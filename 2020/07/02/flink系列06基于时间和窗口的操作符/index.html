<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>flink系列06基于时间和窗口的操作符 | MasterYangBlog</title><meta name="description" content="flink系列06基于时间和窗口的操作符"><meta name="keywords" content="教程,大数据,flink"><meta name="author" content="Yang4"><meta name="copyright" content="Yang4"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="flink系列06基于时间和窗口的操作符"><meta name="twitter:description" content="flink系列06基于时间和窗口的操作符"><meta name="twitter:image" content="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg"><meta property="og:type" content="article"><meta property="og:title" content="flink系列06基于时间和窗口的操作符"><meta property="og:url" content="https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9706%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/"><meta property="og:site_name" content="MasterYangBlog"><meta property="og:description" content="flink系列06基于时间和窗口的操作符"><meta property="og:image" content="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9706%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/"><link rel="prev" title="flink系列07有状态算子和应用" href="https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9707%E6%9C%89%E7%8A%B6%E6%80%81%E7%AE%97%E5%AD%90%E5%92%8C%E5%BA%94%E7%94%A8/"><link rel="next" title="flume源码修改之flumeTailDirSource兼容log4j" href="https://masteryang4.github.io/2020/06/30/flume%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8BflumeTailDirSource%E5%85%BC%E5%AE%B9log4j/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://masteryang4.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="MasterYangBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">MasterYangBlog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/n.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">66</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">46</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">25</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#第六章，基于时间和窗口的操作符"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">第六章，基于时间和窗口的操作符</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#设置时间属性"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">设置时间属性</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#指定时间戳和产生水位线"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">指定时间戳和产生水位线</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#周期性的生成水位线"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">周期性的生成水位线</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何产生不规则的水位线"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">如何产生不规则的水位线</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Process-Function-Low-Level-API"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">Process Function(Low-Level API)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TimerService-and-Timers"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">TimerService and Timers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#将事件发送到侧输出-Emitting-to-Side-Outputs"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">将事件发送到侧输出(Emitting to Side Outputs)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#CoProcessFunction"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">CoProcessFunction</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#窗口操作符-Window-Operators"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">窗口操作符(Window Operators)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#定义窗口操作符"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">定义窗口操作符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#内置的窗口分配器-built-in-window-assigner"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">内置的窗口分配器(built-in window assigner)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调用窗口计算函数"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">调用窗口计算函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#自定义窗口操作符-windows-operators"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">自定义窗口操作符(windows operators)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#基于时间的双流Join"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">基于时间的双流Join</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基于间隔的Join"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">基于间隔的Join</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基于窗口的Join"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">基于窗口的Join</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#处理迟到的元素-Handling-Late-Data"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">处理迟到的元素(Handling Late Data)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#抛弃迟到元素"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">抛弃迟到元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#重定向迟到元素"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">重定向迟到元素</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#使用迟到元素更新窗口计算结果-Updating-Results-by-Including-Late-Events"><span class="toc_mobile_items-number">1.5.3.</span> <span class="toc_mobile_items-text">使用迟到元素更新窗口计算结果(Updating Results by Including Late Events)</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章，基于时间和窗口的操作符"><span class="toc-number">1.</span> <span class="toc-text">第六章，基于时间和窗口的操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设置时间属性"><span class="toc-number">1.1.</span> <span class="toc-text">设置时间属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指定时间戳和产生水位线"><span class="toc-number">1.1.1.</span> <span class="toc-text">指定时间戳和产生水位线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#周期性的生成水位线"><span class="toc-number">1.1.2.</span> <span class="toc-text">周期性的生成水位线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何产生不规则的水位线"><span class="toc-number">1.1.3.</span> <span class="toc-text">如何产生不规则的水位线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Process-Function-Low-Level-API"><span class="toc-number">1.2.</span> <span class="toc-text">Process Function(Low-Level API)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TimerService-and-Timers"><span class="toc-number">1.2.1.</span> <span class="toc-text">TimerService and Timers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将事件发送到侧输出-Emitting-to-Side-Outputs"><span class="toc-number">1.2.2.</span> <span class="toc-text">将事件发送到侧输出(Emitting to Side Outputs)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CoProcessFunction"><span class="toc-number">1.2.3.</span> <span class="toc-text">CoProcessFunction</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#窗口操作符-Window-Operators"><span class="toc-number">1.3.</span> <span class="toc-text">窗口操作符(Window Operators)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义窗口操作符"><span class="toc-number">1.3.1.</span> <span class="toc-text">定义窗口操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内置的窗口分配器-built-in-window-assigner"><span class="toc-number">1.3.2.</span> <span class="toc-text">内置的窗口分配器(built-in window assigner)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用窗口计算函数"><span class="toc-number">1.3.3.</span> <span class="toc-text">调用窗口计算函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义窗口操作符-windows-operators"><span class="toc-number">1.3.4.</span> <span class="toc-text">自定义窗口操作符(windows operators)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基于时间的双流Join"><span class="toc-number">1.4.</span> <span class="toc-text">基于时间的双流Join</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基于间隔的Join"><span class="toc-number">1.4.1.</span> <span class="toc-text">基于间隔的Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于窗口的Join"><span class="toc-number">1.4.2.</span> <span class="toc-text">基于窗口的Join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理迟到的元素-Handling-Late-Data"><span class="toc-number">1.5.</span> <span class="toc-text">处理迟到的元素(Handling Late Data)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抛弃迟到元素"><span class="toc-number">1.5.1.</span> <span class="toc-text">抛弃迟到元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定向迟到元素"><span class="toc-number">1.5.2.</span> <span class="toc-text">重定向迟到元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用迟到元素更新窗口计算结果-Updating-Results-by-Including-Late-Events"><span class="toc-number">1.5.3.</span> <span class="toc-text">使用迟到元素更新窗口计算结果(Updating Results by Including Late Events)</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">flink系列06基于时间和窗口的操作符</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-07-02<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-07-02</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/">flink</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="第六章，基于时间和窗口的操作符"><a href="#第六章，基于时间和窗口的操作符" class="headerlink" title="第六章，基于时间和窗口的操作符"></a>第六章，基于时间和窗口的操作符</h1><p>在本章，我们将要学习DataStream API中处理时间和基于时间的操作符，例如窗口操作符。</p>
<p>首先，我们会学习如何定义时间属性，时间戳和水位线。然后我们将会学习底层操作process function，它可以让我们访问时间戳和水位线，以及注册定时器事件。接下来，我们将会使用Flink的window API，它提供了通常使用的各种窗口类型的内置实现。我们将会学到如何进行用户自定义窗口操作符，以及窗口的核心功能：assigners（分配器）、triggers（触发器）和evictors（清理器）。最后，我们将讨论如何基于时间来做流的联结查询，以及处理迟到事件的策略。</p>
<h2 id="设置时间属性"><a href="#设置时间属性" class="headerlink" title="设置时间属性"></a>设置时间属性</h2><p>如果我们想要在分布式流处理应用程序中定义有关时间的操作，彻底理解时间的语义是非常重要的。当我们指定了一个窗口去收集某1分钟内的数据时，这个长度为1分钟的桶中，到底应该包含哪些数据？在DataStream API中，我们将使用时间属性来告诉Flink：当我们创建窗口时，我们如何定义时间。时间属性是<code>StreamExecutionEnvironment</code>的一个属性，有以下值：</p>
<p><em>ProcessingTime</em></p>
<blockquote>
<p>机器时间在分布式系统中又叫做“墙上时钟”。</p>
</blockquote>
<p>当操作符执行时，此操作符看到的时间是操作符所在机器的机器时间。Processing-time window的触发取决于机器时间，窗口包含的元素也是那个机器时间段内到达的元素。通常情况下，窗口操作符使用processing time会导致不确定的结果，因为基于机器时间的窗口中收集的元素取决于元素到达的速度快慢。使用processing time会为程序提供极低的延迟，因为无需等待水位线的到达。</p>
<blockquote>
<p>如果要追求极限的低延迟，请使用processing time。</p>
</blockquote>
<p><em>EventTime</em></p>
<p>当操作符执行时，操作符看的当前时间是由流中元素所携带的信息决定的。流中的每一个元素都必须包含时间戳信息。而系统的逻辑时钟由水位线(Watermark)定义。我们之前学习过，时间戳要么在事件进入流处理程序之前已经存在，要么就需要在程序的数据源（source）处进行分配。当水位线宣布特定时间段的数据都已经到达，事件时间窗口将会被触发计算。即使数据到达的顺序是乱序的，事件时间窗口的计算结果也将是确定性的。窗口的计算结果并不取决于元素到达的快与慢。</p>
<blockquote>
<p>当水位线超过事件时间窗口的结束时间时，窗口将会闭合，不再接收数据，并触发计算。</p>
</blockquote>
<p><em>IngestionTime</em></p>
<p>当事件进入source操作符时，source操作符所在机器的机器时间，就是此事件的“摄入时间”（IngestionTime），并同时产生水位线。IngestionTime相当于EventTime和ProcessingTime的混合体。一个事件的IngestionTime其实就是它进入流处理器中的时间。</p>
<blockquote>
<p>IngestionTime没什么价值，既有EventTime的执行效率（比较低），有没有EventTime计算结果的准确性。</p>
</blockquote>
<p>下面的例子展示了如何设置事件时间。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AverageSensorReadings</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">    <span class="keyword">val</span> sensorData: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env.addSource(...)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果要使用processing time，将<code>TimeCharacteristic.EventTime</code>替换为<code>TimeCharacteristic.ProcessingTIme</code>就可以了。</p>
<h3 id="指定时间戳和产生水位线"><a href="#指定时间戳和产生水位线" class="headerlink" title="指定时间戳和产生水位线"></a>指定时间戳和产生水位线</h3><p>如果使用事件时间，那么流中的事件必须包含这个事件真正发生的时间。使用了事件时间的流必须携带水位线。</p>
<p>时间戳和水位线的单位是毫秒，记时从<code>1970-01-01T00:00:00Z</code>开始。到达某个操作符的水位线就会告知这个操作符：小于等于水位线中携带的时间戳的事件都已经到达这个操作符了。时间戳和水位线可以由<code>SourceFunction</code>产生，或者由用户自定义的时间戳分配器和水位线产生器来生成。</p>
<p>Flink暴露了TimestampAssigner接口供我们实现，使我们可以自定义如何从事件数据中抽取时间戳。一般来说，时间戳分配器需要在source操作符后马上进行调用。</p>
<blockquote>
<p>因为时间戳分配器看到的元素的顺序应该和source操作符产生数据的顺序是一样的，否则就乱了。这就是为什么我们经常将source操作符的并行度设置为1的原因。</p>
</blockquote>
<p>也就是说，任何分区操作都会将元素的顺序打乱，例如：并行度改变，keyBy()操作等等。</p>
<p>所以最佳实践是：在尽量接近数据源source操作符的地方分配时间戳和产生水位线，甚至最好在SourceFunction中分配时间戳和产生水位线。当然在分配时间戳和产生水位线之前可以对流进行map和filter操作是没问题的，也就是说必须是窄依赖。</p>
<p>以下这种写法是可以的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream = env</span><br><span class="line">  .addSource(...)</span><br><span class="line">  .map(...)</span><br><span class="line">  .filter(...)</span><br><span class="line">  .assignTimestampsAndWatermarks(...)</span><br></pre></td></tr></table></figure></div>

<p>下面的例子展示了首先filter流，然后再分配时间戳和水位线。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 从调用时刻开始给env创建的每一个stream追加时间特征</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env</span><br><span class="line">  .addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>)</span><br><span class="line">  .filter(r =&gt; r.temperature &gt; <span class="number">25</span>)</span><br><span class="line">  .assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">MyAssigner</span>())</span><br></pre></td></tr></table></figure></div>

<p>MyAssigner有两种类型</p>
<ul>
<li>AssignerWithPeriodicWatermarks</li>
<li>AssignerWithPunctuatedWatermarks</li>
</ul>
<p>以上两个接口都继承自TimestampAssigner。</p>
<h3 id="周期性的生成水位线"><a href="#周期性的生成水位线" class="headerlink" title="周期性的生成水位线"></a>周期性的生成水位线</h3><p>周期性的生成水位线：系统会周期性的将水位线插入到流中（水位线也是一种特殊的事件!）。默认周期是200毫秒，也就是说，系统会每隔200毫秒就往流中插入一次水位线。</p>
<blockquote>
<p>这里的200毫秒是机器时间！</p>
</blockquote>
<p>可以使用<code>ExecutionConfig.setAutoWatermarkInterval()</code>方法进行设置。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"><span class="comment">// 每隔5秒产生一个水位线</span></span><br><span class="line">env.getConfig.setAutoWatermarkInterval(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure></div>

<p>上面的例子产生水位线的逻辑：每隔5秒钟，Flink会调用AssignerWithPeriodicWatermarks中的getCurrentWatermark()方法。如果方法返回的时间戳大于之前水位线的时间戳，新的水位线会被插入到流中。这个检查保证了水位线是单调递增的。如果方法返回的时间戳小于等于之前水位线的时间戳，则不会产生新的水位线。</p>
<p>例子，自定义一个周期性的时间戳抽取</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicAssigner</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span> <span class="comment">// 延时为1分钟</span></span><br><span class="line">  <span class="keyword">var</span> maxTs: <span class="type">Long</span> = <span class="type">Long</span>.<span class="type">MinValue</span> + bound <span class="comment">// 观察到的最大时间戳</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Watermark</span>(maxTs - bound)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>, previousTS: <span class="type">Long</span>) = &#123;</span><br><span class="line">    maxTs = maxTs.max(r.timestamp)</span><br><span class="line">    r.timestamp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果我们事先得知数据流的时间戳是单调递增的，也就是说没有乱序。我们可以使用assignAscendingTimestamps，方法会直接使用数据的时间戳生成水位线。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val stream: DataStream[SensorReading] &#x3D; ...</span><br><span class="line">val withTimestampsAndWatermarks &#x3D; stream</span><br><span class="line">  .assignAscendingTimestamps(e &#x3D;&gt; e.timestamp)</span><br></pre></td></tr></table></figure></div>

<p>如果我们能大致估算出数据流中的事件的最大延迟时间，可以使用如下代码：</p>
<blockquote>
<p>最大延迟时间就是当前到达的事件的事件时间和之前所有到达的事件中最大时间戳的差。</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> withTimestampsAndWatermarks = stream.assignTimestampsAndWatermarks(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">SensorTimeAssigner</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorTimeAssigner</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    <span class="type">Time</span>.seconds(5</span>)</span></span><br><span class="line"><span class="class">  ) </span>&#123;</span><br><span class="line">    <span class="comment">// 抽取时间戳</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>): <span class="type">Long</span> = r.timestamp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上代码设置了最大延迟时间为5秒。</p>
<h3 id="如何产生不规则的水位线"><a href="#如何产生不规则的水位线" class="headerlink" title="如何产生不规则的水位线"></a>如何产生不规则的水位线</h3><p>有时候输入流中会包含一些用于指示系统进度的特殊元组或标记。Flink为此类情形以及可根据输入元素生成水位线的情形提供了<code>AssignerWithPunctuatedWatermarks</code>接口。该接口中的<code>checkAndGetNextWatermark()</code>方法会在针对每个事件的<code>extractTimestamp()</code>方法后立即调用。它可以决定是否生成一个新的水位线。如果该方法返回一个非空、且大于之前值的水位线，算子就会将这个新水位线发出。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PunctuatedAssigner</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AssignerWithPunctuatedWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每来一条数据就调用一次</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkAndGetNextWatermark</span></span>(r: <span class="type">SensorReading</span>,</span><br><span class="line">                                        extractedTS: <span class="type">Long</span>): <span class="type">Watermark</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.id == <span class="string">"sensor_1"</span>) &#123;</span><br><span class="line">      <span class="comment">// 抽取的时间戳 - 最大延迟时间</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">Watermark</span>(extractedTS - bound)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每来一条数据就调用一次</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>,</span><br><span class="line">                                previousTS: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    r.timestamp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>现在我们已经知道如何使用 <code>TimestampAssigner</code> 来产生水位线了。现在我们要讨论一下水位线会对我们的程序产生什么样的影响。</p>
<p>水位线用来平衡延迟和计算结果的正确性。水位线告诉我们，在触发计算（例如关闭窗口并触发窗口计算）之前，我们需要等待事件多长时间。基于事件时间的操作符根据水位线来衡量系统的逻辑时间的进度。</p>
<p>完美的水位线永远不会错：时间戳小于水位线的事件不会再出现。在特殊情况下(例如非乱序事件流)，最近一次事件的时间戳就可能是完美的水位线。启发式水位线则相反，它只估计时间，因此有可能出错，即迟到的事件(其时间戳小于水位线标记时间)晚于水位线出现。针对启发式水位线，Flink提供了处理迟到元素的机制。</p>
<p>设定水位线通常需要用到领域知识。举例来说，如果知道事件的迟到时间不会超过5秒，就可以将水位线标记时间设为收到的最大时间戳减去5秒。另一种做法是，采用一个Flink作业监控事件流，学习事件的迟到规律，并以此构建水位线生成模型。</p>
<p>如果最大延迟时间设置的很大，计算出的结果会更精确，但收到计算结果的速度会很慢，同时系统会缓存大量的数据，并对系统造成比较大的压力。如果最大延迟时间设置的很小，那么收到计算结果的速度会很快，但可能收到错误的计算结果。不过Flink处理迟到数据的机制可以解决这个问题。上述问题看起来很复杂，但是恰恰符合现实世界的规律：大部分真实的事件流都是乱序的，并且通常无法了解它们的乱序程度(因为理论上不能预见未来)。水位线是唯一让我们直面乱序事件流并保证正确性的机制; 否则只能选择忽视事实，假装错误的结果是正确的。</p>
<blockquote>
<p>思考题一：实时程序，要求实时性非常高，并且结果并不一定要求非常准确，那么应该怎么办？ 直接使用处理时间。 思考题二：如果要进行时间旅行，也就是要还原以前的数据集当时的流的状态，应该怎么办？ 使用事件时间。使用Hive将数据集先按照时间戳升序排列，再将最大延迟时间设置为0。</p>
</blockquote>
<h2 id="Process-Function-Low-Level-API"><a href="#Process-Function-Low-Level-API" class="headerlink" title="Process Function(Low-Level API)"></a>Process Function(Low-Level API)</h2><p>我们之前学习的转换算子是无法访问事件的时间戳信息和水位线信息的。而这在一些应用场景下，极为重要。例如MapFunction这样的map转换算子就无法访问时间戳或者当前事件的事件时间。</p>
<p>基于此，DataStream API提供了一系列的Low-Level转换算子。可以访问时间戳、水位线以及注册定时事件。还可以输出特定的一些事件，例如超时事件等。Process Function用来构建事件驱动的应用以及实现自定义的业务逻辑(使用之前的window函数和转换算子无法实现)。例如，Flink-SQL就是使用Process Function实现的。</p>
<p>Flink提供了8个Process Function：</p>
<ul>
<li>ProcessFunction</li>
<li>KeyedProcessFunction</li>
<li>CoProcessFunction</li>
<li>ProcessJoinFunction</li>
<li>BroadcastProcessFunction</li>
<li>KeyedBroadcastProcessFunction</li>
<li>ProcessWindowFunction</li>
<li>ProcessAllWindowFunction</li>
</ul>
<p>我们这里详细介绍一下KeyedProcessFunction。</p>
<p>KeyedProcessFunction用来操作KeyedStream。KeyedProcessFunction会处理流的每一个元素，输出为0个、1个或者多个元素。所有的Process Function都继承自RichFunction接口，所以都有open()、close()和getRuntimeContext()等方法。而KeyedProcessFunction[KEY, IN, OUT]还额外提供了两个方法:</p>
<ul>
<li>processElement(v: IN, ctx: Context, out: Collector[OUT]), 流中的每一个元素都会调用这个方法，调用结果将会放在Collector数据类型中输出。Context可以访问元素的时间戳，元素的key，以及TimerService时间服务。Context还可以将结果输出到别的流(side outputs)。</li>
<li>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])是一个回调函数。当之前注册的定时器触发时调用。参数timestamp为定时器所设定的触发的时间戳。Collector为输出结果的集合。OnTimerContext和processElement的Context参数一样，提供了上下文的一些信息，例如firing trigger的时间信息(事件时间或者处理时间)。</li>
</ul>
<h3 id="TimerService-and-Timers"><a href="#TimerService-and-Timers" class="headerlink" title="TimerService and Timers"></a>TimerService and Timers</h3><p>Context和OnTimerContext所持有的TimerService对象拥有以下方法:</p>
<ul>
<li><code>currentProcessingTime(): Long</code> 返回当前处理时间</li>
<li><code>currentWatermark(): Long</code> 返回当前水位线的时间戳</li>
<li><code>registerProcessingTimeTimer(timestamp: Long): Unit</code> 会注册当前key的processing time的timer。当processing time到达定时时间时，触发timer。</li>
<li><code>registerEventTimeTimer(timestamp: Long): Unit</code> 会注册当前key的event time timer。当水位线大于等于定时器注册的时间时，触发定时器执行回调函数。</li>
<li><code>deleteProcessingTimeTimer(timestamp: Long): Unit</code> 删除之前注册处理时间定时器。如果没有这个时间戳的定时器，则不执行。</li>
<li><code>deleteEventTimeTimer(timestamp: Long): Unit</code> 删除之前注册的事件时间定时器，如果没有此时间戳的定时器，则不执行。</li>
</ul>
<p>当定时器timer触发时，执行回调函数onTimer()。processElement()方法和onTimer()方法是同步（不是异步）方法，这样可以避免并发访问和操作状态。</p>
<blockquote>
<p>定时器timer只能在KeyedStream上面使用。</p>
</blockquote>
<p>针对每一个key和timestamp，只能注册一个定期器。也就是说，每一个key可以注册多个定时器，但在每一个时间戳只能注册一个定时器。KeyedProcessFunction默认将所有定时器的时间戳放在一个优先队列中。在Flink做检查点操作时，定时器也会被保存到状态后端中。</p>
<p>举个例子说明KeyedProcessFunction如何操作KeyedStream。</p>
<p>下面的程序展示了如何监控温度传感器的温度值，如果温度值在一秒钟之内(processing time)连续上升，报警。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> warnings = readings</span><br><span class="line">  <span class="comment">// key by sensor id</span></span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  <span class="comment">// apply ProcessFunction to monitor temperatures</span></span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TempIncreaseAlertFunction</span>)</span><br></pre></td></tr></table></figure></div>

<p>看一下TempIncreaseAlertFunction如何实现, 程序中使用了ValueState这样一个状态变量, 后面会详细讲解。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempIncreaseAlertFunction</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 保存上一个传感器温度值</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> lastTemp: <span class="type">ValueState</span>[<span class="type">Double</span>] = getRuntimeContext.getState(</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Double</span>](<span class="string">"lastTemp"</span>, <span class="type">Types</span>.of[<span class="type">Double</span>])</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存注册的定时器的时间戳</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> currentTimer: <span class="type">ValueState</span>[<span class="type">Long</span>] = getRuntimeContext.getState(</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Long</span>](<span class="string">"timer"</span>, <span class="type">Types</span>.of[<span class="type">Long</span>])</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(r: <span class="type">SensorReading</span>,</span><br><span class="line">                              ctx: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>,</span><br><span class="line">                                <span class="type">SensorReading</span>, <span class="type">String</span>]#<span class="type">Context</span>,</span><br><span class="line">                              out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// get previous temperature</span></span><br><span class="line">    <span class="comment">// 取出上一次的温度</span></span><br><span class="line">    <span class="keyword">val</span> prevTemp = lastTemp.value()</span><br><span class="line">    <span class="comment">// update last temperature</span></span><br><span class="line">    <span class="comment">// 将当前温度更新到上一次的温度这个变量中</span></span><br><span class="line">    lastTemp.update(r.temperature)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> curTimerTimestamp = currentTimer.value()</span><br><span class="line">    <span class="keyword">if</span> (prevTemp == <span class="number">0.0</span> || r.temperature &lt; prevTemp) &#123;</span><br><span class="line">      <span class="comment">// temperature decreased; delete current timer</span></span><br><span class="line">      <span class="comment">// 温度下降或者是第一个温度值，删除定时器</span></span><br><span class="line">      ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp)</span><br><span class="line">      <span class="comment">// 清空状态变量</span></span><br><span class="line">      currentTimer.clear()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// temperature increased and we have not set a timer yet</span></span><br><span class="line">      <span class="comment">// set processing time timer for now + 1 second</span></span><br><span class="line">      <span class="comment">// 温度上升且我们并没有设置定时器</span></span><br><span class="line">      <span class="keyword">val</span> timerTs = ctx.timerService().currentProcessingTime() + <span class="number">1000</span></span><br><span class="line">      ctx.timerService().registerProcessingTimeTimer(timerTs)</span><br><span class="line">      <span class="comment">// remember current timer</span></span><br><span class="line">      currentTimer.update(timerTs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onTimer</span></span>(ts: <span class="type">Long</span>,</span><br><span class="line">                       ctx: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>,</span><br><span class="line">                        <span class="type">SensorReading</span>, <span class="type">String</span>]#<span class="type">OnTimerContext</span>,</span><br><span class="line">                       out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    out.collect(<span class="string">"传感器id为: "</span></span><br><span class="line">      + ctx.getCurrentKey</span><br><span class="line">      + <span class="string">"的传感器温度值已经连续1s上升了。"</span>)</span><br><span class="line">    currentTimer.clear()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="将事件发送到侧输出-Emitting-to-Side-Outputs"><a href="#将事件发送到侧输出-Emitting-to-Side-Outputs" class="headerlink" title="将事件发送到侧输出(Emitting to Side Outputs)"></a>将事件发送到侧输出(Emitting to Side Outputs)</h3><p>大部分的DataStream API的算子的输出是单一输出，也就是某种数据类型的流。除了split算子，可以将一条流分成多条流，这些流的数据类型也都相同。process function的side outputs功能可以产生多条流，并且这些流的数据类型可以不一样。一个side output可以定义为OutputTag[X]对象，X是输出流的数据类型。process function可以通过Context对象发射一个事件到一个或者多个side outputs。</p>
<p>例子</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> monitoredReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = readings</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">FreezingMonitor</span>)</span><br><span class="line"></span><br><span class="line">monitoredReadings</span><br><span class="line">  .getSideOutput(<span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">"freezing-alarms"</span>))</span><br><span class="line">  .print()</span><br><span class="line"></span><br><span class="line">readings.print()</span><br></pre></td></tr></table></figure></div>

<p>接下来我们实现FreezingMonitor函数，用来监控传感器温度值，将温度值低于32F的温度输出到side output。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreezingMonitor</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// define a side output tag</span></span><br><span class="line">  <span class="comment">// 定义一个侧输出标签</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> freezingAlarmOutput: <span class="type">OutputTag</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">"freezing-alarms"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(r: <span class="type">SensorReading</span>,</span><br><span class="line">                              ctx: <span class="type">ProcessFunction</span>[<span class="type">SensorReading</span>,</span><br><span class="line">                                <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">                              out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// emit freezing alarm if temperature is below 32F</span></span><br><span class="line">    <span class="keyword">if</span> (r.temperature &lt; <span class="number">32.0</span>) &#123;</span><br><span class="line">      ctx.output(freezingAlarmOutput, <span class="string">s"Freezing Alarm for <span class="subst">$&#123;r.id&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// forward all readings to the regular output</span></span><br><span class="line">    out.collect(r)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="CoProcessFunction"><a href="#CoProcessFunction" class="headerlink" title="CoProcessFunction"></a>CoProcessFunction</h3><p>对于两条输入流，DataStream API提供了CoProcessFunction这样的low-level操作。CoProcessFunction提供了操作每一个输入流的方法: processElement1()和processElement2()。类似于ProcessFunction，这两种方法都通过Context对象来调用。这个Context对象可以访问事件数据，定时器时间戳，TimerService，以及side outputs。CoProcessFunction也提供了onTimer()回调函数。下面的例子展示了如何使用CoProcessFunction来合并两条流。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ingest sensor stream</span></span><br><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter switches enable forwarding of readings</span></span><br><span class="line"><span class="keyword">val</span> filterSwitches: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>)] = env</span><br><span class="line">  .fromCollection(<span class="type">Seq</span>(</span><br><span class="line">    (<span class="string">"sensor_2"</span>, <span class="number">10</span> * <span class="number">1000</span>L),</span><br><span class="line">    (<span class="string">"sensor_7"</span>, <span class="number">60</span> * <span class="number">1000</span>L)</span><br><span class="line">  ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> forwardedReadings = readings</span><br><span class="line">  <span class="comment">// connect readings and switches</span></span><br><span class="line">  .connect(filterSwitches)</span><br><span class="line">  <span class="comment">// key by sensor ids</span></span><br><span class="line">  .keyBy(_.id, _._1)</span><br><span class="line">  <span class="comment">// apply filtering CoProcessFunction</span></span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">ReadingFilter</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadingFilter</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">CoProcessFunction</span>[<span class="type">SensorReading</span>,</span></span><br><span class="line"><span class="class">    (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// switch to enable forwarding</span></span><br><span class="line">  <span class="comment">// 传送数据的开关</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> forwardingEnabled: <span class="type">ValueState</span>[<span class="type">Boolean</span>] = getRuntimeContext</span><br><span class="line">    .getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](<span class="string">"filterSwitch"</span>, <span class="type">Types</span>.of[<span class="type">Boolean</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hold timestamp of currently active disable timer</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> disableTimer: <span class="type">ValueState</span>[<span class="type">Long</span>] = getRuntimeContext</span><br><span class="line">    .getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Long</span>](<span class="string">"timer"</span>, <span class="type">Types</span>.of[<span class="type">Long</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement1</span></span>(reading: <span class="type">SensorReading</span>,</span><br><span class="line">                               ctx: <span class="type">CoProcessFunction</span>[<span class="type">SensorReading</span>,</span><br><span class="line">                                (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">                               out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// check if we may forward the reading</span></span><br><span class="line">    <span class="comment">// 决定我们是否要将数据继续传下去</span></span><br><span class="line">    <span class="keyword">if</span> (forwardingEnabled.value()) &#123;</span><br><span class="line">      out.collect(reading)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement2</span></span>(switch: (<span class="type">String</span>, <span class="type">Long</span>),</span><br><span class="line">                               ctx: <span class="type">CoProcessFunction</span>[<span class="type">SensorReading</span>,</span><br><span class="line">                                (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">                               out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// enable reading forwarding</span></span><br><span class="line">    <span class="comment">// 允许继续传输数据</span></span><br><span class="line">    forwardingEnabled.update(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// set disable forward timer</span></span><br><span class="line">    <span class="keyword">val</span> timerTimestamp = ctx.timerService().currentProcessingTime()</span><br><span class="line">     + switch._2</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">val</span> curTimerTimestamp = disableTimer.value()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timerTimestamp &gt; curTimerTimestamp) &#123;</span><br><span class="line">      <span class="comment">// remove current timer and register new timer</span></span><br><span class="line">      ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp)</span><br><span class="line">      ctx.timerService().registerProcessingTimeTimer(timerTimestamp)</span><br><span class="line">      disableTimer.update(timerTimestamp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onTimer</span></span>(ts: <span class="type">Long</span>,</span><br><span class="line">                       ctx: <span class="type">CoProcessFunction</span>[<span class="type">SensorReading</span>,</span><br><span class="line">                        (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">SensorReading</span>]#<span class="type">OnTimerContext</span>,</span><br><span class="line">                       out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">     <span class="comment">// remove all state; forward switch will be false by default</span></span><br><span class="line">     forwardingEnabled.clear()</span><br><span class="line">     disableTimer.clear()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="窗口操作符-Window-Operators"><a href="#窗口操作符-Window-Operators" class="headerlink" title="窗口操作符(Window Operators)"></a>窗口操作符(Window Operators)</h2><p>窗口操作是流处理程序中很常见的操作。窗口操作允许我们在无限流上的一段有界区间上面做聚合之类的操作。而我们使用基于时间的逻辑来定义区间。窗口操作符提供了一种将数据放进一个桶，并根据桶中的数据做计算的方法。例如，我们可以将事件放进5分钟的滚动窗口中，然后计数。</p>
<blockquote>
<p>无限流转化成有限数据的方法：使用窗口。</p>
</blockquote>
<h3 id="定义窗口操作符"><a href="#定义窗口操作符" class="headerlink" title="定义窗口操作符"></a>定义窗口操作符</h3><p>Window算子可以在keyed stream或者nokeyed stream上面使用。</p>
<p>创建一个Window算子，需要指定两个部分：</p>
<ol>
<li><code>window assigner</code>定义了流的元素如何分配到window中。window assigner将会产生一条WindowedStream(或者AllWindowedStream，如果是nonkeyed DataStream的话)</li>
<li>window function用来处理WindowedStream(AllWindowedStream)中的元素。</li>
</ol>
<p>下面的代码说明了如何使用窗口操作符。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .window(...)  <span class="comment">// 指定window assigner</span></span><br><span class="line">  .reduce/aggregate/process(...) <span class="comment">// 指定window function</span></span><br><span class="line"></span><br><span class="line">stream</span><br><span class="line">  .windowAll(...) <span class="comment">// 指定window assigner</span></span><br><span class="line">  .reduce/aggregate/process(...) <span class="comment">// 指定window function</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>我们的学习重点是Keyed WindowedStream。</p>
</blockquote>
<h3 id="内置的窗口分配器-built-in-window-assigner"><a href="#内置的窗口分配器-built-in-window-assigner" class="headerlink" title="内置的窗口分配器(built-in window assigner)"></a>内置的窗口分配器(built-in window assigner)</h3><p>窗口分配器将会根据事件的事件时间或者处理时间来将事件分配到对应的窗口中去。窗口包含开始时间和结束时间这两个时间戳。</p>
<p>所有的窗口分配器都包含一个默认的触发器：</p>
<ul>
<li>对于事件时间：当水位线超过窗口结束时间，触发窗口的求值操作。</li>
<li>对于处理时间：当机器时间超过窗口结束时间，触发窗口的求值操作。</li>
</ul>
<blockquote>
<p>需要注意的是：当处于某个窗口的第一个事件到达的时候，这个窗口才会被创建。Flink不会对空窗口求值。</p>
</blockquote>
<p>Flink创建的窗口类型是<code>TimeWindow</code>，包含开始时间和结束时间，区间是左闭右开的，也就是说包含开始时间戳，不包含结束时间戳。</p>
<p><em>滚动窗口(tumbling windows)</em></p>
<p><a href="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0601.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0601.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sensorData: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  <span class="comment">// group readings in 1s event-time windows</span></span><br><span class="line">  .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">1</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  <span class="comment">// group readings in 1s processing-time windows</span></span><br><span class="line">  .window(<span class="type">TumblingProcessingTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">1</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实就是之前的</span></span><br><span class="line"><span class="comment">// shortcut for window.(TumblingEventTimeWindows.of(size))</span></span><br><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">1</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br></pre></td></tr></table></figure></div>

<p>默认情况下，滚动窗口会和<code>1970-01-01-00:00:00.000</code>对齐，例如一个1小时的滚动窗口将会定义以下开始时间的窗口：00:00:00，01:00:00，02:00:00，等等。</p>
<p><em>滑动窗口(sliding window)</em></p>
<p>对于滑动窗口，我们需要指定窗口的大小和滑动的步长。当滑动步长小于窗口大小时，窗口将会出现重叠，而元素会被分配到不止一个窗口中去。当滑动步长大于窗口大小时，一些元素可能不会被分配到任何窗口中去，会被直接丢弃。</p>
<p>下面的代码定义了窗口大小为1小时，滑动步长为15分钟的窗口。每一个元素将被分配到4个窗口中去。</p>
<p><a href="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0602.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0602.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> slidingAvgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .window(</span><br><span class="line">    <span class="type">SlidingEventTimeWindows</span>.of(<span class="type">Time</span>.hours(<span class="number">1</span>), <span class="type">Time</span>.minutes(<span class="number">15</span>))</span><br><span class="line">  )</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> slidingAvgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .window(</span><br><span class="line">    <span class="type">SlidingProcessingTimeWindows</span>.of(<span class="type">Time</span>.hours(<span class="number">1</span>), <span class="type">Time</span>.minutes(<span class="number">15</span>))</span><br><span class="line">  )</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> slidingAvgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.hours(<span class="number">1</span>), <span class="type">Time</span>.minutes(<span class="number">15</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br></pre></td></tr></table></figure></div>

<p><em>会话窗口(session windows)</em></p>
<p>会话窗口不可能重叠，并且会话窗口的大小也不是固定的。不活跃的时间长度定义了会话窗口的界限。不活跃的时间是指这段时间没有元素到达。下图展示了元素如何被分配到会话窗口。</p>
<p><a href="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0603.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0603.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sessionWindows = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .window(<span class="type">EventTimeSessionWindows</span>.withGap(<span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">  .process(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sessionWindows = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .window(<span class="type">ProcessingTimeSessionWindows</span>.withGap(<span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">  .process(...)</span><br></pre></td></tr></table></figure></div>

<p>由于会话窗口的开始时间和结束时间取决于接收到的元素，所以窗口分配器无法立即将所有的元素分配到正确的窗口中去。相反，会话窗口分配器最开始时先将每一个元素分配到它自己独有的窗口中去，窗口开始时间是这个元素的时间戳，窗口大小是session gap的大小。接下来，会话窗口分配器会将出现重叠的窗口合并成一个窗口。</p>
<h3 id="调用窗口计算函数"><a href="#调用窗口计算函数" class="headerlink" title="调用窗口计算函数"></a>调用窗口计算函数</h3><p>window functions定义了窗口中数据的计算逻辑。有两种计算逻辑：</p>
<ol>
<li>增量聚合函数(Incremental aggregation functions)：当一个事件被添加到窗口时，触发函数计算，并且更新window的状态(单个值)。最终聚合的结果将作为输出。ReduceFunction和AggregateFunction是增量聚合函数。</li>
<li>全窗口函数(Full window functions)：这个函数将会收集窗口中所有的元素，可以做一些复杂计算。ProcessWindowFunction是window function。</li>
</ol>
<p><em>ReduceFunction</em></p>
<p>例子: 计算每个传感器15s窗口中的温度最小值</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = sensorData</span><br><span class="line">  .map(r =&gt; (r.id, r.temperature))</span><br><span class="line">  .keyBy(_._1)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>))</span><br><span class="line">  .reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</span><br></pre></td></tr></table></figure></div>

<p><em>AggregateFunction</em></p>
<p>先来看接口定义</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">AggregateFunction</span>&lt;<span class="type">IN</span>, <span class="type">ACC</span>, <span class="type">OUT</span>&gt;</span><br><span class="line">  <span class="keyword">extends</span> <span class="type">Function</span>, <span class="type">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create a new accumulator to start a new aggregate</span></span><br><span class="line">  <span class="type">ACC</span> createAccumulator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add an input element to the accumulator and return the accumulator</span></span><br><span class="line">  <span class="type">ACC</span> add(<span class="type">IN</span> value, <span class="type">ACC</span> accumulator);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compute the result from the accumulator and return it.</span></span><br><span class="line">  <span class="type">OUT</span> getResult(<span class="type">ACC</span> accumulator);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// merge two accumulators and return the result.</span></span><br><span class="line">  <span class="type">ACC</span> merge(<span class="type">ACC</span> a, <span class="type">ACC</span> b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>IN是输入元素的类型，ACC是累加器的类型，OUT是输出元素的类型。</p>
<p>例子</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> avgTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = sensorData</span><br><span class="line">  .map(r =&gt; (r.id, r.temperature))</span><br><span class="line">  .keyBy(_._1)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>))</span><br><span class="line">  .aggregate(<span class="keyword">new</span> <span class="type">AvgTempFunction</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An AggregateFunction to compute the average temperature per sensor.</span></span><br><span class="line"><span class="comment">// The accumulator holds the sum of temperatures and an event count.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvgTempFunction</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AggregateFunction</span>[(<span class="type">String</span>, <span class="type">Double</span>),</span></span><br><span class="line"><span class="class">    (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>), (<span class="type">String</span>, <span class="type">Double</span>)] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createAccumulator</span></span>() = &#123;</span><br><span class="line">    (<span class="string">""</span>, <span class="number">0.0</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(in: (<span class="type">String</span>, <span class="type">Double</span>), acc: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">    (in._1, in._2 + acc._2, <span class="number">1</span> + acc._3)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getResult</span></span>(acc: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">    (acc._1, acc._2 / acc._3)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(acc1: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>),</span><br><span class="line">    acc2: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">    (acc1._1, acc1._2 + acc2._2, acc1._3 + acc2._3)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>ProcessWindowFunction</em></p>
<p>一些业务场景，我们需要收集窗口内所有的数据进行计算，例如计算窗口数据的中位数，或者计算窗口数据中出现频率最高的值。这样的需求，使用ReduceFunction和AggregateFunction就无法实现了。这个时候就需要ProcessWindowFunction了。</p>
<p>先来看接口定义</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction&lt;IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window&gt;</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Evaluates the window</span></span><br><span class="line">  void process(<span class="type">KEY</span> key, <span class="type">Context</span> ctx, <span class="type">Iterable</span>&lt;<span class="type">IN</span>&gt; vals, <span class="type">Collector</span>&lt;<span class="type">OUT</span>&gt; out)</span><br><span class="line">    <span class="keyword">throws</span> <span class="type">Exception</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Deletes any custom per-window state when the window is purged</span></span><br><span class="line">  public void clear(<span class="type">Context</span> ctx) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The context holding window metadata</span></span><br><span class="line">  public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Returns the metadata of the window</span></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="type">W</span> window();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the current processing time</span></span><br><span class="line">    public <span class="keyword">abstract</span> long currentProcessingTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the current event-time watermark</span></span><br><span class="line">    public <span class="keyword">abstract</span> long currentWatermark();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State accessor for per-window state</span></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="type">KeyedStateStore</span> windowState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State accessor for per-key global state</span></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="type">KeyedStateStore</span> globalState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emits a record to the side output identified by the OutputTag.</span></span><br><span class="line">    public <span class="keyword">abstract</span> &lt;<span class="type">X</span>&gt; void output(<span class="type">OutputTag</span>&lt;<span class="type">X</span>&gt; outputTag, <span class="type">X</span> value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>process()方法接受的参数为：window的key，Iterable迭代器包含窗口的所有元素，Collector用于输出结果流。Context参数和别的process方法一样。而ProcessWindowFunction的Context对象还可以访问window的元数据(窗口开始和结束时间)，当前处理时间和水位线，per-window state和per-key global state，side outputs。</p>
<ul>
<li>per-window state: 用于保存一些信息，这些信息可以被process()访问，只要process所处理的元素属于这个窗口。</li>
<li>per-key global state: 同一个key，也就是在一条KeyedStream上，不同的window可以访问per-key global state保存的值。</li>
</ul>
<p>例子：计算5s滚动窗口中的最低和最高的温度。输出的元素包含了(流的Key, 最低温度, 最高温度, 窗口结束时间)。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minMaxTempPerWindow: <span class="type">DataStream</span>[<span class="type">MinMaxTemp</span>] = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">HighAndLowTempProcessFunction</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MinMaxTemp</span>(<span class="params">id: <span class="type">String</span>, min: <span class="type">Double</span>, max: <span class="type">Double</span>, endTs: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HighAndLowTempProcessFunction</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[<span class="type">SensorReading</span>,</span></span><br><span class="line"><span class="class">    <span class="type">MinMaxTemp</span>, <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(key: <span class="type">String</span>,</span><br><span class="line">                       ctx: <span class="type">Context</span>,</span><br><span class="line">                       vals: <span class="type">Iterable</span>[<span class="type">SensorReading</span>],</span><br><span class="line">                       out: <span class="type">Collector</span>[<span class="type">MinMaxTemp</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> temps = vals.map(_.temperature)</span><br><span class="line">    <span class="keyword">val</span> windowEnd = ctx.window.getEnd</span><br><span class="line"></span><br><span class="line">    out.collect(<span class="type">MinMaxTemp</span>(key, temps.min, temps.max, windowEnd))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们还可以将ReduceFunction/AggregateFunction和ProcessWindowFunction结合起来使用。ReduceFunction/AggregateFunction做增量聚合，ProcessWindowFunction提供更多的对数据流的访问权限。如果只使用ProcessWindowFunction(底层的实现为将事件都保存在ListState中)，将会非常占用空间。分配到某个窗口的元素将被提前聚合，而当窗口的trigger触发时，也就是窗口收集完数据关闭时，将会把聚合结果发送到ProcessWindowFunction中，这时Iterable参数将会只有一个值，就是前面聚合的值。</p>
<p>例子</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .timeWindow(...)</span><br><span class="line">  .reduce(</span><br><span class="line">    incrAggregator: <span class="type">ReduceFunction</span>[<span class="type">IN</span>],</span><br><span class="line">    function: <span class="type">ProcessWindowFunction</span>[<span class="type">IN</span>, <span class="type">OUT</span>, <span class="type">K</span>, <span class="type">W</span>])</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .timeWindow(...)</span><br><span class="line">  .aggregate(</span><br><span class="line">    incrAggregator: <span class="type">AggregateFunction</span>[<span class="type">IN</span>, <span class="type">ACC</span>, <span class="type">V</span>],</span><br><span class="line">    windowFunction: <span class="type">ProcessWindowFunction</span>[<span class="type">V</span>, <span class="type">OUT</span>, <span class="type">K</span>, <span class="type">W</span>])</span><br></pre></td></tr></table></figure></div>

<p>我们把之前的需求重新使用以上两种方法实现一下。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MinMaxTemp</span>(<span class="params">id: <span class="type">String</span>, min: <span class="type">Double</span>, max: <span class="type">Double</span>, endTs: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">minMaxTempPerWindow2</span></span>: <span class="type">DataStream</span>[<span class="type">MinMaxTemp</span>] = sensorData</span><br><span class="line">  .map(r =&gt; (r.id, r.temperature, r.temperature))</span><br><span class="line">  .keyBy(_._1)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  .reduce(</span><br><span class="line">    (r1: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>), r2: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)) =&gt; &#123;</span><br><span class="line">      (r1._1, r1._2.min(r2._2), r1._3.max(r2._3))</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="type">AssignWindowEndProcessFunction</span>()</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssignWindowEndProcessFunction</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>),</span></span><br><span class="line"><span class="class">    <span class="type">MinMaxTemp</span>, <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(key: <span class="type">String</span>,</span><br><span class="line">                       ctx: <span class="type">Context</span>,</span><br><span class="line">                       minMaxIt: <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)],</span><br><span class="line">                       out: <span class="type">Collector</span>[<span class="type">MinMaxTemp</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> minMax = minMaxIt.head</span><br><span class="line">    <span class="keyword">val</span> windowEnd = ctx.window.getEnd</span><br><span class="line">    out.collect(<span class="type">MinMaxTemp</span>(key, minMax._2, minMax._3, windowEnd))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="自定义窗口操作符-windows-operators"><a href="#自定义窗口操作符-windows-operators" class="headerlink" title="自定义窗口操作符(windows operators)"></a>自定义窗口操作符(windows operators)</h3><p>Flink内置的window operators分配器已经已经足够应付大多数应用场景。尽管如此，如果我们需要实现一些复杂的窗口逻辑，例如：可以发射早到的事件或者碰到迟到的事件就更新窗口的结果，或者窗口的开始和结束决定于特定事件的接收。</p>
<p>DataStream API暴露了接口和方法来自定义窗口操作符。</p>
<ul>
<li>自定义窗口分配器</li>
<li>自定义窗口计算触发器(trigger)</li>
<li>自定义窗口数据清理功能(evictor)</li>
</ul>
<p>当一个事件来到窗口操作符，首先将会传给WindowAssigner来处理。WindowAssigner决定了事件将被分配到哪些窗口。如果窗口不存在，WindowAssigner将会创建一个新的窗口。</p>
<p>如果一个window operator接受了一个增量聚合函数作为参数，例如ReduceFunction或者AggregateFunction，新到的元素将会立即被聚合，而聚合结果result将存储在window中。如果window operator没有使用增量聚合函数，那么新元素将被添加到ListState中，ListState中保存了所有分配给窗口的元素。</p>
<p>新元素被添加到窗口时，这个新元素同时也被传给了window的trigger。trigger定义了window何时准备好求值，何时window被清空。trigger可以基于window被分配的元素和注册的定时器来对窗口的所有元素求值或者在特定事件清空window中所有的元素。</p>
<p>当window operator只接收一个增量聚合函数作为参数时：</p>
<p>当window operator只接收一个全窗口函数作为参数时：</p>
<p>当window operator接收一个增量聚合函数和一个全窗口函数作为参数时：</p>
<p>evictor是一个可选的组件，可以被注入到ProcessWindowFunction之前或者之后调用。evictor可以清除掉window中收集的元素。由于evictor需要迭代所有的元素，所以evictor只能使用在没有增量聚合函数作为参数的情况下。</p>
<p>下面的代码说明了如果使用自定义的trigger和evictor定义一个window operator：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .window(...)</span><br><span class="line"> [.trigger(...)]</span><br><span class="line"> [.evictor(...)]</span><br><span class="line">  .reduce/aggregate/process(...)</span><br></pre></td></tr></table></figure></div>

<p>注意：每个WindowAssigner都有一个默认的trigger。</p>
<p><em>窗口生命周期</em></p>
<p>当WindowAssigner分配某个窗口的第一个元素时，这个窗口才会被创建。所以不存在没有元素的窗口。</p>
<p>一个窗口包含了如下状态：</p>
<ul>
<li>Window content<ul>
<li>分配到这个窗口的元素</li>
<li>增量聚合的结果(如果window operator接收了ReduceFunction或者AggregateFunction作为参数)。</li>
</ul>
</li>
<li>Window object<ul>
<li>WindowAssigner返回0个，1个或者多个window object。</li>
<li>window operator根据返回的window object来聚合元素。</li>
<li>每一个window object包含一个windowEnd时间戳，来区别于其他窗口。</li>
</ul>
</li>
<li>触发器的定时器：一个触发器可以注册定时事件，到了定时的时间可以执行相应的回调函数，例如：对窗口进行求值或者清空窗口。</li>
<li>触发器中的自定义状态：触发器可以定义和使用自定义的、per-window或者per-key状态。这个状态完全被触发器所控制。而不是被window operator控制。</li>
</ul>
<p>当窗口结束时间来到，window operator将删掉这个窗口。窗口结束时间是由window object的end timestamp所定义的。无论是使用processing time还是event time，窗口结束时间是什么类型可以调用WindowAssigner.isEventTime()方法获得。</p>
<p><em>窗口分配器(window assigners)</em></p>
<p>WindowAssigner将会把元素分配到0个，1个或者多个窗口中去。我们看一下WindowAssigner接口：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowAssigner&lt;T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window&gt;</span></span></span><br><span class="line"><span class="class">    <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">abstract</span> <span class="type">Collection</span>&lt;<span class="type">W</span>&gt; assignWindows(</span><br><span class="line">    <span class="type">T</span> element,</span><br><span class="line">    long timestamp,</span><br><span class="line">    <span class="type">WindowAssignerContext</span> context);</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">abstract</span> <span class="type">Trigger</span>&lt;<span class="type">T</span>, <span class="type">W</span>&gt; getDefaultTriger(</span><br><span class="line">    <span class="type">StreamExecutionEnvironment</span> env);</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">abstract</span> <span class="type">TypeSerializer</span>&lt;<span class="type">W</span>&gt; getWindowSerializer(</span><br><span class="line">    <span class="type">ExecutionConfig</span> executionConfig);</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">abstract</span> boolean isEventTime();</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">WindowAssignerContext</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">abstract</span> long getCurrentProcessingTime();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>WindowAssigner有两个泛型参数：</p>
<ul>
<li>T: 事件的数据类型</li>
<li>W: 窗口的类型</li>
</ul>
<p>下面的代码创建了一个自定义窗口分配器，是一个30秒的滚动事件时间窗口。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirtySecondsWindows</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">WindowAssigner</span>[<span class="type">Object</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> windowSize: <span class="type">Long</span> = <span class="number">30</span> * <span class="number">1000</span>L</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">assignWindows</span></span>(</span><br><span class="line">    o: <span class="type">Object</span>,</span><br><span class="line">    ts: <span class="type">Long</span>,</span><br><span class="line">    ctx: <span class="type">WindowAssigner</span>.<span class="type">WindowAssignerContext</span></span><br><span class="line">  ): java.util.<span class="type">List</span>[<span class="type">TimeWindow</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startTime = ts - (ts % windowSize)</span><br><span class="line">    <span class="keyword">val</span> endTime = startTime + windowSize</span><br><span class="line">    <span class="type">Collections</span>.singletonList(<span class="keyword">new</span> <span class="type">TimeWindow</span>(startTime, endTime))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getDefaultTrigger</span></span>(</span><br><span class="line">    env: environment.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line">  ): <span class="type">Trigger</span>[<span class="type">Object</span>, <span class="type">TimeWindow</span>] = &#123;</span><br><span class="line">      <span class="type">EventTimeTrigger</span>.create()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getWindowSerializer</span></span>(</span><br><span class="line">    executionConfig: <span class="type">ExecutionConfig</span></span><br><span class="line">  ): <span class="type">TypeSerializer</span>[<span class="type">TimeWindow</span>] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">TimeWindow</span>.<span class="type">Serializer</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isEventTime</span> </span>= <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>增量聚合示意图</p>
<p><a href="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0604.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0604.png" class="lazyload"></a></p>
<p>全窗口聚合示意图</p>
<p><a href="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0605.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0605.png" class="lazyload"></a></p>
<p>增量聚合和全窗口聚合结合使用的示意图</p>
<p><a href="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0606.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0606.png" class="lazyload"></a></p>
<p><em>触发器(Triggers)</em></p>
<p>触发器定义了window何时会被求值以及何时发送求值结果。触发器可以到了特定的时间触发也可以碰到特定的事件触发。例如：观察到事件数量符合一定条件或者观察到了特定的事件。</p>
<p>默认的触发器将会在两种情况下触发</p>
<ul>
<li>处理时间：机器时间到达处理时间</li>
<li>事件时间：水位线超过了窗口的结束时间</li>
</ul>
<p>触发器可以访问流的时间属性以及定时器，还可以对state状态编程。所以触发器和process function一样强大。例如我们可以实现一个触发逻辑：当窗口接收到一定数量的元素时，触发器触发。再比如当窗口接收到一个特定元素时，触发器触发。还有就是当窗口接收到的元素里面包含特定模式(5秒钟内接收到了两个同样类型的事件)，触发器也可以触发。在一个事件时间的窗口中，一个自定义的触发器可以提前(在水位线没过窗口结束时间之前)计算和发射计算结果。这是一个常见的低延迟计算策略，尽管计算不完全，但不像默认的那样需要等待水位线没过窗口结束时间。</p>
<p>每次调用触发器都会产生一个TriggerResult来决定窗口接下来发生什么。TriggerResult可以取以下结果：</p>
<ul>
<li>CONTINUE：什么都不做</li>
<li>FIRE：如果window operator有ProcessWindowFunction这个参数，将会调用这个ProcessWindowFunction。如果窗口仅有增量聚合函数(ReduceFunction或者AggregateFunction)作为参数，那么当前的聚合结果将会被发送。窗口的state不变。</li>
<li>PURGE：窗口所有内容包括窗口的元数据都将被丢弃。</li>
<li>FIRE_AND_PURGE：先对窗口进行求值，再将窗口中的内容丢弃。</li>
</ul>
<p>TriggerResult可能的取值使得我们可以实现很复杂的窗口逻辑。一个自定义触发器可以触发多次，可以计算或者更新结果，可以在发送结果之前清空窗口。</p>
<p>接下来我们看一下Trigger API：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Trigger&lt;T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window&gt;</span></span></span><br><span class="line"><span class="class">    <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">TriggerResult</span> onElement(</span><br><span class="line">    long timestamp,</span><br><span class="line">    <span class="type">W</span> window,</span><br><span class="line">    <span class="type">TriggerContext</span> ctx);</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">abstract</span> <span class="type">TriggerResult</span> onProcessingTime(</span><br><span class="line">    long timestamp,</span><br><span class="line">    <span class="type">W</span> window,</span><br><span class="line">    <span class="type">TriggerContext</span> ctx);</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">abstract</span> <span class="type">TriggerResult</span> onEventTime(</span><br><span class="line">    long timestamp,</span><br><span class="line">    <span class="type">W</span> window,</span><br><span class="line">    <span class="type">TriggerContext</span> ctx);</span><br><span class="line">  </span><br><span class="line">  public boolean canMerge();</span><br><span class="line"></span><br><span class="line">  public void onMerge(<span class="type">W</span> window, <span class="type">OnMergeContext</span> ctx);</span><br><span class="line"></span><br><span class="line">  public <span class="keyword">abstract</span> void clear(<span class="type">W</span> window, <span class="type">TriggerContext</span> ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface <span class="type">TriggerContext</span> &#123;</span><br><span class="line"></span><br><span class="line">  long getCurrentProcessingTime();</span><br><span class="line"></span><br><span class="line">  long getCurrentWatermark();</span><br><span class="line"></span><br><span class="line">  void registerProcessingTimeTimer(long time);</span><br><span class="line"></span><br><span class="line">  void registerEventTimeTimer(long time);</span><br><span class="line"></span><br><span class="line">  void deleteProcessingTimeTimer(long time);</span><br><span class="line"></span><br><span class="line">  void deleteEventTimeTimer(long time);</span><br><span class="line"></span><br><span class="line">  &lt;<span class="type">S</span> <span class="keyword">extends</span> <span class="type">State</span>&gt; <span class="type">S</span> getPartitionedState(</span><br><span class="line">    <span class="type">StateDescriptor</span>&lt;<span class="type">S</span>, ?&gt; stateDescriptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface <span class="type">OnMergeContext</span> <span class="keyword">extends</span> <span class="type">TriggerContext</span> &#123;</span><br><span class="line"></span><br><span class="line">  void mergePartitionedState(</span><br><span class="line">    <span class="type">StateDescriptor</span>&lt;<span class="type">S</span>, ?&gt; stateDescriptor</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里要注意两个地方：清空state和merging合并触发器。</p>
<p>当在触发器中使用per-window state时，这里我们需要保证当窗口被删除时state也要被删除，否则随着时间的推移，window operator将会积累越来越多的数据，最终可能使应用崩溃。</p>
<p>当窗口被删除时，为了清空所有状态，触发器的clear()方法需要需要删掉所有的自定义per-window state，以及使用TriggerContext对象将处理时间和事件时间的定时器都删除。</p>
<p>下面的例子展示了一个触发器在窗口结束时间之前触发。当第一个事件被分配到窗口时，这个触发器注册了一个定时器，定时时间为水位线之前一秒钟。当定时事件执行，将会注册一个新的定时事件，这样，这个触发器每秒钟最多触发一次。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneSecondIntervalTrigger</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Trigger</span>[<span class="type">SensorReading</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onElement</span></span>(</span><br><span class="line">    r: <span class="type">SensorReading</span>,</span><br><span class="line">    timestamp: <span class="type">Long</span>,</span><br><span class="line">    window: <span class="type">TimeWindow</span>,</span><br><span class="line">    ctx: <span class="type">Trigger</span>.<span class="type">TriggerContext</span></span><br><span class="line">  ): <span class="type">TriggerResult</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> firstSeen: <span class="type">ValueState</span>[<span class="type">Boolean</span>] = ctx</span><br><span class="line">      .getPartitionedState(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](</span><br><span class="line">          <span class="string">"firstSeen"</span>, classOf[<span class="type">Boolean</span>]</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!firstSeen.value()) &#123;</span><br><span class="line">      <span class="keyword">val</span> t = ctx.getCurrentWatermark</span><br><span class="line">       + (<span class="number">1000</span> - (ctx.getCurrentWatermark % <span class="number">1000</span>))</span><br><span class="line">      ctx.registerEventTimeTimer(t)</span><br><span class="line">      ctx.registerEventTimeTimer(window.getEnd)</span><br><span class="line">      firstSeen.update(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TriggerResult</span>.<span class="type">CONTINUE</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onEventTime</span></span>(</span><br><span class="line">    timestamp: <span class="type">Long</span>,</span><br><span class="line">    window: <span class="type">TimeWindow</span>,</span><br><span class="line">    ctx: <span class="type">Trigger</span>.<span class="type">TriggerContext</span></span><br><span class="line">  ): <span class="type">TriggerResult</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (timestamp == window.getEnd) &#123;</span><br><span class="line">      <span class="type">TriggerResult</span>.<span class="type">FIRE_AND_PURGE</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> t = ctx.getCurrentWatermark</span><br><span class="line">       + (<span class="number">1000</span> - (ctx.getCurrentWatermark % <span class="number">1000</span>))</span><br><span class="line">      <span class="keyword">if</span> (t &lt; window.getEnd) &#123;</span><br><span class="line">        ctx.registerEventTimeTimer(t)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">TriggerResult</span>.<span class="type">FIRE</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onProcessingTime</span></span>(</span><br><span class="line">    timestamp: <span class="type">Long</span>,</span><br><span class="line">    window: <span class="type">TimeWindow</span>,</span><br><span class="line">    ctx: <span class="type">Trigger</span>.<span class="type">TriggerContext</span></span><br><span class="line">  ): <span class="type">TriggerResult</span> = &#123;</span><br><span class="line">    <span class="type">TriggerResult</span>.<span class="type">CONTINUE</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">clear</span></span>(</span><br><span class="line">    window: <span class="type">TimeWindow</span>,</span><br><span class="line">    ctx: <span class="type">Trigger</span>.<span class="type">TriggerContext</span></span><br><span class="line">  ): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> firstSeen: <span class="type">ValueState</span>[<span class="type">Boolean</span>] = ctx</span><br><span class="line">      .getPartitionedState(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](</span><br><span class="line">          <span class="string">"firstSeen"</span>, classOf[<span class="type">Boolean</span>]</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    firstSeen.clear()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><em>清理器(EVICTORS)</em></p>
<p>evictor可以在window function求值之前或者之后移除窗口中的元素。</p>
<p>我们看一下Evictor的接口定义：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">Evictor</span>&lt;<span class="type">T</span>, <span class="type">W</span> <span class="keyword">extends</span> <span class="type">Window</span>&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="type">Serializable</span> &#123;</span><br><span class="line">  void evictBefore(</span><br><span class="line">    <span class="type">Iterable</span>&lt;<span class="type">TimestampedValue</span>&lt;<span class="type">T</span>&gt;&gt; elements,</span><br><span class="line">    int size,</span><br><span class="line">    <span class="type">W</span> window,</span><br><span class="line">    <span class="type">EvictorContext</span> evictorContext);</span><br><span class="line"></span><br><span class="line">  void evictAfter(</span><br><span class="line">    <span class="type">Iterable</span>&lt;<span class="type">TimestampedValue</span>&lt;<span class="type">T</span>&gt;&gt; elements,</span><br><span class="line">    int size,</span><br><span class="line">    <span class="type">W</span> window,</span><br><span class="line">    <span class="type">EvictorContext</span> evictorContext);</span><br><span class="line"></span><br><span class="line">  interface <span class="type">EvictorContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    long getCurrentProcessingTime();</span><br><span class="line"></span><br><span class="line">    long getCurrentWatermark();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>evictBefore()和evictAfter()分别在window function计算之前或者之后调用。Iterable迭代器包含了窗口所有的元素，size为窗口中元素的数量，window object和EvictorContext可以访问当前处理时间和水位线。可以对Iterator调用remove()方法来移除窗口中的元素。</p>
<p>evictor也经常被用在GlobalWindow上，用来清除部分元素，而不是将窗口中的元素全部清空。</p>
<h2 id="基于时间的双流Join"><a href="#基于时间的双流Join" class="headerlink" title="基于时间的双流Join"></a>基于时间的双流Join</h2><p>数据流操作的另一个常见需求是对两条数据流中的事件进行联结（connect）或Join。Flink DataStream API中内置有两个可以根据时间条件对数据流进行Join的算子：基于间隔的Join和基于窗口的Join。本节我们会对它们进行介绍。</p>
<p>如果Flink内置的Join算子无法表达所需的Join语义，那么你可以通过CoProcessFunction、BroadcastProcessFunction或KeyedBroadcastProcessFunction实现自定义的Join逻辑。</p>
<blockquote>
<p>注意，你要设计的Join算子需要具备高效的状态访问模式及有效的状态清理策略。</p>
</blockquote>
<h3 id="基于间隔的Join"><a href="#基于间隔的Join" class="headerlink" title="基于间隔的Join"></a>基于间隔的Join</h3><p>基于间隔的Join会对两条流中拥有相同键值以及彼此之间时间戳不超过某一指定间隔的事件进行Join。</p>
<p>下图展示了两条流（A和B）上基于间隔的Join，如果B中事件的时间戳相较于A中事件的时间戳不早于1小时且不晚于15分钟，则会将两个事件Join起来。Join间隔具有对称性，因此上面的条件也可以表示为A中事件的时间戳相较B中事件的时间戳不早于15分钟且不晚于1小时。</p>
<p><a href="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0607.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0607.png" class="lazyload"></a></p>
<p>基于间隔的Join目前只支持事件时间以及INNER JOIN语义（无法发出未匹配成功的事件）。下面的例子定义了一个基于间隔的Join。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input1</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .between(&lt;lower-bound&gt;, &lt;upper-bound&gt;) <span class="comment">// 相对于input1的上下界</span></span><br><span class="line">  .process(<span class="type">ProcessJoinFunction</span>) <span class="comment">// 处理匹配的事件对</span></span><br></pre></td></tr></table></figure></div>

<p>Join成功的事件对会发送给ProcessJoinFunction。下界和上界分别由负时间间隔和正时间间隔来定义，例如between(Time.hour(-1), Time.minute(15))。在满足下界值小于上界值的前提下，你可以任意对它们赋值。例如，允许出现B中事件的时间戳相较A中事件的时间戳早1～2小时这样的条件。</p>
<p>基于间隔的Join需要同时对双流的记录进行缓冲。对第一个输入而言，所有时间戳大于当前水位线减去间隔上界的数据都会被缓冲起来；对第二个输入而言，所有时间戳大于当前水位线加上间隔下界的数据都会被缓冲起来。注意，两侧边界值都有可能为负。上图中的Join需要存储数据流A中所有时间戳大于当前水位线减去15分钟的记录，以及数据流B中所有时间戳大于当前水位线减去1小时的记录。不难想象，如果两条流的事件时间不同步，那么Join所需的存储就会显著增加，因为水位线总是由“较慢”的那条流来决定。</p>
<p>例子：每个用户的点击Join这个用户最近10分钟内的浏览</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.<span class="type">ProcessJoinFunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions</span><br><span class="line">.timestamps.<span class="type">BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"><span class="keyword">import</span> org.joda.time.<span class="type">DateTime</span></span><br><span class="line"><span class="keyword">import</span> org.joda.time.format.<span class="type">DateTimeFormat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：每个用户的点击Join这个用户最近10分钟内的浏览</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流clickStream</span></span><br><span class="line"><span class="comment">// 某个用户在某个时刻点击了某个页面</span></span><br><span class="line"><span class="comment">// &#123;"userID": "user_2", "eventTime": "2019-11-16 17:30:02", "eventType": "click", "pageID": "page_1"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流browseStream</span></span><br><span class="line"><span class="comment">// 某个用户在某个时刻浏览了某个商品，以及商品的价值</span></span><br><span class="line"><span class="comment">// &#123;"userID": "user_2", "eventTime": "2019-11-16 17:30:01", "eventType": "browse", "productID": "product_1", "productPrice": 10&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntervalJoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClickLog</span>(<span class="params">userID: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          eventTime: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          eventType: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                          pageID: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">UserBrowseLog</span>(<span class="params">userID: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           eventTime: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           eventType: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           productID: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                           productPrice: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">main</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>)</span>: <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> clickStream = env</span><br><span class="line">      .fromElements(</span><br><span class="line">        <span class="type">UserClickLog</span>(<span class="string">"user_2"</span>, <span class="string">"2019-11-16 17:30:00"</span>, <span class="string">"click"</span>, <span class="string">"page_1"</span>)</span><br><span class="line">      )</span><br><span class="line">      .assignTimestampsAndWatermarks(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">UserClickLog</span>](<span class="type">Time</span>.seconds(<span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(t: <span class="type">UserClickLog</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">            <span class="keyword">val</span> dateTimeFormatter = <span class="type">DateTimeFormat</span>.forPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">            <span class="keyword">val</span> dateTime = <span class="type">DateTime</span>.parse(t.eventTime, dateTimeFormatter)</span><br><span class="line">            dateTime.getMillis</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> browseStream = env</span><br><span class="line">      .fromElements(</span><br><span class="line">        <span class="type">UserBrowseLog</span>(<span class="string">"user_2"</span>, <span class="string">"2019-11-16 17:19:00"</span>, <span class="string">"browse"</span>, <span class="string">"product_1"</span>, <span class="string">"10"</span>),</span><br><span class="line">        <span class="type">UserBrowseLog</span>(<span class="string">"user_2"</span>, <span class="string">"2019-11-16 17:20:00"</span>, <span class="string">"browse"</span>, <span class="string">"product_1"</span>, <span class="string">"10"</span>),</span><br><span class="line">        <span class="type">UserBrowseLog</span>(<span class="string">"user_2"</span>, <span class="string">"2019-11-16 17:22:00"</span>, <span class="string">"browse"</span>, <span class="string">"product_1"</span>, <span class="string">"10"</span>),</span><br><span class="line">        <span class="type">UserBrowseLog</span>(<span class="string">"user_2"</span>, <span class="string">"2019-11-16 17:26:00"</span>, <span class="string">"browse"</span>, <span class="string">"product_1"</span>, <span class="string">"10"</span>),</span><br><span class="line">        <span class="type">UserBrowseLog</span>(<span class="string">"user_2"</span>, <span class="string">"2019-11-16 17:30:00"</span>, <span class="string">"browse"</span>, <span class="string">"product_1"</span>, <span class="string">"10"</span>),</span><br><span class="line">        <span class="type">UserBrowseLog</span>(<span class="string">"user_2"</span>, <span class="string">"2019-11-16 17:31:00"</span>, <span class="string">"browse"</span>, <span class="string">"product_1"</span>, <span class="string">"10"</span>)</span><br><span class="line">      )</span><br><span class="line">      .assignTimestampsAndWatermarks(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">UserBrowseLog</span>](<span class="type">Time</span>.seconds(<span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(t: <span class="type">UserBrowseLog</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">            <span class="keyword">val</span> dateTimeFormatter = <span class="type">DateTimeFormat</span>.forPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">            <span class="keyword">val</span> dateTime = <span class="type">DateTime</span>.parse(t.eventTime, dateTimeFormatter)</span><br><span class="line">            dateTime.getMillis</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    clickStream</span><br><span class="line">      .keyBy(<span class="string">"userID"</span>)</span><br><span class="line">      .intervalJoin(browseStream.keyBy(<span class="string">"userID"</span>))</span><br><span class="line">      .between(<span class="type">Time</span>.minutes(<span class="number">-10</span>),<span class="type">Time</span>.seconds(<span class="number">0</span>))</span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">MyIntervalJoin</span>)</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyIntervalJoin</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessJoinFunction</span>[<span class="type">UserClickLog</span>, <span class="type">UserBrowseLog</span>, <span class="type">String</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(</span><br><span class="line">      left: <span class="type">UserClickLog</span>,</span><br><span class="line">      right: <span class="type">UserBrowseLog</span>,</span><br><span class="line">      context: <span class="type">ProcessJoinFunction</span>[<span class="type">UserClickLog</span>, <span class="type">UserBrowseLog</span>, <span class="type">String</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">String</span>]</span><br><span class="line">    ): <span class="type">Unit</span> = &#123;</span><br><span class="line">      out.collect(left +<span class="string">" =Interval Join=&gt; "</span>+right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="基于窗口的Join"><a href="#基于窗口的Join" class="headerlink" title="基于窗口的Join"></a>基于窗口的Join</h3><p>顾名思义，基于窗口的Join需要用到Flink中的窗口机制。其原理是将两条输入流中的元素分配到公共窗口中并在窗口完成时进行Join（或Cogroup）。</p>
<p>下面的例子展示了如何定义基于窗口的Join。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input1.join(input2)</span><br><span class="line">  .where(...)       <span class="comment">// 为input1指定键值属性</span></span><br><span class="line">  .equalTo(...)     <span class="comment">// 为input2指定键值属性</span></span><br><span class="line">  .window(...)      <span class="comment">// 指定WindowAssigner</span></span><br><span class="line">  [.trigger(...)]   <span class="comment">// 选择性的指定Trigger</span></span><br><span class="line">  [.evictor(...)]   <span class="comment">// 选择性的指定Evictor</span></span><br><span class="line">  .apply(...)       <span class="comment">// 指定JoinFunction</span></span><br></pre></td></tr></table></figure></div>

<p>下图展示了DataStream API中基于窗口的Join是如何工作的。</p>
<p><a href="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0608.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://confucianzuoyuan.github.io/flink-tutorial/images/spaf_0608.png" class="lazyload"></a></p>
<p>两条输入流都会根据各自的键值属性进行分区，公共窗口分配器会将二者的事件映射到公共窗口内（其中同时存储了两条流中的数据）。当窗口的计时器触发时，算子会遍历两个输入中元素的每个组合（叉乘积）去调用JoinFunction。同时你也可以自定义触发器或移除器。由于两条流中的事件会被映射到同一个窗口中，因此该过程中的触发器和移除器与常规窗口算子中的完全相同。</p>
<p>除了对窗口中的两条流进行Join，你还可以对它们进行Cogroup，只需将算子定义开始位置的join改为coGroup()即可。Join和Cogroup的总体逻辑相同，二者的唯一区别是：Join会为两侧输入中的每个事件对调用JoinFunction；而Cogroup中用到的CoGroupFunction会以两个输入的元素遍历器为参数，只在每个窗口中被调用一次。</p>
<blockquote>
<p>注意，对划分窗口后的数据流进行Join可能会产生意想不到的语义。例如，假设你为执行Join操作的算子配置了1小时的滚动窗口，那么一旦来自两个输入的元素没有被划分到同一窗口，它们就无法Join在一起，即使二者彼此仅相差1秒钟。</p>
</blockquote>
<h2 id="处理迟到的元素-Handling-Late-Data"><a href="#处理迟到的元素-Handling-Late-Data" class="headerlink" title="处理迟到的元素(Handling Late Data)"></a>处理迟到的元素(Handling Late Data)</h2><p>水位线可以用来平衡计算的完整性和延迟两方面。除非我们选择一种非常保守的水位线策略(最大延时设置的非常大，以至于包含了所有的元素，但结果是非常大的延迟)，否则我们总需要处理迟到的元素。</p>
<p>迟到的元素是指当这个元素来到时，这个元素所对应的窗口已经计算完毕了(也就是说水位线已经没过窗口结束时间了)。这说明迟到这个特性只针对事件时间。</p>
<p>DataStream API提供了三种策略来处理迟到元素</p>
<ul>
<li>直接抛弃迟到的元素</li>
<li>将迟到的元素发送到另一条流中去</li>
<li>可以更新窗口已经计算完的结果，并发出计算结果。</li>
</ul>
<h3 id="抛弃迟到元素"><a href="#抛弃迟到元素" class="headerlink" title="抛弃迟到元素"></a>抛弃迟到元素</h3><p>抛弃迟到的元素是event time window operator的默认行为。也就是说一个迟到的元素不会创建一个新的窗口。</p>
<p>process function可以通过比较迟到元素的时间戳和当前水位线的大小来很轻易的过滤掉迟到元素。</p>
<h3 id="重定向迟到元素"><a href="#重定向迟到元素" class="headerlink" title="重定向迟到元素"></a>重定向迟到元素</h3><p>迟到的元素也可以使用侧输出(side output)特性被重定向到另外的一条流中去。迟到元素所组成的侧输出流可以继续处理或者sink到持久化设施中去。</p>
<p>例子</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> readings = env</span><br><span class="line">  .socketTextStream(<span class="string">"localhost"</span>, <span class="number">9999</span>, '\n')</span><br><span class="line">  .map(line =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> arr = line.split(<span class="string">" "</span>)</span><br><span class="line">    (arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong * <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .assignAscendingTimestamps(_._2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> countPer10Secs = readings</span><br><span class="line">  .keyBy(_._1)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>))</span><br><span class="line">  .sideOutputLateData(</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OutputTag</span>[(<span class="type">String</span>, <span class="type">Long</span>)](<span class="string">"late-readings"</span>)</span><br><span class="line">  )</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">CountFunction</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lateStream = countPer10Secs</span><br><span class="line">  .getSideOutput(</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OutputTag</span>[(<span class="type">String</span>, <span class="type">Long</span>)](<span class="string">"late-readings"</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">lateStream.print()</span><br></pre></td></tr></table></figure></div>

<p>实现<code>CountFunction</code>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[(<span class="type">String</span>, <span class="type">Long</span>),</span></span><br><span class="line"><span class="class">  <span class="type">String</span>, <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(key: <span class="type">String</span>,</span><br><span class="line">                       context: <span class="type">Context</span>,</span><br><span class="line">                       elements: <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Long</span>)],</span><br><span class="line">                       out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    out.collect(<span class="string">"窗口共有"</span> + elements.size + <span class="string">"条数据"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面这个例子展示了ProcessFunction如何过滤掉迟到的元素然后将迟到的元素发送到侧输出流中去。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ???</span><br><span class="line"><span class="keyword">val</span> filteredReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = readings</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">LateReadingsFilter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve late readings</span></span><br><span class="line"><span class="keyword">val</span> lateReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = filteredReadings</span><br><span class="line">  .getSideOutput(<span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">SensorReading</span>](<span class="string">"late-readings"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** A ProcessFunction that filters out late sensor readings and </span></span><br><span class="line"><span class="comment">  * re-directs them to a side output */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LateReadingsFilter</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> lateReadingsOut = <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">SensorReading</span>](<span class="string">"late-readings"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(</span><br><span class="line">      r: <span class="type">SensorReading</span>,</span><br><span class="line">      ctx: <span class="type">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare record timestamp with current watermark</span></span><br><span class="line">    <span class="keyword">if</span> (r.timestamp &lt; ctx.timerService().currentWatermark()) &#123;</span><br><span class="line">      <span class="comment">// this is a late reading =&gt; redirect it to the side output</span></span><br><span class="line">      ctx.output(lateReadingsOut, r)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      out.collect(r)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用迟到元素更新窗口计算结果-Updating-Results-by-Including-Late-Events"><a href="#使用迟到元素更新窗口计算结果-Updating-Results-by-Including-Late-Events" class="headerlink" title="使用迟到元素更新窗口计算结果(Updating Results by Including Late Events)"></a>使用迟到元素更新窗口计算结果(Updating Results by Including Late Events)</h3><p>由于存在迟到的元素，所以已经计算出的窗口结果是不准确和不完全的。我们可以使用迟到元素更新已经计算完的窗口结果。</p>
<p>如果我们要求一个operator支持重新计算和更新已经发出的结果，就需要在第一次发出结果以后也要保存之前所有的状态。但显然我们不能一直保存所有的状态，肯定会在某一个时间点将状态清空，而一旦状态被清空，结果就再也不能重新计算或者更新了。而迟到的元素只能被抛弃或者发送到侧输出流。</p>
<p>window operator API提供了方法来明确声明我们要等待迟到元素。当使用event-time window，我们可以指定一个时间段叫做allowed lateness。window operator如果设置了allowed lateness，这个window operator在水位线没过窗口结束时间时也将不会删除窗口和窗口中的状态。窗口会在一段时间内(allowed lateness设置的)保留所有的元素。</p>
<p>当迟到元素在allowed lateness时间内到达时，这个迟到元素会被实时处理并发送到触发器(trigger)。当水位线没过了窗口结束时间+allowed lateness时间时，窗口会被删除，并且所有后来的迟到的元素都会被丢弃。</p>
<p>Allowed lateness可以使用allowedLateness()方法来指定，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> countPer10Secs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>)] = readings</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>))</span><br><span class="line">  <span class="comment">// process late readings for 5 additional seconds</span></span><br><span class="line">  .allowedLateness(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  <span class="comment">// count readings and update results if late readings arrive</span></span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">UpdatingWindowCountFunction</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** A counting WindowProcessFunction that distinguishes between </span></span><br><span class="line"><span class="comment">  * first results and updates. */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdatingWindowCountFunction</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[<span class="type">SensorReading</span>,</span></span><br><span class="line"><span class="class">      (<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>), <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(</span><br><span class="line">      id: <span class="type">String</span>,</span><br><span class="line">      ctx: <span class="type">Context</span>,</span><br><span class="line">      elements: <span class="type">Iterable</span>[<span class="type">SensorReading</span>],</span><br><span class="line">      out: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count the number of readings</span></span><br><span class="line">    <span class="keyword">val</span> cnt = elements.count(_ =&gt; <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state to check if this is</span></span><br><span class="line">    <span class="comment">// the first evaluation of the window or not</span></span><br><span class="line">    <span class="keyword">val</span> isUpdate = ctx.windowState.getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](</span><br><span class="line">        <span class="string">"isUpdate"</span>,</span><br><span class="line">        <span class="type">Types</span>.of[<span class="type">Boolean</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isUpdate.value()) &#123;</span><br><span class="line">      <span class="comment">// first evaluation, emit first result</span></span><br><span class="line">      out.collect((id, ctx.window.getEnd, cnt, <span class="string">"first"</span>))</span><br><span class="line">      isUpdate.update(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// not the first evaluation, emit an update</span></span><br><span class="line">      out.collect((id, ctx.window.getEnd, cnt, <span class="string">"update"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Yang4</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9706%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/">https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9706%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://masteryang4.github.io">MasterYangBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%99%E7%A8%8B/">教程    </a><a class="post-meta__tags" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据    </a><a class="post-meta__tags" href="/tags/flink/">flink    </a></div><div class="post_share"><div class="social-share" data-image="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://pic.downk.cc/item/5ea1a251c2a9a83be535b287.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://pic.downk.cc/item/5ea1a33ac2a9a83be536f9bc.png" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/02/flink%E7%B3%BB%E5%88%9707%E6%9C%89%E7%8A%B6%E6%80%81%E7%AE%97%E5%AD%90%E5%92%8C%E5%BA%94%E7%94%A8/"><img class="prev_cover lazyload" data-src="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>flink系列07有状态算子和应用</span></div></a></div><div class="next-post pull_right"><a href="/2020/06/30/flume%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8BflumeTailDirSource%E5%85%BC%E5%AE%B9log4j/"><img class="next_cover lazyload" data-src="https://pic.downk.cc/item/5efb40f514195aa594a1236d.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>flume源码修改之flumeTailDirSource兼容log4j</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/02/flink系列12电商用户行为分析/" title="flink系列12电商用户行为分析"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-02</div><div class="relatedPosts_title">flink系列12电商用户行为分析</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/02/flink系列11Table-API-和-Flink-SQL/" title="flink系列11Table API 和 Flink SQL"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-02</div><div class="relatedPosts_title">flink系列11Table API 和 Flink SQL</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/02/flink系列10Flink-CEP简介/" title="flink系列10Flink CEP简介"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-02</div><div class="relatedPosts_title">flink系列10Flink CEP简介</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/02/flink系列09搭建Flink运行流式应用/" title="flink系列09搭建Flink运行流式应用"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-02</div><div class="relatedPosts_title">flink系列09搭建Flink运行流式应用</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/02/flink系列08读写外部系统/" title="flink系列08读写外部系统"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-02</div><div class="relatedPosts_title">flink系列08读写外部系统</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/02/flink系列07有状态算子和应用/" title="flink系列07有状态算子和应用"><img class="relatedPosts_cover lazyload"data-src="https://pic.downk.cc/item/5ef7647614195aa59476f65a.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-02</div><div class="relatedPosts_title">flink系列07有状态算子和应用</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'IeiQD5I6g4Doamc68SctmEnW-gzGzoHsz',
  appKey:'ORWhRoGUBY02RR9DMa5OSIow',
  placeholder:'评论一下~（支持Markdown格式）',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Yang4</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/fireworks.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>