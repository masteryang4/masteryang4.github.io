<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MasterYangBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://masteryang4.github.io/"/>
  <updated>2020-05-14T12:21:18.503Z</updated>
  <id>https://masteryang4.github.io/</id>
  
  <author>
    <name>Yang4</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL事务相关</title>
    <link href="https://masteryang4.github.io/2020/05/14/MySQL%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/"/>
    <id>https://masteryang4.github.io/2020/05/14/MySQL%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/</id>
    <published>2020-05-14T09:10:57.000Z</published>
    <updated>2020-05-14T12:21:18.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务四大特性（ACID）"><a href="#事务四大特性（ACID）" class="headerlink" title="事务四大特性（ACID）"></a>事务四大特性（ACID）</h1><p><strong>1、原子性（Atomicity）：</strong></p><p>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。</p><p>事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。</p><p>也就是说事务是一个不可分割的整体。</p><p>的基本单位 </p><p><strong>2、一致性（Consistency）：</strong></p><p>事务开始前和结束后，数据库的完整性约束没有被破坏 。</p><p>比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。 </p><p><strong>3、隔离性（Isolation）：</strong></p><p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。</p><p>比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前，B 不能向这张卡转账。 </p><p><strong>4、持久性（Durability）：</strong></p><p>事务完成后，事务对数据库的所有更新将被保存到数据库，不 能回滚。 </p><h1 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h1><p>多个事务之间隔离的，相互独立的。</p><p>但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><blockquote><p>隔离级别越高，效率越低。</p><p>大多数数据库的默认级别就是不可重复读（Read committed），比如Sql Server , Oracle</p><p><strong>【注意】MySQL的默认事务隔离级别是——可重复读</strong></p></blockquote><h1 id="事务并发存在的问题"><a href="#事务并发存在的问题" class="headerlink" title="事务并发存在的问题"></a>事务并发存在的问题</h1><p>1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</p><p>（一个事务，读取到另一个事务中没有提交的数据）</p><p>2、不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务 A多次读取同一数据时，结果不一致 。</p><p>（在同一个事务中，两次读取到的数据不一样 ）</p><p>3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 </p><p>（一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到添加的数据）</p><p>（ 一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行）</p><blockquote><p>可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）；</p><p>insert、update和delete会更新版本号，是当前读（当前版本）。 幻读只在<strong>当前读</strong>下才会出现。 </p></blockquote><blockquote><p>不可重复读的和幻读很容易混淆，<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong>。</p><p>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表等方法</p></blockquote><p><strong>幻读产生的原因：</strong></p><ul><li>行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。 </li></ul><p><strong>解决幻读的其他方法：</strong></p><ul><li>将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为<strong>间隙锁</strong>。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事务四大特性（ACID）&quot;&gt;&lt;a href=&quot;#事务四大特性（ACID）&quot; class=&quot;headerlink&quot; title=&quot;事务四大特性（ACID）&quot;&gt;&lt;/a&gt;事务四大特性（ACID）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、原子性（Atomicity）：&lt;/str
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://masteryang4.github.io/categories/SQL/"/>
    
      <category term="MySQL" scheme="https://masteryang4.github.io/categories/SQL/MySQL/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="面试" scheme="https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="MySQL" scheme="https://masteryang4.github.io/tags/MySQL/"/>
    
      <category term="数据库" scheme="https://masteryang4.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>[精]zookeeper总结与思考</title>
    <link href="https://masteryang4.github.io/2020/05/14/%E7%B2%BE-zookeeper%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>https://masteryang4.github.io/2020/05/14/%E7%B2%BE-zookeeper%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2020-05-14T08:30:13.000Z</published>
    <updated>2020-05-14T08:56:10.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Zookeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。多作为集群提供服务的中间件.</p><p>Zookeeper从设计模式角度来理解，是一个基于<strong>观察者模式</strong>设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生了变化，Zookeeper就负责<strong>通知</strong>已经在Zookeeper上注册的那些观察者做出相应的反应.</p><blockquote><p>分布式系统: 分布式系统指由很多台计算机组成的一个整体。</p><p>这个整体一致对外,并且处理同一请求，系统对内透明，对外不透明。</p><p>内部的每台计算机都可以相互通信，例如使用RPC 或者是WebService。客户端向一个分布式系统发送的一次请求到接受到响应，有可能会经历多台计算机。</p></blockquote><p><strong>Zookeeper = 文件系统 + 通知机制</strong></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>中心化集群，但是中心化集群易出现单点故障。</p><p><a href="https://pic.downk.cc/item/5ebcf7c7c2a9a83be53e07f7.png" data-fancybox="group" data-caption="zk特点" class="fancybox"><img alt="zk特点" title="zk特点" data-src="https://pic.downk.cc/item/5ebcf7c7c2a9a83be53e07f7.png" class="lazyload"></a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://pic.downk.cc/item/5ebcf7f5c2a9a83be53e3033.png" data-fancybox="group" data-caption="zk数据结构" class="fancybox"><img alt="zk数据结构" title="zk数据结构" data-src="https://pic.downk.cc/item/5ebcf7f5c2a9a83be53e3033.png" class="lazyload"></a></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><h1 id="二、安装及操作"><a href="#二、安装及操作" class="headerlink" title="二、安装及操作"></a>二、安装及操作</h1><p>需要提前安装JDK</p><p>两种部署方式：本地模式（standalone），分布式模式</p><h2 id="分布式安装部署"><a href="#分布式安装部署" class="headerlink" title="分布式安装部署"></a>分布式安装部署</h2><blockquote><p>版本：zookeeper-3.4.10</p></blockquote><p>1、规划</p><p>将在hadoop102、hadoop103和hadoop104三个节点上部署Zookeeper。</p><p>2、解压安装</p><p>三台服务器分别解压：tar -zxvf zookeeper-3.4.10.tar.gz</p><p>解压后生成zookeeper-3.4.10目录</p><p>3、配置服务器编号</p><ul><li><p>在zookeeper-3.4.10目录下创建zkData：mkdir -p zkData</p></li><li><p>进入目录：cd  zkData</p></li><li><p>创建myid文件：touch myid</p></li><li><p>编辑文件：vim myid</p></li></ul><p>在文件中添加与server对应的编号：比如hadoop02添加2；</p><ul><li>在hadoop103、hadoop104上修改myid文件中内容为3、4</li></ul><p>4、修改配置文件</p><ul><li><p>zookeeper-3.4.10/conf这个目录下的zoo_sample.cfg重命名为zoo.cfg：mv zoo_sample.cfg zoo.cfg</p></li><li><p>打开zoo.cfg文件：vim zoo.cfg</p></li><li><p>在文件中修改数据存储路径配置：</p></li></ul><p>dataDir=/opt/module/zookeeper-3.4.10/zkData</p><ul><li>并且增加如下配置：</li></ul><p>#######################cluster##########################</p><p>server.2=hadoop102:2888:3888</p><p>server.3=hadoop103:2888:3888</p><p>server.4=hadoop104:2888:3888</p><ul><li>同步zoo.cfg配置文件到其他所有服务器</li></ul><blockquote><p>【配置参数解读】server.A=B:C:D</p><p>A是一个数字，表示这个是第几号服务器【myid】；</p><p>zk启动时读取myid文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。</p><p>B是这个服务器的ip地址；</p><p>C是这个服务器与集群中的Leader服务器交换信息的端口<strong>2888</strong>；【副本】</p><p>D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口<strong>3888</strong>。【选举信息】</p><p>【扩展】<strong>2181</strong>，客户端访问端口</p></blockquote><p>5、相关操作</p><ul><li><p>三台服务器在zookeeper-3.4.10下分别启动：bin/zkServer.sh start</p></li><li><p>查看状态：bin/zkServer.sh status</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ys@hadoop102 zookeeper-3.4.10]# bin/zkServer.sh status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /opt/module/zookeeper-3.4.10/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br><span class="line">[ys@hadoop103 zookeeper-3.4.10]# bin/zkServer.sh status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /opt/module/zookeeper-3.4.10/bin/../conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br><span class="line">[ys@hadoop104 zookeeper-3.4.5]# bin/zkServer.sh status</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /opt/module/zookeeper-3.4.10/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure></div><h2 id="客户端命令行操作"><a href="#客户端命令行操作" class="headerlink" title="客户端命令行操作"></a>客户端命令行操作</h2><p>启动客户端：bin/zkCli.sh</p><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls path [watch]</td><td>使用 ls 命令来查看当前znode中所包含的内容</td></tr><tr><td>ls2 path [watch]</td><td>（详细信息）查看当前节点数据并能看到更新次数等数据</td></tr><tr><td>create</td><td>普通创建<br>-s  含有序列<br>-e  临时（重启或者超时消失）</td></tr><tr><td>get path [watch]</td><td>获得节点的值</td></tr><tr><td>set</td><td>设置节点的具体值</td></tr><tr><td>stat</td><td>查看节点状态</td></tr><tr><td>delete</td><td>删除节点</td></tr><tr><td>rmr</td><td>递归删除节点</td></tr></tbody></table><h1 id="三、内部原理【重点】"><a href="#三、内部原理【重点】" class="headerlink" title="三、内部原理【重点】"></a>三、内部原理【重点】</h1><h2 id="选举机制【重点】"><a href="#选举机制【重点】" class="headerlink" title="选举机制【重点】"></a>选举机制【重点】</h2><ul><li><p>半数机制：</p><ul><li>集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。</li></ul></li><li><p>内部投票选举：</p><ul><li>Zookeeper虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。</li></ul></li></ul><p>【举例】五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。这些服务器依序启动，则：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">因为一共5台服务器，只有超过半数以上，即最少启动3台服务器，集群才能正常工作。</span><br><span class="line"></span><br><span class="line">（1）服务器1启动，发起一次选举。</span><br><span class="line">服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成；</span><br><span class="line">服务器1状态保持为LOOKING；</span><br><span class="line"></span><br><span class="line">（2）服务器2启动，再发起一次选举。</span><br><span class="line">服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2；</span><br><span class="line">此时服务器1票数0票，服务器2票数2票，不够半数以上（3票），选举无法完成；</span><br><span class="line">服务器1，2状态保持LOOKING；</span><br><span class="line"></span><br><span class="line">（3）服务器3启动，发起一次选举。</span><br><span class="line">与上面过程一样，服务器1和2先投自己一票，然后因为服务器3id最大，两者更改选票投给为服务器3；</span><br><span class="line">此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数（3票），服务器3当选Leader。</span><br><span class="line">服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</span><br><span class="line"></span><br><span class="line">（4）服务器4启动，发起一次选举。</span><br><span class="line">此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。</span><br><span class="line">此时服务器4服从多数，更改选票信息为服务器3；</span><br><span class="line">服务器4并更改状态为FOLLOWING；</span><br><span class="line"></span><br><span class="line">（5）服务器5启动，同4一样投票给3，此时服务器3一共5票，服务器5为0票；</span><br><span class="line">服务器5并更改状态为FOLLOWING；</span><br><span class="line"></span><br><span class="line">最终Leader是服务器3，状态为LEADING；</span><br><span class="line">其余服务器是Follower，状态为FOLLOWING。</span><br></pre></td></tr></table></figure></div><blockquote><p>参考文章： <a href="https://blog.csdn.net/weixin_43291055/article/details/95451357" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43291055/article/details/95451357</a> </p><p>选举机制文章推荐：</p><p> <a href="https://www.cnblogs.com/shuaiandjun/p/9383655.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuaiandjun/p/9383655.html</a> </p><p> <a href="https://blog.csdn.net/wyqwilliam/article/details/83537139" target="_blank" rel="noopener">https://blog.csdn.net/wyqwilliam/article/details/83537139</a> </p></blockquote><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p><a href="https://pic.downk.cc/item/5ebcf83cc2a9a83be53e6d2f.png" data-fancybox="group" data-caption="zk节点4大类型" class="fancybox"><img alt="zk节点4大类型" title="zk节点4大类型" data-src="https://pic.downk.cc/item/5ebcf83cc2a9a83be53e6d2f.png" class="lazyload"></a></p><h2 id="监听器原理【重点】"><a href="#监听器原理【重点】" class="headerlink" title="监听器原理【重点】"></a>监听器原理【重点】</h2><p><a href="https://pic.downk.cc/item/5ebcf87ac2a9a83be53ea28e.png" data-fancybox="group" data-caption="监听器原理" class="fancybox"><img alt="监听器原理" title="监听器原理" data-src="https://pic.downk.cc/item/5ebcf87ac2a9a83be53ea28e.png" class="lazyload"></a></p><h2 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h2><p><a href="https://pic.downk.cc/item/5ebcf898c2a9a83be53ebe79.png" data-fancybox="group" data-caption="写数据流程" class="fancybox"><img alt="写数据流程" title="写数据流程" data-src="https://pic.downk.cc/item/5ebcf898c2a9a83be53ebe79.png" class="lazyload"></a></p><h2 id="【案例】监听服务器节点动态上下线-zk工作机制"><a href="#【案例】监听服务器节点动态上下线-zk工作机制" class="headerlink" title="【案例】监听服务器节点动态上下线/zk工作机制"></a>【案例】监听服务器节点动态上下线/zk工作机制</h2><p><a href="https://pic.downk.cc/item/5ebcf8b1c2a9a83be53ed66b.png" data-fancybox="group" data-caption="zk工作机制" class="fancybox"><img alt="zk工作机制" title="zk工作机制" data-src="https://pic.downk.cc/item/5ebcf8b1c2a9a83be53ed66b.png" class="lazyload"></a></p><h3 id="API操作："><a href="#API操作：" class="headerlink" title="API操作："></a>API操作：</h3><p>1、maven依赖</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>2、集群上创建/servers节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] create /servers "servers"</span><br><span class="line">Created /servers</span><br></pre></td></tr></table></figure></div><p>3、服务器端向Zookeeper注册</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String connectString = <span class="string">"hadoop102:2181,hadoop103:2181,hadoop104:2181"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> String parentNode = <span class="string">"/servers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建到zk的客户端连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">zk = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册服务器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registServer</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">String create = zk.create(parentNode + <span class="string">"/server"</span>, hostname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">System.out.println(hostname +<span class="string">" is online "</span>+ create);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">System.out.println(hostname+<span class="string">" is working ..."</span>);</span><br><span class="line"></span><br><span class="line">Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1获取zk连接</span></span><br><span class="line">DistributeServer server = <span class="keyword">new</span> DistributeServer();</span><br><span class="line">server.getConnect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 利用zk连接注册服务器信息</span></span><br><span class="line">server.registServer(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 启动业务功能</span></span><br><span class="line">server.business(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>4、客户端</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String connectString = <span class="string">"hadoop102:2181,hadoop103:2181,hadoop104:2181"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> String parentNode = <span class="string">"/servers"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建到zk的客户端连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">zk = <span class="keyword">new</span> ZooKeeper(connectString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次启动监听</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getServerList();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务器列表信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getServerList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1获取服务器子节点信息，并且对父节点进行监听</span></span><br><span class="line">List&lt;String&gt; children = zk.getChildren(parentNode, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2存储服务器信息列表</span></span><br><span class="line">ArrayList&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3遍历所有节点，获取节点中的主机名称信息</span></span><br><span class="line"><span class="keyword">for</span> (String child : children) &#123;</span><br><span class="line"><span class="keyword">byte</span>[] data = zk.getData(parentNode + <span class="string">"/"</span> + child, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">servers.add(<span class="keyword">new</span> String(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4打印服务器列表信息</span></span><br><span class="line">System.out.println(servers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"client is working ..."</span>);</span><br><span class="line">Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1获取zk连接</span></span><br><span class="line">DistributeClient client = <span class="keyword">new</span> DistributeClient();</span><br><span class="line">client.getConnect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2获取servers的子节点信息，从中获取服务器信息列表</span></span><br><span class="line">client.getServerList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3业务进程启动</span></span><br><span class="line">client.business();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><h2 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h2><p>1、zk常用端口号：</p><blockquote><p>2181，客户端访问端口<br>2888，zk内部信息通讯（数据）<br>3888，zk选举专用</p></blockquote><p>2、zk不能越级创建节点；</p><p>且创建节点一般要带有数据（除非数据是null），否则创建会失败</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create /ys/sss "666"</span><br><span class="line">Node does not exist: /ys/sss</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create /ys "666"    </span><br><span class="line">Created /ys</span><br><span class="line">...</span><br><span class="line">[zk: localhost:2181(CONNECTED) 16] create /ss null</span><br><span class="line">Created /ys </span><br><span class="line">[zk: localhost:2181(CONNECTED) 17] ls /</span><br><span class="line">[cluster, configs, controller, brokers, zookeeper, overseer, admin, isr_change_notification, controller_epoch, druid, aliases.json, live_nodes, collections, overseer_elect, spark, clusterstate.json, consumers, 【ss】, latest_producer_id_block, config, hbase, kylin]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 18] ls /ss</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 19] get /ss</span><br><span class="line">null</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h2 id="常考面试题"><a href="#常考面试题" class="headerlink" title="常考面试题"></a>常考面试题</h2><ul><li><p>请简述ZooKeeper的选举机制</p><blockquote><p>半数机制：2n+1 </p><p>10 台服务器：3 台 zk</p><p>20 台服务器：5 台 zk</p><p>100 台服务器：11 台 zk</p><p>【注意】台数并不是越多越好。 太多选举时间过长影响性能。 </p></blockquote></li><li><p>ZooKeeper的监听原理</p></li><li><p>ZooKeeper的常用命令</p></li><li><p>ZooKeeper的部署方式有哪几种？集群中的角色有哪些？集群最少需要几台机器？</p><ul><li>部署方式单机模式、集群模式</li><li>角色：Leader和Follower</li><li>集群最少需要机器数：3</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="zookeeper" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/zookeeper/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="面试" scheme="https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="大数据" scheme="https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="教程" scheme="https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="zookeeper" scheme="https://masteryang4.github.io/tags/zookeeper/"/>
    
      <category term="分布式" scheme="https://masteryang4.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[精]Redis总结与思考</title>
    <link href="https://masteryang4.github.io/2020/05/12/%E7%B2%BE-Redis%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>https://masteryang4.github.io/2020/05/12/%E7%B2%BE-Redis%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2020-05-12T14:20:49.000Z</published>
    <updated>2020-05-14T08:34:01.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis介绍及安装"><a href="#Redis介绍及安装" class="headerlink" title="Redis介绍及安装"></a>Redis介绍及安装</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>1、Redis是最常用的非关系型数据库（NoSQL）——不依赖业务逻辑方式存储，而以简单的key-value模式存储。</p><blockquote><p>常见的NoSQL数据库：</p><p>​         Memcached,Redis,MongoDB,HBase</p></blockquote><p>2、Redis有16个库，编号为0~15，默认使用0号库。</p><p>3、Redis使用的是<strong>单线程+多路IO复用技术</strong>（Linux系统特有）。</p><h2 id="Redis安装及启动"><a href="#Redis安装及启动" class="headerlink" title="Redis安装及启动"></a>Redis安装及启动</h2><p><strong>1、Redis安装步骤：</strong></p><ul><li>首先保证有gcc-c++工具，否则先执行：yum install gcc-c++</li><li>下载获得redis-3.2.5.tar.gz后将它放入Linux目录</li><li>解压命令:tar -zxvf redis-3.2.5.tar.gz</li><li>解压完成后进入目录:cd redis-3.2.5</li><li>在redis-3.2.5目录下执行make命令</li><li>在redis-3.2.5目录下执行make install命令</li></ul><p><strong>2、Redis默认安装目录：/usr/local/bin</strong></p><ul><li>redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何(服务启动起来后执行)</li><li>redis-check-aof：修复有问题的AOF文件</li><li>redis-check-rdb：修复有问题RDB文件</li><li>redis-sentinel：Redis集群使用</li><li>redis-server：Redis服务器启动命令</li><li>redis-cli：客户端，操作入口</li></ul><p><strong>3、Redis启动：</strong></p><ul><li>备份redis.conf：拷贝一份redis.conf到其他目录</li><li>修改redis.conf文件将里面的daemonize no 改成 yes(128行)，让服务在后台启动</li><li>启动命令：执行  redis-server  /root/myredis/redis.conf</li><li>用客户端访问: redis-cli -p  <strong>6379</strong></li><li>关闭：客户端中输入shutdown，redis-server进程就已关闭。之后Ctrl+c退出客户端即可。</li></ul><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><blockquote><p><strong>常用</strong>五大数据类型：String,list,set,hash,zset</p></blockquote><p>五大数据类型常用指令：</p><h2 id="0、Key"><a href="#0、Key" class="headerlink" title="0、Key"></a>0、Key</h2><table><thead><tr><th>Key常用指令</th><th></th></tr></thead><tbody><tr><td>keys *</td><td>查询当前库的所有键</td></tr><tr><td>exists <code>&lt;key&gt;</code></td><td>判断某个键是否存在</td></tr><tr><td>type  <code>&lt;key&gt;</code></td><td>查看键对应的数据的类型</td></tr><tr><td>del  <code>&lt;key&gt;</code></td><td>删除某个键</td></tr><tr><td>expire   <code>&lt;key&gt; &lt;seconds&gt;</code></td><td>为键值设置过期时间，单位秒</td></tr><tr><td>ttl   <code>&lt;key&gt;</code></td><td>查看还有多少秒过期，-1表示永不过期，-2表示已过期</td></tr><tr><td>dbsize</td><td>查看当前数据库的key的数量</td></tr><tr><td>flushdb</td><td>清空当前库</td></tr><tr><td>flushall</td><td>通杀全部库</td></tr></tbody></table><h2 id="1、String"><a href="#1、String" class="headerlink" title="1、String"></a>1、String</h2><ul><li>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</li><li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</li></ul><table><thead><tr><th>String常用指令</th><th></th></tr></thead><tbody><tr><td>get   <code>&lt;key&gt;</code></td><td>查询对应键值</td></tr><tr><td>set   <code>&lt;key&gt;  &lt;value&gt;</code></td><td>添加键值对</td></tr><tr><td>append  <code>&lt;key&gt;  &lt;value&gt;</code></td><td>将给定的<code>&lt;value&gt;</code>追加到原值的末尾</td></tr><tr><td>strlen  <code>&lt;key&gt;</code></td><td>获得值的长度</td></tr><tr><td>setnx  <code>&lt;key&gt;  &lt;value&gt;</code></td><td>只有在 key 不存在时设置 key 的值</td></tr><tr><td>incr <code>&lt;key&gt;</code></td><td>将 key 中储存的数字值增1。<br>只能对数字值操作，如果为空，新增值为1</td></tr><tr><td>decr  <code>&lt;key&gt;</code></td><td>将 key 中储存的数字值减1。<br>只能对数字值操作，如果为空，新增值为-1</td></tr><tr><td>incrby / decrby  <code>&lt;key&gt;</code>  <code>&lt;步长&gt;</code></td><td>将 key 中储存的数字值增减。自定义步长</td></tr><tr><td>mset  <code>&lt;key1&gt;  &lt;value1&gt;  &lt;key2&gt;  &lt;value2&gt;</code>  …</td><td>同时设置一个或多个 key-value对</td></tr><tr><td>mget  <code>&lt;key1&gt;   &lt;key2&gt;   &lt;key3&gt;</code> …</td><td>同时获取一个或多个 value</td></tr><tr><td>msetnx <code>&lt;key1&gt;  &lt;value1&gt;  &lt;key2&gt;  &lt;value2&gt;</code>  …</td><td>同时设置一个或多个 key-value 对，<br>当且仅当所有给定 key 都不存在。</td></tr><tr><td>getrange  <code>&lt;key&gt;  &lt;起始位置&gt;  &lt;结束位置&gt;</code></td><td>获得值的范围，类似java中的substring</td></tr><tr><td>setrange  <code>&lt;key&gt;   &lt;起始位置&gt;   &lt;value&gt;</code></td><td>用 <code>&lt;value&gt;</code>覆写<code>&lt;key&gt;</code>所储存的字符串值<br>，从<code>&lt;起始位置&gt;</code>开始</td></tr><tr><td>setex  <code>&lt;key&gt;  &lt;过期时间&gt;   &lt;value&gt;</code></td><td>设置键值的同时，设置过期时间，单位秒</td></tr><tr><td>getset <code>&lt;key&gt;  &lt;value&gt;</code></td><td>以新换旧，设置了新值同时获得旧值</td></tr></tbody></table><h2 id="2、List"><a href="#2、List" class="headerlink" title="2、List"></a>2、List</h2><ul><li>单键多值</li><li>Redis 列表是简单的字符串列表，按照插入顺序排序。</li><li>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</li></ul><table><thead><tr><th>List常用指令</th><th></th></tr></thead><tbody><tr><td>lpush/rpush  <code>&lt;key&gt;  &lt;value1&gt;  &lt;value2&gt;</code> …</td><td>从左边/右边插入一个或多个值</td></tr><tr><td>lpop/rpop  <code>&lt;key&gt;</code></td><td>从左边/右边吐出一个值。值在键在，值亡键亡。</td></tr><tr><td>rpoplpush  <code>&lt;key1&gt;  &lt;key2&gt;</code></td><td>从<code>&lt;key1&gt;</code>列表右边吐出一个值，插到<code>&lt;key2&gt;</code>列表左边</td></tr><tr><td>lrange <code>&lt;key&gt; &lt;start&gt; &lt;stop&gt;</code></td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>lindex <code>&lt;key&gt; &lt;index&gt;</code></td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>llen <code>&lt;key&gt;</code></td><td>获得列表长度</td></tr><tr><td>linsert <code>&lt;key&gt;</code>  before <code>&lt;value&gt;  &lt;newvalue&gt;</code></td><td>在<code>&lt;value&gt;</code>的前面插入<code>&lt;newvalue&gt;</code></td></tr><tr><td>lrem <code>&lt;key&gt; &lt;n&gt;  &lt;value&gt;</code></td><td>从左边删除n个value(从左到右)</td></tr></tbody></table><h2 id="3、Set"><a href="#3、Set" class="headerlink" title="3、Set"></a>3、Set</h2><ul><li>Redis的Set是string类型的无序集合</li><li>它底层其实是一个value为null的hash表,所以添加，删除，查找的复杂度都是O(1)。</li></ul><table><thead><tr><th>Set常用指令</th><th></th></tr></thead><tbody><tr><td>sadd <code>&lt;key&gt;  &lt;value1&gt;  &lt;value2&gt;</code> …</td><td>将一个或多个 member 元素加入到集合 key 当中，<br>已经存在于集合的 member 元素将被忽略。</td></tr><tr><td>smembers <code>&lt;key&gt;</code></td><td>取出该集合的所有值</td></tr><tr><td>sismember <code>&lt;key&gt;  &lt;value&gt;</code></td><td>判断集合<code>&lt;key&gt;</code>是否为含有该<code>&lt;value&gt;</code>值，有返回1，没有返回0</td></tr><tr><td>scard   <code>&lt;key&gt;</code></td><td>返回该集合的元素个数。</td></tr><tr><td>srem <code>&lt;key&gt; &lt;value1&gt; &lt;value2&gt;</code> …</td><td>删除集合中的某个元素。</td></tr><tr><td>spop <code>&lt;key&gt; &lt;n&gt;</code></td><td>随机从该集合中吐出一个或多个值。</td></tr><tr><td>srandmember <code>&lt;key&gt; &lt;n&gt;</code></td><td>随机从该集合中取出n个值。不会从集合中删除。</td></tr><tr><td>sinter <code>&lt;key1&gt; &lt;key2&gt;</code></td><td>返回两个集合的交集元素。</td></tr><tr><td>sunion <code>&lt;key1&gt; &lt;key2&gt;</code></td><td>返回两个集合的并集元素。</td></tr><tr><td>sdiff <code>&lt;key1&gt; &lt;key2&gt;</code></td><td>返回两个集合的差集元素。</td></tr></tbody></table><h2 id="4、Hash"><a href="#4、Hash" class="headerlink" title="4、Hash"></a>4、Hash</h2><ul><li>Redis  hash 是一个键值对集合。</li><li>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储<strong>对象</strong>。</li><li>类似Java里面的Map&lt;String,Object&gt;</li></ul><table><thead><tr><th align="left">Hash常用指令</th><th></th></tr></thead><tbody><tr><td align="left">hset <code>&lt;key&gt;  &lt;field&gt;  &lt;value&gt;</code></td><td>给<code>&lt;key&gt;</code>集合中的<code>&lt;field&gt;</code>键赋值<code>&lt;value&gt;</code></td></tr><tr><td align="left">hget <code>&lt;key&gt;  &lt;field&gt;</code></td><td>从<code>&lt;key&gt;</code>集合<code>&lt;field&gt;</code>取出 value</td></tr><tr><td align="left">hmset <code>&lt;key&gt;  &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;</code>…</td><td>批量设置hash的值</td></tr><tr><td align="left">hexists key  <code>&lt;field&gt;</code></td><td>查看哈希表 key 中，给定域 field 是否存在</td></tr><tr><td align="left">hkeys <code>&lt;key&gt;</code></td><td>列出该hash集合的所有field</td></tr><tr><td align="left">hvals <code>&lt;key&gt;</code></td><td>列出该hash集合的所有value</td></tr><tr><td align="left">hincrby <code>&lt;key&gt; &lt;field&gt;  &lt;increment&gt;</code></td><td>为哈希表 key 中的域 field 的值加上增量 increment</td></tr><tr><td align="left">hsetnx <code>&lt;key&gt;  &lt;field&gt; &lt;value&gt;</code></td><td>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</td></tr></tbody></table><h2 id="5、zset-sorted-set"><a href="#5、zset-sorted-set" class="headerlink" title="5、zset  (sorted set)"></a>5、zset  (sorted set)</h2><ul><li><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p></li><li><p>有序集合的所有成员都关联了一个评分（score） ，这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。（集合的成员是唯一的，但是评分可以是重复了的）</p></li><li><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p></li></ul><table><thead><tr><th>zset常用指令</th><th></th></tr></thead><tbody><tr><td>zadd  <code>&lt;key&gt; &lt;score1&gt; &lt;value1&gt;  &lt;score2&gt; &lt;value2&gt;</code>…</td><td>将一个或多个 member 元素及其 score 值加入到有序集 key 当中</td></tr><tr><td>zrange <code>&lt;key&gt;  &lt;start&gt; &lt;stop&gt;</code>  [WITHSCORES]</td><td>返回有序集 key 中，下标在<code>&lt;start&gt; &lt;stop&gt;</code>之间的元素。<br>带WITHSCORES，可以让分数一起和值返回到结果集。</td></tr><tr><td>zrangebyscore key min max [withscores] [limit offset count]</td><td>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列</td></tr><tr><td>zrevrangebyscore key max min [withscores] [limit offset count]</td><td>同上，改为从大到小排列</td></tr><tr><td>zincrby <code>&lt;key&gt; &lt;increment&gt; &lt;value&gt;</code></td><td>为元素的score加上增量</td></tr><tr><td>zrem  <code>&lt;key&gt;  &lt;value&gt;</code></td><td>删除该集合下，指定值的元素</td></tr><tr><td>zcount <code>&lt;key&gt;  &lt;min&gt;  &lt;max&gt;</code></td><td>统计该集合，分数区间内的元素个数</td></tr><tr><td>zrank <code>&lt;key&gt;  &lt;value&gt;</code></td><td>返回该值在集合中的排名，从0开始</td></tr></tbody></table><h1 id="Redis的Java客户端Jedis"><a href="#Redis的Java客户端Jedis" class="headerlink" title="Redis的Java客户端Jedis"></a>Redis的Java客户端Jedis</h1><p>maven依赖：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h1 id="Redis常考面试题"><a href="#Redis常考面试题" class="headerlink" title="Redis常考面试题"></a>Redis常考面试题</h1><p>-</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis介绍及安装&quot;&gt;&lt;a href=&quot;#Redis介绍及安装&quot; class=&quot;headerlink&quot; title=&quot;Redis介绍及安装&quot;&gt;&lt;/a&gt;Redis介绍及安装&lt;/h1&gt;&lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Redis" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Redis/"/>
    
    
      <category term="面试" scheme="https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="大数据" scheme="https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Redis" scheme="https://masteryang4.github.io/tags/Redis/"/>
    
      <category term="JavaWeb" scheme="https://masteryang4.github.io/tags/JavaWeb/"/>
    
      <category term="数据库" scheme="https://masteryang4.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="教程" scheme="https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUnit常用注解</title>
    <link href="https://masteryang4.github.io/2020/05/12/JUnit%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://masteryang4.github.io/2020/05/12/JUnit%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-05-12T11:49:00.000Z</published>
    <updated>2020-05-12T12:14:44.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JUnit常用注解"><a href="#JUnit常用注解" class="headerlink" title="JUnit常用注解"></a>JUnit常用注解</h1><p>JUnit是 Java平台最常用的测试框架 。</p><p>本文重点阐述JUnit4版本的@Before、@After、@BeforeClass、@AfterClass四个注解。</p><h2 id="JUnit4，JUnit5注解对比"><a href="#JUnit4，JUnit5注解对比" class="headerlink" title="JUnit4，JUnit5注解对比"></a>JUnit4，JUnit5注解对比</h2><table><thead><tr><th>JUnit4</th><th>JUnit5</th><th>功能</th></tr></thead><tbody><tr><td>@BeforeClass</td><td>@BeforeAll</td><td>在当前类的<strong>所有测试方法</strong>之前执行。注解在【静态方法】上。</td></tr><tr><td>@AfterClass</td><td>@AfterAll</td><td>在当前类中的<strong>所有测试方法</strong>之后执行。注解在【静态方法】上。</td></tr><tr><td>@Before</td><td>@BeforeEach</td><td>在<strong>每个测试方法</strong>之前执行。注解在【非静态方法】上。</td></tr><tr><td>@After</td><td>@AfterEach</td><td>在<strong>每个测试方法</strong>之后执行。注解在【非静态方法】上。</td></tr></tbody></table><p>为什么 JUnit中@BeforeClass和@AfterClass标注的方法必须是static的 ？</p><p>其实和JUnit的运行机制有关：</p><blockquote><p>在JUnit中：每运行一个@Test方法，就会为该测试类新建一个新的实例。所以@BeforeClass和@AfterClass必须是static的，因为运行他们的时候，测试类还没有实例化。</p><p>这种设计有助于提高测试方法之间的独立性，因为每个@Test执行的时候，都新建了一个实例，这样的话，可以避免测试方法之间重用各个@Test方法里面的变量值。</p></blockquote><p>示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUintDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"test1 i="</span> + i); <span class="comment">//test1 i=1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2 i="</span> + i); <span class="comment">//test2 i=2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="comment">//【静态方法】</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before class:begin this class================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="comment">//【静态方法】</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after class:end this class================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before:begin test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after:end test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[this is a test!]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[this is another test!!!!!]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>执行整个JunitTest文件，输出结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before class:begin this class&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">before:begin test</span><br><span class="line">[this is a test!]</span><br><span class="line">after:end test</span><br><span class="line">before:begin test</span><br><span class="line">[this is another test!!!!!]</span><br><span class="line">after:end test</span><br><span class="line">after class:end this class&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一整个JUnit4的单元测试用例执行顺序为： </p><p>​        @BeforeClass -&gt; @Before -&gt; @Test -&gt; @After -&gt; @AfterClass; </p><p>每一个单独的测试方法的调用顺序为： </p><p>​        @Before -&gt; @Test -&gt; @After; </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JUnit常用注解&quot;&gt;&lt;a href=&quot;#JUnit常用注解&quot; class=&quot;headerlink&quot; title=&quot;JUnit常用注解&quot;&gt;&lt;/a&gt;JUnit常用注解&lt;/h1&gt;&lt;p&gt;JUnit是 Java平台最常用的测试框架 。&lt;/p&gt;
&lt;p&gt;本文重点阐述JUnit
      
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="基础知识" scheme="https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
      <category term="JUnit" scheme="https://masteryang4.github.io/tags/JUnit/"/>
    
      <category term="单元测试" scheme="https://masteryang4.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>[SparkSQL]UDAF自定义聚合函数</title>
    <link href="https://masteryang4.github.io/2020/05/05/SparkSQL-UDAF%E8%87%AA%E5%AE%9A%E4%B9%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"/>
    <id>https://masteryang4.github.io/2020/05/05/SparkSQL-UDAF%E8%87%AA%E5%AE%9A%E4%B9%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-05T13:30:07.000Z</published>
    <updated>2020-05-05T13:45:04.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SparkSQL-UDAF自定义聚合函数"><a href="#SparkSQL-UDAF自定义聚合函数" class="headerlink" title="[SparkSQL]UDAF自定义聚合函数"></a>[SparkSQL]UDAF自定义聚合函数</h1><p>SparkSql中，用户可以设定自己的自定义聚合函数（UserDefinedAggregateFunction）。</p><blockquote><p>需求：实现平均年龄</p></blockquote><p>user.json 文件：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">json</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"username"</span>: <span class="string">"lisi"</span>,<span class="attr">"userage"</span>: <span class="number">40</span>&#125;</span><br><span class="line">&#123;<span class="attr">"username"</span>: <span class="string">"zhangsan"</span>,<span class="attr">"userage"</span>: <span class="number">30</span>&#125;</span><br><span class="line">&#123;<span class="attr">"username"</span>: <span class="string">"wangwu"</span>,<span class="attr">"userage"</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure></div><h2 id="UDAF-弱类型"><a href="#UDAF-弱类型" class="headerlink" title="UDAF - 弱类型"></a>UDAF - 弱类型</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.&#123;<span class="type">MutableAggregationBuffer</span>, <span class="type">UserDefinedAggregateFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types.&#123;<span class="type">DataType</span>, <span class="type">DoubleType</span>, <span class="type">LongType</span>, <span class="type">StructField</span>, <span class="type">StructType</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">DataFrame</span>, <span class="type">Row</span>, <span class="type">SparkSession</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">AccumulatorV2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SparkSQL_UDAF01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"sparksql"</span>)</span><br><span class="line">        <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().config(sparkConf).getOrCreate()</span><br><span class="line">        <span class="comment">// TODO 读取JSON数据</span></span><br><span class="line">        <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.json(<span class="string">"input/user.json"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 使用自定义聚合函数实现年龄的平均值计算</span></span><br><span class="line">        <span class="comment">// buffer</span></span><br><span class="line">        <span class="comment">// select avg(age) from user</span></span><br><span class="line">        <span class="comment">// 创建自定义函数</span></span><br><span class="line">        <span class="keyword">val</span> udaf = <span class="keyword">new</span> <span class="type">MyAvgAgeUDAF</span></span><br><span class="line">        <span class="comment">// 注册UDAF函数</span></span><br><span class="line">        spark.udf.register(<span class="string">"avgAge"</span>, udaf)</span><br><span class="line"></span><br><span class="line">        df.createTempView(<span class="string">"user"</span>)</span><br><span class="line"></span><br><span class="line">        spark.sql(<span class="string">"select avgAge(userage) from user"</span>).show</span><br><span class="line"></span><br><span class="line">        spark.close</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * TODO 自定义聚合函数（UDAF）</span></span><br><span class="line"><span class="comment">     * 1. 继承UserDefinedAggregateFunction</span></span><br><span class="line"><span class="comment">     * 2. 重写方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyAvgAgeUDAF</span> <span class="keyword">extends</span> <span class="title">UserDefinedAggregateFunction</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 传入聚合函数的数据结构</span></span><br><span class="line">        <span class="comment">// 1 =&gt; age =&gt; Long</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">inputSchema</span></span>: <span class="type">StructType</span> = &#123;</span><br><span class="line">            <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">                <span class="type">StructField</span>(<span class="string">"age"</span>, <span class="type">LongType</span>)</span><br><span class="line">            ))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 用于计算的缓冲区的数据结构</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferSchema</span></span>: <span class="type">StructType</span> = &#123;</span><br><span class="line">            <span class="type">StructType</span>(<span class="type">Array</span>(</span><br><span class="line">                <span class="type">StructField</span>(<span class="string">"totalage"</span>, <span class="type">LongType</span>),</span><br><span class="line">                <span class="type">StructField</span>(<span class="string">"totalcnt"</span>, <span class="type">LongType</span>)</span><br><span class="line">            ))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 输出结果的类型</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">dataType</span></span>: <span class="type">DataType</span> = <span class="type">DoubleType</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 函数稳定性（幂等性）</span></span><br><span class="line">        <span class="comment">// 给函数相同的输入值，计算结果也相同</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">deterministic</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 用于计算的缓冲区初始化</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            buffer(<span class="number">0</span>) = <span class="number">0</span>L</span><br><span class="line">            buffer(<span class="number">1</span>) = <span class="number">0</span>L</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 将输入的值更新到缓冲区中</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(buffer: <span class="type">MutableAggregationBuffer</span>, input: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            buffer(<span class="number">0</span>) = buffer.getLong(<span class="number">0</span>) + input.getLong(<span class="number">0</span>)</span><br><span class="line">            buffer(<span class="number">1</span>) = buffer.getLong(<span class="number">1</span>) + <span class="number">1</span>L</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 合并缓冲区</span></span><br><span class="line">        <span class="comment">// MutableAggregationBuffer 继承了Row</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(buffer1: <span class="type">MutableAggregationBuffer</span>, buffer2: <span class="type">Row</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">            buffer1(<span class="number">0</span>) = buffer1.getLong(<span class="number">0</span>) + buffer2.getLong(<span class="number">0</span>)</span><br><span class="line">            buffer1(<span class="number">1</span>) = buffer1.getLong(<span class="number">1</span>) + buffer2.getLong(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 计算结果</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>(buffer: <span class="type">Row</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">            buffer.getLong(<span class="number">0</span>).toDouble / buffer.getLong(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">|myavgageudaf(userage)|</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">|                 30.0|</span><br><span class="line">+<span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure></div><h2 id="UDAF-强类型"><a href="#UDAF-强类型" class="headerlink" title="UDAF - 强类型"></a>UDAF - 强类型</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.&#123;<span class="type">DataFrame</span>, <span class="type">Dataset</span>, <span class="type">Encoder</span>, <span class="type">Encoders</span>, <span class="type">SparkSession</span>, <span class="type">TypedColumn</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.expressions.<span class="type">Aggregator</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">UDAF02</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"myudaf"</span>)</span><br><span class="line">    <span class="keyword">val</span> spark: <span class="type">SparkSession</span> = <span class="type">SparkSession</span>.builder().config(conf).getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="keyword">val</span> df: <span class="type">DataFrame</span> = spark.read.json(<span class="string">"input/user.json"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装为DataSet</span></span><br><span class="line">    <span class="keyword">val</span> ds: <span class="type">Dataset</span>[<span class="type">User01</span>] = df.as[<span class="type">User01</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建聚合函数</span></span><br><span class="line">    <span class="keyword">var</span> myAgeUdtf1 = <span class="keyword">new</span> <span class="type">MyAveragUDAF1</span></span><br><span class="line">    <span class="comment">//将聚合函数转换为查询的列</span></span><br><span class="line">    <span class="keyword">val</span> col: <span class="type">TypedColumn</span>[<span class="type">User01</span>, <span class="type">Double</span>] = myAgeUdtf1.toColumn</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    ds.select(col).show()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输入数据类型</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User01</span>(<span class="params">username: <span class="type">String</span>, userage: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">//缓存类型</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">AgeBuffer</span>(<span class="params">var sum: <span class="type">Long</span>, var count: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">/**</span></span></span><br><span class="line"><span class="class">    <span class="title">*</span> <span class="title">定义类继承org</span>.<span class="title">apache</span>.<span class="title">spark</span>.<span class="title">sql</span>.<span class="title">expressions</span>.<span class="title">Aggregator</span></span></span><br><span class="line"><span class="class">    <span class="title">*</span> <span class="title">重写类中的方法</span></span></span><br><span class="line"><span class="class">    <span class="title">*/</span></span></span><br><span class="line"><span class="class">  <span class="title">class</span> <span class="title">MyAveragUDAF1</span> <span class="keyword">extends</span> <span class="title">Aggregator</span>[<span class="type">User01</span>, <span class="type">AgeBuffer</span>, <span class="type">Double</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">AgeBuffer</span> = &#123;</span><br><span class="line">      <span class="type">AgeBuffer</span>(<span class="number">0</span>L, <span class="number">0</span>L)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(b: <span class="type">AgeBuffer</span>, a: <span class="type">User01</span>): <span class="type">AgeBuffer</span> = &#123;</span><br><span class="line">      b.sum = b.sum + a.userage</span><br><span class="line">      b.count = b.count + <span class="number">1</span></span><br><span class="line">      b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(b1: <span class="type">AgeBuffer</span>, b2: <span class="type">AgeBuffer</span>): <span class="type">AgeBuffer</span> = &#123;</span><br><span class="line">      b1.sum = b1.sum + b2.sum</span><br><span class="line">      b1.count = b1.count + b2.count</span><br><span class="line">      b1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">finish</span></span>(buff: <span class="type">AgeBuffer</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">      buff.sum.toDouble / buff.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DataSet默认额编解码器，用于序列化，固定写法</span></span><br><span class="line">    <span class="comment">//自定义类型就是produce   自带类型根据类型选择</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">bufferEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">AgeBuffer</span>] = &#123;</span><br><span class="line">      <span class="type">Encoders</span>.product</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputEncoder</span></span>: <span class="type">Encoder</span>[<span class="type">Double</span>] = &#123;</span><br><span class="line">      <span class="type">Encoders</span>.scalaDouble</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-----------------------------------------------------+</span></span><br><span class="line">|MyAveragUDAF1(com.atguigu.sparksql.UDAF_qiang$User01)|</span><br><span class="line">+<span class="comment">-----------------------------------------------------+</span></span><br><span class="line">|                                                 30.0|</span><br><span class="line">+<span class="comment">-----------------------------------------------------+</span></span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SparkSQL-UDAF自定义聚合函数&quot;&gt;&lt;a href=&quot;#SparkSQL-UDAF自定义聚合函数&quot; class=&quot;headerlink&quot; title=&quot;[SparkSQL]UDAF自定义聚合函数&quot;&gt;&lt;/a&gt;[SparkSQL]UDAF自定义聚合函数&lt;/h1
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spark" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"/>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spark" scheme="https://masteryang4.github.io/tags/spark/"/>
    
      <category term="sparksql" scheme="https://masteryang4.github.io/tags/sparksql/"/>
    
  </entry>
  
  <entry>
    <title>HashMap文章推荐</title>
    <link href="https://masteryang4.github.io/2020/04/30/HashMap%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/"/>
    <id>https://masteryang4.github.io/2020/04/30/HashMap%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/</id>
    <published>2020-04-30T15:42:39.000Z</published>
    <updated>2020-05-09T13:27:03.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap文章推荐"><a href="#HashMap文章推荐" class="headerlink" title="HashMap文章推荐"></a>HashMap文章推荐</h1><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p><p>【强烈推荐】来自<strong>美团技术团队</strong>，里面的参考文章也非常好</p><p><a href="https://zhuanlan.zhihu.com/p/96426441" target="_blank" rel="noopener">《吊打面试官》系列-HashMap</a></p><p><a href="https://zhuanlan.zhihu.com/p/97902016" target="_blank" rel="noopener">《吊打面试官》系列-ConcurrentHashMap &amp; HashTable</a></p><p>来自敖丙（蘑菇街大佬），从面试官角度阐述关键技术点，十分硬核，全是干货。</p><p><a href="https://zhuanlan.zhihu.com/p/125628540" target="_blank" rel="noopener">一个HashMap跟面试官扯了半个小时</a></p><p>面试者角度阐述HashMap。</p><p>有空闲时间的话，我自己也会出一篇，甚至是一系列的HashMap文章，</p><p>比如</p><ul><li>源码分析，</li><li>知识点总结，</li><li>常考面试题归档 等等</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap文章推荐&quot;&gt;&lt;a href=&quot;#HashMap文章推荐&quot; class=&quot;headerlink&quot; title=&quot;HashMap文章推荐&quot;&gt;&lt;/a&gt;HashMap文章推荐&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.co
      
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="集合" scheme="https://masteryang4.github.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
      <category term="hashmap" scheme="https://masteryang4.github.io/tags/hashmap/"/>
    
      <category term="面试" scheme="https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java IO相关总结归纳</title>
    <link href="https://masteryang4.github.io/2020/04/29/Java-IO%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    <id>https://masteryang4.github.io/2020/04/29/Java-IO%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/</id>
    <published>2020-04-29T14:12:12.000Z</published>
    <updated>2020-04-29T14:14:13.243Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="基础知识" scheme="https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[spark]十一种方式实现WordCount</title>
    <link href="https://masteryang4.github.io/2020/04/27/spark-%E5%8D%81%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0WordCount/"/>
    <id>https://masteryang4.github.io/2020/04/27/spark-%E5%8D%81%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0WordCount/</id>
    <published>2020-04-27T14:23:10.000Z</published>
    <updated>2020-04-27T15:12:53.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spark-十一种方式实现WordCount"><a href="#Spark-十一种方式实现WordCount" class="headerlink" title="[Spark]十一种方式实现WordCount"></a>[Spark]十一种方式实现WordCount</h1><p>使用Spark中的11种方法实现经典的WordCount算法。</p><p>其中，10种SparkRDD（算子）+ 1种自定义累加器实现。</p><blockquote><p>特朗普：没人比我更懂WordCount！（滑稽）</p></blockquote><h2 id="Why-WordCount？"><a href="#Why-WordCount？" class="headerlink" title="Why WordCount？"></a>Why WordCount？</h2><ul><li>大数据中最经典的算法，相当于编程语言中的“Hello World”。</li><li>在大数据处理中，大多数复杂的问题通常被拆分成一个个小问题，这些小问题一般都是基于WordCount算法。所以，WordCount是重中之重，是大数据处理算法的基石。</li></ul><h2 id="10种Spark算子实现"><a href="#10种Spark算子实现" class="headerlink" title="10种Spark算子实现"></a>10种Spark算子实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * spark-使用十种[算子]实现wordcount</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RDDWordcount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"spark"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">//    val rdd = sc.textFile("input/wc.txt").flatMap(datas =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//      datas.split(" ")</span></span><br><span class="line">    <span class="comment">//    &#125;)</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"hadoop"</span>, <span class="string">"hello"</span>, <span class="string">"spark"</span>, <span class="string">"hello"</span>, <span class="string">"scala"</span>, <span class="string">"hello"</span>, <span class="string">"scala"</span>, <span class="string">"spark"</span>))</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================1===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.countByValue().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================2===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).countByKey().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================3===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).reduceByKey(_ + _).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================4===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).groupByKey().mapValues(_.size).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================5===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).aggregateByKey(<span class="number">0</span>)(_ + _, _ + _).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================6===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).foldByKey(<span class="number">0</span>)(_ + _).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================7===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).combineByKey(</span><br><span class="line">      (num: <span class="type">Int</span>) =&gt; num,</span><br><span class="line">      (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">        x + y</span><br><span class="line">      &#125;,</span><br><span class="line">      (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">        x + y</span><br><span class="line">      &#125;</span><br><span class="line">    ).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================8===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).groupBy(_._1).map(kv =&gt; &#123;</span><br><span class="line">      (kv._1, kv._2.size)</span><br><span class="line">    &#125;).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================9===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.aggregate(mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]())(</span><br><span class="line">      (map, word) =&gt; &#123;</span><br><span class="line">        map(word) = map.getOrElse(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        map</span><br><span class="line">      &#125;,</span><br><span class="line">      (map1, map2) =&gt; &#123;</span><br><span class="line">        map1.foldLeft(map2)(</span><br><span class="line">          (finalMap, kv) =&gt; &#123;</span><br><span class="line">            finalMap(kv._1) = finalMap.getOrElse(kv._1, <span class="number">0</span>) + kv._2</span><br><span class="line">            finalMap</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    ).foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================10===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map(s =&gt; mutable.<span class="type">Map</span>(s -&gt; <span class="number">1</span>)).fold(mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]())(</span><br><span class="line">      (map1, map2) =&gt; &#123;</span><br><span class="line">        map1.foldLeft(map2)(</span><br><span class="line">          (finalMap, kv) =&gt; &#123;</span><br><span class="line">            finalMap(kv._1) = finalMap.getOrElse(kv._1, <span class="number">0</span>) + kv._2</span><br><span class="line">            finalMap</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    ).foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">=================<span class="number">1</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">2</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">3</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">4</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">5</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">6</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">7</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">8</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">9</span>====================</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">=================<span class="number">10</span>====================</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">(hello,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><h2 id="自定义累加器实现"><a href="#自定义累加器实现" class="headerlink" title="自定义累加器实现"></a>自定义累加器实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">AccumulatorV2</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyAccTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"acc"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Spark - 自定义累加器 - wordcount</span></span><br><span class="line">    <span class="comment">// 累加器可以不使用shuffle就完成数据的聚合功能</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">"hadoop spark"</span>, <span class="string">"hello"</span>, <span class="string">"spark"</span>, <span class="string">"hello"</span>, <span class="string">"scala"</span>, <span class="string">"hello"</span>, <span class="string">"scala"</span>, <span class="string">"spark"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1. 创建累加器</span></span><br><span class="line">    <span class="keyword">val</span> acc = <span class="keyword">new</span> <span class="type">WordCountAccumulator</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2. 向Spark注册累加器</span></span><br><span class="line">    sc.register(acc, <span class="string">"wordcount"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 3. 使用累加器</span></span><br><span class="line">    rdd.foreach(</span><br><span class="line">      words =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> ws = words.split(<span class="string">" "</span>)</span><br><span class="line">        ws.foreach(</span><br><span class="line">          word =&gt; &#123;</span><br><span class="line">            acc.add(word)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(acc.value) <span class="comment">//Map(hadoop -&gt; 1, spark -&gt; 3, scala -&gt; 2, hello -&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义累加器 Map&#123;(Word - Count), (Word - Count)&#125;</span></span><br><span class="line">  <span class="comment">// 1, 继承AccumulatorV2, 定义泛型</span></span><br><span class="line">  <span class="comment">//    IN :  向累加器传递的值的类型 , Out : 累加器的返回结果类型</span></span><br><span class="line">  <span class="comment">// 2. 重写方法</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WordCountAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]] </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> innerMap = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 累加器是否初始化</span></span><br><span class="line">    <span class="comment">// Z</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = innerMap.isEmpty</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 复制累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]] = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">WordCountAccumulator</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 重置累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      innerMap.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 累加数据</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(word: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> cnt = innerMap.getOrElse(word, <span class="number">0</span>)</span><br><span class="line">      innerMap.update(word, cnt + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 合并累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="comment">// 两个Map的合并</span></span><br><span class="line">      <span class="keyword">var</span> map1 = <span class="keyword">this</span>.innerMap</span><br><span class="line">      <span class="keyword">var</span> map2 = other.value</span><br><span class="line"></span><br><span class="line">      innerMap = map1.foldLeft(map2)(</span><br><span class="line">        (map, kv) =&gt; &#123;</span><br><span class="line">          <span class="keyword">val</span> k = kv._1</span><br><span class="line">          <span class="keyword">val</span> v = kv._2</span><br><span class="line">          map(k) = map.getOrElse(k, <span class="number">0</span>) + v</span><br><span class="line">          map</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 获取累加器的值，就是累加器的返回结果</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = innerMap</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>输出结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span>(spark -&gt; <span class="number">3</span>, hadoop -&gt; <span class="number">1</span>, scala -&gt; <span class="number">2</span>, hello -&gt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spark-十一种方式实现WordCount&quot;&gt;&lt;a href=&quot;#Spark-十一种方式实现WordCount&quot; class=&quot;headerlink&quot; title=&quot;[Spark]十一种方式实现WordCount&quot;&gt;&lt;/a&gt;[Spark]十一种方式实现WordC
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spark" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"/>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="spark" scheme="https://masteryang4.github.io/tags/spark/"/>
    
      <category term="scala" scheme="https://masteryang4.github.io/tags/scala/"/>
    
      <category term="wordcount" scheme="https://masteryang4.github.io/tags/wordcount/"/>
    
  </entry>
  
  <entry>
    <title>kafka高效读写数据</title>
    <link href="https://masteryang4.github.io/2020/04/27/kafka%E9%AB%98%E6%95%88%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/"/>
    <id>https://masteryang4.github.io/2020/04/27/kafka%E9%AB%98%E6%95%88%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/</id>
    <published>2020-04-27T12:28:01.000Z</published>
    <updated>2020-05-09T13:26:09.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kafka高效读写数据"><a href="#kafka高效读写数据" class="headerlink" title="kafka高效读写数据"></a>kafka高效读写数据</h1><h2 id="一、分布式集群"><a href="#一、分布式集群" class="headerlink" title="一、分布式集群"></a>一、分布式集群</h2><p>Kafka本身是分布式集群；同时采用分区技术，并发度高。  </p><blockquote><p>zookeeper在kafka中的作用：kafka集群中有一个broker会被选举成controller，负责管理集群broker的上下线，所有的topic分区副本分配和leader选举等工作。controller的管理工作都依赖于zk。</p></blockquote><h2 id="二、顺序写磁盘"><a href="#二、顺序写磁盘" class="headerlink" title="二、顺序写磁盘"></a>二、顺序写磁盘</h2><p>Kafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端，为顺序写。官网有数据表明，同样的磁盘，顺序写能到600M/s，而随机写只有100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。</p><h2 id="三、零复制技术"><a href="#三、零复制技术" class="headerlink" title="三、零复制技术"></a>三、零复制技术</h2><p>kafka零复制技术示意图：</p><p><a href="https://pic.downk.cc/item/5ea7012ec2a9a83be5e629f2.png" data-fancybox="group" data-caption="kafka零拷贝技术" class="fancybox"><img alt="kafka零拷贝技术" title="kafka零拷贝技术" data-src="https://pic.downk.cc/item/5ea7012ec2a9a83be5e629f2.png" class="lazyload"></a></p><p>java复制技术示意图：</p><p>（仅仅复制文件，没有对于文件的应用，效率很低。</p><p>文件要经过操作系统层（OS层）Buffer缓存传给java应用层输入流，输入流再将数据写到输出流，输出流将数据写到OS层缓存，缓存在将数据写到新的文件。。。）</p><p><a href="https://pic.downk.cc/item/5ea701a6c2a9a83be5e6b749.png" data-fancybox="group" data-caption="java拷贝技术原理图解" class="fancybox"><img alt="java拷贝技术原理图解" title="java拷贝技术原理图解" data-src="https://pic.downk.cc/item/5ea701a6c2a9a83be5e6b749.png" class="lazyload"></a></p><p>因为java复制技术在拷贝文件时效率较低，所以对上图做出优化，如下图所示：</p><p>（应用层通知操作系统层：仅仅是复制文件，所以操作系统层就不会将数据传给应用层，直接在操作系统层复制文件即可。）</p><p><a href="https://pic.downk.cc/item/5ea701c6c2a9a83be5e6e1e8.png" data-fancybox="group" data-caption="零拷贝技术图解" class="fancybox"><img alt="零拷贝技术图解" title="零拷贝技术图解" data-src="https://pic.downk.cc/item/5ea701c6c2a9a83be5e6e1e8.png" class="lazyload"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kafka高效读写数据&quot;&gt;&lt;a href=&quot;#kafka高效读写数据&quot; class=&quot;headerlink&quot; title=&quot;kafka高效读写数据&quot;&gt;&lt;/a&gt;kafka高效读写数据&lt;/h1&gt;&lt;h2 id=&quot;一、分布式集群&quot;&gt;&lt;a href=&quot;#一、分布式集群&quot; c
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="kafka" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/"/>
    
    
      <category term="面试" scheme="https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="大数据" scheme="https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="kafka" scheme="https://masteryang4.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>flume总结与思考</title>
    <link href="https://masteryang4.github.io/2020/04/24/%E7%B2%BE-flume%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>https://masteryang4.github.io/2020/04/24/%E7%B2%BE-flume%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2020-04-24T15:50:53.000Z</published>
    <updated>2020-05-14T08:34:21.325Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="flume" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flume/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="面试" scheme="https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="大数据" scheme="https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="教程" scheme="https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="flume" scheme="https://masteryang4.github.io/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>kafka分区分配策略</title>
    <link href="https://masteryang4.github.io/2020/04/23/kafka%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://masteryang4.github.io/2020/04/23/kafka%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</id>
    <published>2020-04-23T09:09:56.000Z</published>
    <updated>2020-05-09T13:25:52.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kafka分区分配策略"><a href="#kafka分区分配策略" class="headerlink" title="kafka分区分配策略"></a>kafka分区分配策略</h1><p>kafka系列总结之：kafka分区分配策略[转载&amp;归纳]</p><ul><li>kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。</li><li>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据 </li></ul><p>kafka官网：</p><blockquote><p>kafka.apache.org</p></blockquote><p>kafka分区分配策略文章索引</p><p>1、 <a href="https://blog.csdn.net/u013256816/article/details/81123600" target="_blank" rel="noopener">Kafka分区分配策略（1）——RangeAssignor</a></p><p>2、 <a href="https://blog.csdn.net/u013256816/article/details/81123625" target="_blank" rel="noopener">Kafka分区分配策略（2）——RoundRobinAssignor和StickyAssignor</a></p><p>3、 <a href="https://blog.csdn.net/u013256816/article/details/81123858" target="_blank" rel="noopener">Kafka分区分配策略（3）——自定义分区分配策略</a> </p><p>4、 <a href="https://blog.csdn.net/u013256816/article/details/81123907" target="_blank" rel="noopener">Kafka分区分配策略（4）——分配的实施</a></p><blockquote><p>[注]作者为 《深入理解Kafka:核心设计与实践原理》 的作者：朱忠华老师</p><p>作者更多kafka技术文章： <a href="https://blog.csdn.net/u013256816/category_6500871.html" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/category_6500871.html</a> </p><p>作者个人博客： <a href="http://honeypps.com/" target="_blank" rel="noopener">http://honeypps.com/</a></p><p>作者CSDN博客： <a href="https://blog.csdn.net/u013256816" target="_blank" rel="noopener">https://blog.csdn.net/u013256816</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kafka分区分配策略&quot;&gt;&lt;a href=&quot;#kafka分区分配策略&quot; class=&quot;headerlink&quot; title=&quot;kafka分区分配策略&quot;&gt;&lt;/a&gt;kafka分区分配策略&lt;/h1&gt;&lt;p&gt;kafka系列总结之：kafka分区分配策略[转载&amp;amp;归纳]&lt;
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="kafka" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="大数据" scheme="https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="kafka" scheme="https://masteryang4.github.io/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>scala中的flatMap和foldLeft函数</title>
    <link href="https://masteryang4.github.io/2020/04/21/scala%E4%B8%AD%E7%9A%84flatMap%E5%92%8CfoldLeft%E5%87%BD%E6%95%B0/"/>
    <id>https://masteryang4.github.io/2020/04/21/scala%E4%B8%AD%E7%9A%84flatMap%E5%92%8CfoldLeft%E5%87%BD%E6%95%B0/</id>
    <published>2020-04-21T14:34:32.000Z</published>
    <updated>2020-04-27T15:10:43.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scala中的flatMap和foldLeft函数"><a href="#scala中的flatMap和foldLeft函数" class="headerlink" title="scala中的flatMap和foldLeft函数"></a>scala中的flatMap和foldLeft函数</h1><p>scala由于其函数式编程的特性，在大数据的处理中被广泛使用。</p><p>此文针对scala集合中两个常用的，却不太好理解的函数进行示例讲解。</p><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>scala中最重要的函数之一，映射扁平化</p><p>把握以下三点即可：</p><blockquote><p>1、flatMap = map + flatten</p><p>2、什么类型调用的flatMap方法，则返回的也是什么类型</p><p>3、<strong>先对集合中的每个元素进行map，</strong></p><p>​      <strong>再对map后的每个元素（map后的每个元素必须还是集合）中的每个元素进行flatten</strong></p></blockquote><p>[注] 进行map的对象可以是只含一层的集合，但进行flatten操作的对象必需是至少含两层的集合</p><p>map和flatten示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test0001</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 集合映射</span></span><br><span class="line">    println(<span class="string">"map =&gt; "</span> + list.map(x=&gt;&#123;x*<span class="number">2</span>&#125;)) <span class="comment">//map =&gt; List(2, 4, 6, 8)</span></span><br><span class="line">    println(<span class="string">"map =&gt; "</span> + list.map(x=&gt;x*<span class="number">2</span>))   <span class="comment">//map =&gt; List(2, 4, 6, 8)</span></span><br><span class="line">    println(<span class="string">"map =&gt; "</span> + list.map(_*<span class="number">2</span>))      <span class="comment">//map =&gt; List(2, 4, 6, 8)</span></span><br><span class="line">    <span class="comment">// 集合扁平化</span></span><br><span class="line">    <span class="keyword">val</span> list1 = <span class="type">List</span>(</span><br><span class="line">      <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">      <span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    )</span><br><span class="line">    println(<span class="string">"flatten =&gt;"</span> + list1.flatten)   <span class="comment">//flatten =&gt;List(1, 2, 3, 4)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>flatMap示例一：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="type">Set</span>(<span class="string">"scala"</span>, <span class="string">"spark"</span>, <span class="string">"hadoop"</span>)</span><br><span class="line"><span class="keyword">val</span> result = words.flatMap(x =&gt; x.toUpperCase)</span><br><span class="line">println(result)  <span class="comment">//Set(A, L, P, C, H, K, R, O, D, S)</span></span><br></pre></td></tr></table></figure></div><p>flatMap示例二：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tuples: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">"Hello Scala"</span>, <span class="number">4</span>), (<span class="string">"Hello Spark"</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">val</span> strings: <span class="type">List</span>[<span class="type">String</span>] = tuples.map(t=&gt;&#123;(t._1+<span class="string">" "</span>)*t._2&#125;)</span><br><span class="line"><span class="comment">//List(Hello Scala Hello Scala Hello Scala Hello Scala , Hello Spark Hello Spark )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> flatMapList: <span class="type">List</span>[<span class="type">String</span>] = strings.flatMap(t=&gt;&#123;t.split(<span class="string">" "</span>)&#125;)</span><br><span class="line"><span class="comment">//List(Hello, Scala, Hello, Scala, Hello, Scala, Hello, Scala, Hello, Spark, Hello, Spark)</span></span><br></pre></td></tr></table></figure></div><p>flatMap示例三：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> linesList = <span class="type">List</span>((<span class="string">"Hello Scala"</span>, <span class="number">4</span>), (<span class="string">"Hello Spark"</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">val</span> flatMapList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = linesList.flatMap(t =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> line: <span class="type">String</span> = t._1</span><br><span class="line">    <span class="keyword">val</span> words = line.split(<span class="string">" "</span>)</span><br><span class="line">    words.map(w =&gt; (w, t._2))</span><br><span class="line">&#125;)</span><br><span class="line">println(flatMapList)  <span class="comment">//List((Hello,4), (Scala,4), (Hello,2), (Spark,2))</span></span><br></pre></td></tr></table></figure></div><p>根据上述三个原则即可算出函数结果。</p><h2 id="foldLeft"><a href="#foldLeft" class="headerlink" title="foldLeft"></a>foldLeft</h2><p>集合折叠函数，fold、foldRight底层都是基于foldLeft函数。</p><p>所以本文用到的函数可以不用严格区分，主要阐述其原理。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](z: <span class="type">A1</span>)(op: (<span class="type">A1</span>, <span class="type">A1</span>) =&gt; <span class="type">A1</span>): <span class="type">A1</span> = foldLeft(z)(op)</span><br></pre></td></tr></table></figure></div><p>就是将集合的数据和集合之外的数据进行聚合操作。</p><p>fold方法有函数柯里化，有2个参数列表</p><ul><li><p>第一个参数列表：集合之外的数据</p></li><li><p>第二个参数列表：表示计算规则</p></li></ul><p>fold示例一：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 集合折叠</span></span><br><span class="line">println(<span class="string">"fold =&gt; "</span> + list.fold(<span class="number">0</span>)(_+_))    <span class="comment">//10</span></span><br><span class="line"><span class="comment">// 集合折叠(左)</span></span><br><span class="line">println(<span class="string">"foldLeft =&gt; "</span> + list.foldLeft(<span class="number">0</span>)(_+_)) <span class="comment">//10</span></span><br></pre></td></tr></table></figure></div><p>  fold示例二：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala21_Collection_Method4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 将两个Map集合进行合并(merge)处理</span></span><br><span class="line">    <span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>(<span class="string">"a"</span> -&gt; <span class="number">1</span>, <span class="string">"b"</span> -&gt; <span class="number">2</span>, <span class="string">"c"</span> -&gt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> map2 = mutable.<span class="type">Map</span>(<span class="string">"a"</span> -&gt; <span class="number">4</span>, <span class="string">"d"</span> -&gt; <span class="number">5</span>, <span class="string">"c"</span> -&gt; <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// Map( "a"-&gt;5, "b"-&gt;2, "c"-&gt;9 ,"d"-&gt;5)</span></span><br><span class="line">    <span class="keyword">val</span> map3 = map2.foldLeft(map1)(</span><br><span class="line">      (map, kv) =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> k = kv._1</span><br><span class="line">        <span class="keyword">val</span> v = kv._2</span><br><span class="line">        <span class="comment">//map.update(k, map.getOrElse(k, 0) + v)</span></span><br><span class="line">        map(k) = map.getOrElse(k, <span class="number">0</span>) + v</span><br><span class="line">        map</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    println(map3) <span class="comment">//Map(b -&gt; 2, d -&gt; 5, a -&gt; 5, c -&gt; 9)</span></span><br><span class="line">    </span><br><span class="line">    println(map1) <span class="comment">//Map(b -&gt; 2, d -&gt; 5, a -&gt; 5, c -&gt; 9)</span></span><br><span class="line">    println(map2) <span class="comment">//Map(d -&gt; 5, a -&gt; 4, c -&gt; 6)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>原理示意图如下：</p><p><a href="https://pic.downk.cc/item/5e9f0b95c2a9a83be5c27ef7.png" data-fancybox="group" data-caption="folfLeft原理图" class="fancybox"><img alt="folfLeft原理图" title="folfLeft原理图" data-src="https://pic.downk.cc/item/5e9f0b95c2a9a83be5c27ef7.png" class="lazyload"></a></p><p><strong>总结：</strong></p><p><strong>其实，在foldleft函数中，第二个参数规定的就是，</strong></p><p><strong>foldleft第一个参数和foldleft调用者的第一个元素的运算规则</strong></p><p>可以用如下公式理解：</p><blockquote><p>a. foldLeft( b )( (b,a的第一个元素)=&gt;{} )</p></blockquote><p>（对应上面示意图：红色块为b，蓝色块为a）</p><p>只不过在此公式中b和a的第一个元素都是动态变化的：</p><p>​    b一直在迭代，a会继续往后顺序取后面的值。</p><p>​    <strong>其实函数最终返回值就是b的值（上面的例子map1和map3相等也能证明这一点，本质就是map1把值赋给了map3），且a不发生改变。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;scala中的flatMap和foldLeft函数&quot;&gt;&lt;a href=&quot;#scala中的flatMap和foldLeft函数&quot; class=&quot;headerlink&quot; title=&quot;scala中的flatMap和foldLeft函数&quot;&gt;&lt;/a&gt;scala中的flat
      
    
    </summary>
    
    
      <category term="大数据" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="scala" scheme="https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="scala" scheme="https://masteryang4.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>Java空指针问题的本质</title>
    <link href="https://masteryang4.github.io/2020/04/18/Java%E7%A9%BA%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <id>https://masteryang4.github.io/2020/04/18/Java%E7%A9%BA%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-04-18T15:58:28.000Z</published>
    <updated>2020-04-18T16:00:16.725Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="基础知识" scheme="https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
      <category term="面试" scheme="https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题：sleep和wait的区别</title>
    <link href="https://masteryang4.github.io/2020/04/14/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93/"/>
    <id>https://masteryang4.github.io/2020/04/14/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93/</id>
    <published>2020-04-14T08:01:30.000Z</published>
    <updated>2020-04-16T15:49:47.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中sleep和wait方法的区别"><a href="#Java中sleep和wait方法的区别" class="headerlink" title="Java中sleep和wait方法的区别"></a>Java中sleep和wait方法的区别</h1><p> sleep和wait都能使线程处于阻塞状态，但二者有着本质区别。 </p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread();</span><br><span class="line">        <span class="comment">//【本质区别】静态方法和成员方法</span></span><br><span class="line">        <span class="comment">//【静态方法】，绑定的是类。休眠的线程不是t1，是当前运行的main线程</span></span><br><span class="line">        <span class="comment">//和对象都没有关系，所以不存在什么对象锁</span></span><br><span class="line">        t1.sleep(<span class="number">1000</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【成员方法】，等待的线程就是t2</span></span><br><span class="line">        <span class="comment">//有同步/synchronized关键字才能拿到对象锁。</span></span><br><span class="line">        t2.wait();</span><br><span class="line">        t2.wait(<span class="number">1000</span>);<span class="comment">//wait也可以加等待时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//【扩展】scala中的伴生对象就是对静态语法的模拟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>【核心】静态方法、成员方法<ol><li>sleep是Thread类的静态方法。sleep的作用是让线程休眠道制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行。</li><li>wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会属将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者。 </li></ol></li><li>sleep方法没有释放锁（lock），而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 </li><li>【使用范围】<ol><li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，</li><li>而sleep可以在任何地方使用</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中sleep和wait方法的区别&quot;&gt;&lt;a href=&quot;#Java中sleep和wait方法的区别&quot; class=&quot;headerlink&quot; title=&quot;Java中sleep和wait方法的区别&quot;&gt;&lt;/a&gt;Java中sleep和wait方法的区别&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="多线程" scheme="https://masteryang4.github.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git使用小结</title>
    <link href="https://masteryang4.github.io/2020/04/13/Git%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://masteryang4.github.io/2020/04/13/Git%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</id>
    <published>2020-04-12T16:25:50.000Z</published>
    <updated>2020-04-16T15:52:46.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git使用小结"><a href="#Git使用小结" class="headerlink" title="Git使用小结"></a>Git使用小结</h1><p>小结Git常用指令，以及如何将本地代码同步/更新到Github的常用指令</p><h2 id="一、初始配置"><a href="#一、初始配置" class="headerlink" title="一、初始配置"></a>一、初始配置</h2><p>git安装完成后，需要设置一下，在命令行输入 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></div><p> <strong>–global</strong>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 </p><h2 id="二、常用指令"><a href="#二、常用指令" class="headerlink" title="二、常用指令"></a>二、常用指令</h2><p>进入到自己的项目文件下右键选择Git Bash Here打开git客户端 </p><p>初始化项目：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></div><p>将文件添加到本地仓库：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure></div><p>将文件提交到仓库</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;注释内容&quot;</span><br></pre></td></tr></table></figure></div><p>关联远程项目（你的远程仓库地址）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;xxx.git</span><br></pre></td></tr></table></figure></div><p>本地推送到远程（ <strong>第一次</strong>推送<strong>master分支</strong>的所有内容）</p><blockquote><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。 </p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></div><p>查看Git状态</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></div><h2 id="三、更新文件到Github"><a href="#三、更新文件到Github" class="headerlink" title="三、更新文件到Github"></a>三、更新文件到Github</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit -m &quot;注释内容&quot;</span><br><span class="line">git pull origin master   #从远程抓取分支，使用git pull，如果有冲突，要先处理冲突</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></div><p> 查看远程库信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></div><blockquote><p>会显示可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git使用小结&quot;&gt;&lt;a href=&quot;#Git使用小结&quot; class=&quot;headerlink&quot; title=&quot;Git使用小结&quot;&gt;&lt;/a&gt;Git使用小结&lt;/h1&gt;&lt;p&gt;小结Git常用指令，以及如何将本地代码同步/更新到Github的常用指令&lt;/p&gt;
&lt;h2 id=&quot;一
      
    
    </summary>
    
    
      <category term="Git&amp;Github" scheme="https://masteryang4.github.io/categories/Git-Github/"/>
    
    
      <category term="Git&amp;Github" scheme="https://masteryang4.github.io/tags/Git-Github/"/>
    
  </entry>
  
  <entry>
    <title>关于i=i++的分析与思考</title>
    <link href="https://masteryang4.github.io/2020/04/11/%E5%85%B3%E4%BA%8Ei-i-%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/"/>
    <id>https://masteryang4.github.io/2020/04/11/%E5%85%B3%E4%BA%8Ei-i-%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/</id>
    <published>2020-04-10T16:00:30.000Z</published>
    <updated>2020-04-18T15:22:45.874Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="基础知识" scheme="https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于HashMap的两道小面试题</title>
    <link href="https://masteryang4.github.io/2020/04/11/%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E4%B8%A4%E9%81%93%E5%B0%8F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://masteryang4.github.io/2020/04/11/%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E4%B8%A4%E9%81%93%E5%B0%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-10T16:00:16.000Z</published>
    <updated>2020-04-18T15:23:25.435Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="集合" scheme="https://masteryang4.github.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
      <category term="面试" scheme="https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>String_StringBuffer_StringBuilder分析总结</title>
    <link href="https://masteryang4.github.io/2020/04/11/String_StringBuffer_StringBuilder%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>https://masteryang4.github.io/2020/04/11/String_StringBuffer_StringBuilder%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-10T16:00:03.000Z</published>
    <updated>2020-04-24T15:48:19.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-StringBuffer-StringBuilder分析总结"><a href="#String-StringBuffer-StringBuilder分析总结" class="headerlink" title="String_StringBuffer_StringBuilder分析总结"></a>String_StringBuffer_StringBuilder分析总结</h1><p>本文对Java语言中的String，StringBuffer，StringBuilder类进行分析对比，</p><p>并String类型进行简单原理分析。</p><h2 id="String，StringBuffer，StringBuilder的区别"><a href="#String，StringBuffer，StringBuilder的区别" class="headerlink" title="String，StringBuffer，StringBuilder的区别"></a>String，StringBuffer，StringBuilder的区别</h2><p><strong>1、可变与不可变</strong></p><p>　　String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></div><p>　　StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure></div><p><strong>2、是否多线程安全</strong></p><p>　　String中的对象是不可变的，也就可以理解为常量，<strong>显然线程安全</strong>。</p><p>　　AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。</p><p>　　StringBuilder并没有对方法进行加同步锁，所以是<strong>非线程安全的</strong>。 </p><p>​        StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全的</strong>。看如下源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);        <span class="comment">//存在 public synchronized int indexOf(String str, int fromIndex) 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>3、StringBuilder与StringBuffer共同点</strong></p><p>　　StringBuilder与StringBuffer有公共父类AbstractStringBuilder(<strong>抽象类</strong>)。</p><p>　　抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。</p><p>　　StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(…)。只是StringBuffer会在方法上加synchronized关键字，进行同步。</p><p>　　如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。</p><h2 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h2><p>String类<strong>部分</strong>源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>说明：</p><ul><li>private final char value[];说明String不可变</li><li>其实不可变指的是其<strong>字符串内容</strong>不可变，<strong>字符串对象</strong>的地址其实是可以改变的，示例如下：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"ABCabc"</span>;</span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//a = ABCabc</span></span><br><span class="line">a = a.replace(<span class="string">'A'</span>, <span class="string">'a'</span>);</span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//a = aBCabc</span></span><br></pre></td></tr></table></figure></div><p>​        这个例子的本质是，字符串对象a指向了一个新的字符串数组。</p><ul><li>如果真的要去修改String内容的话，其实也是可以的，使用<strong>反射</strong>机制就可以实现，示例如下：</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>; </span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField("value");</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h2><blockquote><p><a href="https://www.cnblogs.com/leskang/p/6110631.html" target="_blank" rel="noopener">https://www.cnblogs.com/leskang/p/6110631.html</a> </p><p><a href="https://www.cnblogs.com/xudong-bupt/p/3961159.html" target="_blank" rel="noopener">https://www.cnblogs.com/xudong-bupt/p/3961159.html</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;String-StringBuffer-StringBuilder分析总结&quot;&gt;&lt;a href=&quot;#String-StringBuffer-StringBuilder分析总结&quot; class=&quot;headerlink&quot; title=&quot;String_StringBuffe
      
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="基础知识" scheme="https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中final关键字小结</title>
    <link href="https://masteryang4.github.io/2020/04/10/Java%E4%B8%ADfinal%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%8F%E7%BB%93/"/>
    <id>https://masteryang4.github.io/2020/04/10/Java%E4%B8%ADfinal%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%8F%E7%BB%93/</id>
    <published>2020-04-10T15:59:41.000Z</published>
    <updated>2020-04-16T15:44:18.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中final关键字小结"><a href="#Java中final关键字小结" class="headerlink" title="Java中final关键字小结"></a>Java中final关键字小结</h1><h2 id="一、final、finally、finalize的区别"><a href="#一、final、finally、finalize的区别" class="headerlink" title="一、final、finally、finalize的区别"></a>一、final、finally、finalize的区别</h2><p>final：</p><blockquote><p>修饰符（关键字）有三种用法：修饰类、变量和方法。</p><p>修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。</p><p>修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。（下一节代码示例）</p><p>修饰方法时，也同样只能使用，不能在子类中被重写。 </p></blockquote><p>finally:</p><blockquote><p>通常放在 try…catch 的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在finally块中。</p></blockquote><p>finalize：</p><blockquote><p>Object 类中定义的方法。</p><p>Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p><p>这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。</p></blockquote><h2 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zd_important_test_nbst</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserTest userTest = <span class="keyword">new</span> UserTest();</span><br><span class="line">        System.out.println(userTest.getA());</span><br><span class="line">        UserTest userTest1 = <span class="keyword">new</span> UserTest(<span class="number">6</span>);</span><br><span class="line">        System.out.println(userTest1.getA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * final修饰的变量，要么一开始就初始化（饿汉式），要么就在构造方法里初始化（懒汉式）。</span></span><br><span class="line"><span class="comment">     * 一旦初始化完成，就不能修改。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 【String中同样，使用private final修饰char[]】所以String是不可变的。</span></span><br><span class="line"><span class="comment">     * （通过反射可以破坏其不可变性）</span></span><br><span class="line"><span class="comment">     * 其他博客会提到上述内容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserTest</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//会报错，因为a是final</span></span><br><span class="line"><span class="comment">//    public void setA(int b) &#123;</span></span><br><span class="line"><span class="comment">//        this.a = b;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下为idea默认生成的hashcode和equals，可忽略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在Object的源码中，hashcode是native方法，使用c语言实现的，综合类的信息计算出的hashcode值</span></span><br><span class="line"><span class="comment">     * equals底层就是“==”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        UserTest userTest = (UserTest) o;</span><br><span class="line">        <span class="keyword">return</span> a == userTest.a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中final关键字小结&quot;&gt;&lt;a href=&quot;#Java中final关键字小结&quot; class=&quot;headerlink&quot; title=&quot;Java中final关键字小结&quot;&gt;&lt;/a&gt;Java中final关键字小结&lt;/h1&gt;&lt;h2 id=&quot;一、final、final
      
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="基础知识" scheme="https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java静态代码块的加载时机</title>
    <link href="https://masteryang4.github.io/2020/04/10/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/"/>
    <id>https://masteryang4.github.io/2020/04/10/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/</id>
    <published>2020-04-10T15:57:07.000Z</published>
    <updated>2020-04-18T15:22:19.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java静态代码块的加载时机"><a href="#Java静态代码块的加载时机" class="headerlink" title="Java静态代码块的加载时机"></a>Java静态代码块的加载时机</h2><p>在java中，静态代码块其实并不是随着类的加载而加载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java静态代码块的加载时机&quot;&gt;&lt;a href=&quot;#Java静态代码块的加载时机&quot; class=&quot;headerlink&quot; title=&quot;Java静态代码块的加载时机&quot;&gt;&lt;/a&gt;Java静态代码块的加载时机&lt;/h2&gt;&lt;p&gt;在java中，静态代码块其实并不是随着类的加
      
    
    </summary>
    
    
      <category term="Java" scheme="https://masteryang4.github.io/categories/Java/"/>
    
      <category term="基础知识" scheme="https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="易错点" scheme="https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"/>
    
      <category term="Java" scheme="https://masteryang4.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
