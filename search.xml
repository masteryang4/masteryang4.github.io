<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArrayList底层实现源码分析(JDK1.8)</title>
    <url>/2020/03/12/ArrayList%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_JDK1.8/</url>
    <content><![CDATA[<h2 id="1-类信息"><a href="#1-类信息" class="headerlink" title="1. 类信息"></a>1. 类信息</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2. 基本属性"></a>2. 基本属性</h2><a id="more"></a>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义序列化ID，主要是为了表示不同的版本的兼容性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的数组存储容量(ArrayList底层是数组结构)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当指定数组的容量为0时使用这个常量赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认空参构造函数时使用这个常量赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正存放数据的对象数组，transient标识不被序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组中的真实元素个数，该值小于或等于elementData.length</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大数组长度：0x7fffffff - 8</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器一：创建具有初始化长度的list</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对传入的值进行合法检测</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器二：默认空参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器三：创建具有初始化值的集合，可传入的集合类型父类是Collection即可，此处是多态的一个应用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将传入的集合转化为数组</span></span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="comment">//判断elementData数组长度</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// elementData转化的数组如果不是Object的子类，就对当前数组进行复制，重新赋值给elementData</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果数组长度为0，复制为EMPTY_ELEMENTDATA</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-add-E-e-方法"><a href="#3-add-E-e-方法" class="headerlink" title="3. add(E e) 方法"></a>3. add(E e) 方法</h2><p>ArrayList集合创建时，默认初始化长度为0，通过add( )方法在添加元素时对数组长度进行动态赋值。添加第一个元素时，长度为10。当添加的元素个数超过10时，会进行首次扩容，容量为原数组长度的1.5倍。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//此方法是添加元素的方法，另外还有一个重载方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用ensureCapacityInternal方法，初始化数组长度（默认为10）</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>); </span><br><span class="line">       <span class="comment">//为数组复制</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//初始化数组长度，默认值为10</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//判断如果数组长度为0，对长度进行初始化</span></span><br><span class="line">       <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           <span class="comment">//从默认数组长度（10）和添加的元素个数（添加第一个元素时size=0,minCapacity=size+1）中取出最大值</span></span><br><span class="line">           <span class="comment">//作为数组初始化长度</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//再次确定数组容量</span></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//再次确定数组容量</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//对数组元素个数进行统计</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//如果数组长度超过10，就对数组长度进行扩容</span></span><br><span class="line">       <span class="comment">//那第一次扩容举例：minCapacity值为11，DEFAULT_CAPACITY值为10</span></span><br><span class="line">       <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//对数组进行扩容，默认为老数组的1.5倍</span></span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//对数组进行扩容，默认为老数组的1.5倍</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//老数组容量：minCapacity</span></span><br><span class="line">       <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">       <span class="comment">//新数组容量：是老数组长度的1.5倍</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//对新数组容量进行合法检测</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           newCapacity = minCapacity;</span><br><span class="line">       <span class="comment">//MAX_ARRAY_SIZE：0x7fffffff - 8</span></span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//如果超过最大数组长度，再次进行扩容</span></span><br><span class="line">           newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">       <span class="comment">//对原数组进行复制</span></span><br><span class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">       <span class="comment">//三元运算符，如果超过最大数组长度返回Integer最大值：0x7fffffff</span></span><br><span class="line">       <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="4-add-int-idnex-E-element"><a href="#4-add-int-idnex-E-element" class="headerlink" title="4. add (int idnex,E element)"></a>4. add (int idnex,E element)</h2><p>从源码中可以看出，与add(E e)方法大致一致，主要的差异是增加了一行代码：System.arraycopy(elementData, index, elementData, index + 1, size - index)，从index位置开始以及之后的数据，整体拷贝到index+1开始的位置，然后再把新加入的数据放在index这个位置，而之前的数据不需要移动。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在指定位置添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断index是否在范围内</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">//与add(E e)方法一致，对数组长度进行初始化</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对原数组从index位置进行拷贝，复制到index+1的位置，elementData[index]此时为空</span></span><br><span class="line">    <span class="comment">//System.arraycopy是一个native方法，意味着这个方法是C/C++语言实现的，我们无法再以普通的方式去查看这些方法了</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    <span class="comment">//为该下标赋值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断index是否在范围内的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> arraycopy(elementData, index, elementData, index + 1, size - index)函数中各个参数对应的意义：（原数组，原数组的开始位置，目标数组，目标数组的开始位置，拷贝的个数）</p>
<h2 id="5-remove-int-index"><a href="#5-remove-int-index" class="headerlink" title="5. remove(int index)"></a>5. remove(int index)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//移除指定index下的元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//index是否合法检测</span></span><br><span class="line">       rangeCheck(index);</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">//指定index下的元素</span></span><br><span class="line">       E oldValue = elementData(index);</span><br><span class="line">       <span class="comment">//移除后数组长度</span></span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">       <span class="comment">//为最后一个元素赋值为null</span></span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回指定index下的元素</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//根据元素（对象）移除该元素</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">               <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//类似于remove()方法</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">           System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">       elementData[--size] = <span class="keyword">null</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>remove方法与add正好是一个相反的操作，移除一个元素，会影响到一批数字的位置移动，所以也是比较耗性能。核心代码都是调用了java.lang.System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)方法</p>
<h2 id="6-get-int-index"><a href="#6-get-int-index" class="headerlink" title="6. get(int index)"></a>6. get(int index)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据指定下标获取元素值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="7-set-int-index-E-element"><a href="#7-set-int-index-E-element" class="headerlink" title="7. set(int index, E element)"></a>7. set(int index, E element)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改指定index下的元素值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="8-clear"><a href="#8-clear" class="headerlink" title="8. clear()"></a>8. clear()</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="9-contains-Object-o"><a href="#9-contains-Object-o" class="headerlink" title="9. contains(Object o)"></a>9. contains(Object o)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的实现方法，如果不包含返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p>  基于数组实现的List在随机访问和遍历的效率比较高，但是往指定位置加入元素或者删除指定位置的元素效率比较低。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Comparable和Comparator底层源码分析</title>
    <url>/2020/03/15/Comparable%E5%92%8CComparator%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-Comparable源码分析"><a href="#1-Comparable源码分析" class="headerlink" title="1. Comparable源码分析"></a>1. Comparable源码分析</h1><h2 id="1-1创建Java工程，实现Comparable接口"><a href="#1-1创建Java工程，实现Comparable接口" class="headerlink" title="1.1创建Java工程，实现Comparable接口"></a>1.1创建Java工程，实现Comparable接口</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Serializable，标识该类可被序列化</span></span><br><span class="line"><span class="comment">//实现Comparable接口，让此类可以利用Collections.sort()进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span>,<span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String address;<span class="comment">//transient修饰，标识该类序列化时此字段不需要进行存储</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,<span class="keyword">int</span> age,String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在此处打上断点，方便进行调试</span></span><br><span class="line">        <span class="keyword">int</span> returnInt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(age&gt;o.getAge())&#123;</span><br><span class="line">            returnInt=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age==o.getAge())&#123;</span><br><span class="line">            returnInt=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(age&lt;o.getAge())&#123;</span><br><span class="line">            returnInt=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnInt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-2-编写测试类"><a href="#1-2-编写测试类" class="headerlink" title="1.2 编写测试类"></a>1.2 编写测试类</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="string">"caililiang1"</span>,<span class="number">20</span>,<span class="string">"hubei1"</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="string">"caililiang2"</span>,<span class="number">30</span>,<span class="string">"hubei2"</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="string">"caililiang3"</span>,<span class="number">25</span>,<span class="string">"hubei3"</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="string">"caililiang4"</span>,<span class="number">28</span>,<span class="string">"hubei4"</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="string">"caililiang5"</span>,<span class="number">23</span>,<span class="string">"hubei5"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        list.add(u1);</span><br><span class="line">        list.add(u2);</span><br><span class="line">        list.add(u3);</span><br><span class="line">        list.add(u4);</span><br><span class="line">        list.add(u5);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            User u =list.get(i);</span><br><span class="line">            System.out.println(u.getName()+<span class="string">"---&gt;"</span>+u.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"排序后---------------------"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在此处打上断点，方便进行调试</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            User u =list.get(i);</span><br><span class="line">            System.out.println(u.getName()+<span class="string">"---&gt;"</span>+u.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-3-Collections类中的泛型方法sort"><a href="#1-3-Collections类中的泛型方法sort" class="headerlink" title="1.3 Collections类中的泛型方法sort()"></a>1.3 Collections类中的泛型方法sort()</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处 &lt;T extends Comparable&lt;? super T&gt;&gt; 的意思是：</span></span><br><span class="line"><span class="comment">// 1.&lt;T extends Comparable&gt;表示比较对象的类必须是Comparable 的子类。</span></span><br><span class="line"><span class="comment">// 2.Comparable&lt;? super T&gt;表示是Comparable实现类及以上。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用List接口中的sort()方法</span></span><br><span class="line">       list.sort(<span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-4-List接口中的默认方法sort"><a href="#1-4-List接口中的默认方法sort" class="headerlink" title="1.4 List接口中的默认方法sort()"></a>1.4 List接口中的默认方法sort()</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于本例中采用的是ArrayList集合，ArrayList集合对List接口中的sort()方法进行了重写，</span></span><br><span class="line"><span class="comment">// 因此实际在DeBug的过程中会执行ArrayLIst类中的sort()方法    </span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">        Arrays.sort(a, (Comparator) c);</span><br><span class="line">        ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">            i.next();</span><br><span class="line">            i.set((E) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-5-ArrayList集合中的方法sort"><a href="#1-5-ArrayList集合中的方法sort" class="headerlink" title="1.5 ArrayList集合中的方法sort()"></a>1.5 ArrayList集合中的方法sort()</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    <span class="comment">//此方法直接调用Arrays类中sort()方法</span></span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-6-Arrays类中的sort-方法"><a href="#1-6-Arrays类中的sort-方法" class="headerlink" title="1.6 Arrays类中的sort()方法"></a>1.6 Arrays类中的sort()方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在1.3中传入的 c值为null,所以调用sort(a, fromIndex, toIndex)方法</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, fromIndex, toIndex, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        <span class="comment">//归并排序</span></span><br><span class="line">        legacyMergeSort(a, fromIndex, toIndex);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//二进制插入排序</span></span><br><span class="line">        ComparableTimSort.sort(a, fromIndex, toIndex, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>解析：源码里首先判断是否采用传统的排序方法,LegacyMergeSort.userRequested属性默认为false,也就是说默认选中 ComparableTimSort.sort(a)方法(传统归并排序在1.5及之前是默认排序方法，1.5之后默认执行ComparableTimSort.sort()方法。除非程序中强制要求使用传统归并排序,语句如下：System.setProperty(“java.util.Arrays.useLegacyMergeSort”, “true”))<br>继续看 ComparableTimSort.sort(a)源码</p>
<h2 id="1-7-ComparableTimSort类中的sort-方法"><a href="#1-7-ComparableTimSort类中的sort-方法" class="headerlink" title="1.7 ComparableTimSort类中的sort()方法"></a>1.7 ComparableTimSort类中的sort()方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Object[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//nRemaining表示没有排序的对象个数，方法执行前，如果这个数小于2，就不需要排序了。</span></span><br><span class="line">       <span class="comment">//如果2&lt;= nRemaining &lt;=32,即MIN_MERGE的初始值，表示需要排序的数组是小数组</span></span><br><span class="line">       <span class="comment">//可以使用mini-TimSort方法进行排序，否则需要使用归并排序。</span></span><br><span class="line">       <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">       <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">           <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line">       <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">           <span class="comment">//调用重写的compareTo()方法</span></span><br><span class="line">           <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi);</span><br><span class="line">           <span class="comment">//只看这一句</span></span><br><span class="line">           binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    ......</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里才是真正的调用compareTo()方法对当前对象进行比较</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">       <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">       <span class="keyword">if</span> (((Comparable) a[runHi++]).compareTo(a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// 降序排列</span></span><br><span class="line">           <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">               runHi++;</span><br><span class="line">           reverseRange(a, lo, runHi);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">// 升序排列</span></span><br><span class="line">           <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">               runHi++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> runHi - lo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里才是真正的进行排序。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(Object[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">       <span class="keyword">if</span> (start == lo)</span><br><span class="line">           start++;</span><br><span class="line">       <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">           Comparable pivot = (Comparable) a[start];</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">           <span class="keyword">int</span> left = lo;</span><br><span class="line">           <span class="keyword">int</span> right = start;</span><br><span class="line">           <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Invariants:</span></span><br><span class="line"><span class="comment">            *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">            *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">               <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (pivot.compareTo(a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                   right = mid;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">            * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">            * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">            * first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">            * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">           <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">           <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">           &#125;</span><br><span class="line">           a[left] = pivot;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="2-Comparator源码分析"><a href="#2-Comparator源码分析" class="headerlink" title="2. Comparator源码分析"></a>2. Comparator源码分析</h1><h2 id="2-1-创建JavaBean"><a href="#2-1-创建JavaBean" class="headerlink" title="2.1 创建JavaBean"></a>2.1 创建JavaBean</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String address;<span class="comment">//transient修饰，标识该类序列化时此字段不需要进行存储</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name,<span class="keyword">int</span> age,String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-2-创建外部比较器"><a href="#2-2-创建外部比较器" class="headerlink" title="2.2 创建外部比较器"></a>2.2 创建外部比较器</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleComparator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">People</span>&gt; <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> returnInt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(o1.getAge()&gt;o2.getAge())&#123;</span><br><span class="line">            returnInt = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.getAge()==o2.getAge())&#123;</span><br><span class="line">            returnInt = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.getAge()&lt;o2.getAge())&#123;</span><br><span class="line">            returnInt = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnInt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-3-创建测试类"><a href="#2-3-创建测试类" class="headerlink" title="2.3 创建测试类"></a>2.3 创建测试类</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        People u1 = <span class="keyword">new</span> People(<span class="string">"caililiang1"</span>,<span class="number">20</span>,<span class="string">"hubei1"</span>);</span><br><span class="line">        People u2 = <span class="keyword">new</span> People(<span class="string">"caililiang2"</span>,<span class="number">30</span>,<span class="string">"hubei2"</span>);</span><br><span class="line">        People u3 = <span class="keyword">new</span> People(<span class="string">"caililiang3"</span>,<span class="number">25</span>,<span class="string">"hubei3"</span>);</span><br><span class="line">        People u4 = <span class="keyword">new</span> People(<span class="string">"caililiang4"</span>,<span class="number">28</span>,<span class="string">"hubei4"</span>);</span><br><span class="line">        People u5 = <span class="keyword">new</span> People(<span class="string">"caililiang5"</span>,<span class="number">23</span>,<span class="string">"hubei5"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;People&gt; list = <span class="keyword">new</span> ArrayList&lt;People&gt;();</span><br><span class="line">        list.add(u1);</span><br><span class="line">        list.add(u2);</span><br><span class="line">        list.add(u3);</span><br><span class="line">        list.add(u4);</span><br><span class="line">        list.add(u5);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            People u =list.get(i);</span><br><span class="line">            System.out.println(u.getName()+<span class="string">"---&gt;"</span>+u.getAge());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"排序后---------------------"</span>);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> PeopleComparator());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            People u =list.get(i);</span><br><span class="line">            System.out.println(u.getName()+<span class="string">"---&gt;"</span>+u.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-4-Collections类中的泛型方法sort"><a href="#2-4-Collections类中的泛型方法sort" class="headerlink" title="2.4 Collections类中的泛型方法sort()"></a>2.4 Collections类中的泛型方法sort()</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line"><span class="comment">//此处调用的是sort方法的重载方法，与案例一中不同</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">       list.sort(c);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-5-ArrayList集合中的方法sort"><a href="#2-5-ArrayList集合中的方法sort" class="headerlink" title="2.5 ArrayList集合中的方法sort()"></a>2.5 ArrayList集合中的方法sort()</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-6-Arrays类中的sort-方法"><a href="#2-6-Arrays类中的sort-方法" class="headerlink" title="2.6 Arrays类中的sort()方法"></a>2.6 Arrays类中的sort()方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sort(a, fromIndex, toIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rangeCheck(a.length, fromIndex, toIndex);</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, fromIndex, toIndex, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//本次进入这里进行排序</span></span><br><span class="line">            TimSort.sort(a, fromIndex, toIndex, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-7-TimSort类下的sort-方法"><a href="#2-7-TimSort类下的sort-方法" class="headerlink" title="2.7 TimSort类下的sort()方法"></a>2.7 TimSort类下的sort()方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c, T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">    <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If array is small, do a "mini-TimSort" with no merges</span></span><br><span class="line">    <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">        <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">        binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> start, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> lo &lt;= start &amp;&amp; start &lt;= hi;</span><br><span class="line">    <span class="keyword">if</span> (start == lo)</span><br><span class="line">        start++;</span><br><span class="line">    <span class="keyword">for</span> ( ; start &lt; hi; start++) &#123;</span><br><span class="line">        T pivot = a[start];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set left (and right) to the index where a[start] (pivot) belongs</span></span><br><span class="line">        <span class="keyword">int</span> left = lo;</span><br><span class="line">        <span class="keyword">int</span> right = start;</span><br><span class="line">        <span class="keyword">assert</span> left &lt;= right;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invariants:</span></span><br><span class="line"><span class="comment">         *   pivot &gt;= all in [lo, left).</span></span><br><span class="line"><span class="comment">         *   pivot &lt;  all in [right, start).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c.compare(pivot, a[mid]) &lt; <span class="number">0</span>)</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> left == right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The invariants still hold: pivot &gt;= all in [lo, left) and</span></span><br><span class="line"><span class="comment">         * pivot &lt; all in [left, start), so pivot belongs at left.  Note</span></span><br><span class="line"><span class="comment">         * that if there are elements equal to pivot, left points to the</span></span><br><span class="line"><span class="comment">         * first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">         * Slide elements over to make room for pivot.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n = start - left;  <span class="comment">// The number of elements to move</span></span><br><span class="line">        <span class="comment">// Switch is just an optimization for arraycopy in default case</span></span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:  a[left + <span class="number">2</span>] = a[left + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  a[left + <span class="number">1</span>] = a[left];</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: System.arraycopy(a, left, a, left + <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ol>
<li><p>Comparable 此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的<em>自然排序</em>，类的<strong>compareTo()</strong>方法被称为它的<em>自然比较方法</em>。  实现此接口的对象列表（集合和数组）可以通过 Collections.sort和 Arrays.sort 进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p>Arrays.sort(people)</p>
</li>
<li><p>Comparator 是比较器，排序时，需要新建比较器对象，将比较器和对象一起传递过去就可以比大小，可称为“<em>外部排序</em>”。比较器是定义在要比较对象的外部的, 必须要重写<strong>compare()</strong>方法，而需要比较的类的结构不需要有任何变化。并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。</p>
<p>Arrays.sort(people,new PersonCompartor());</p>
</li>
<li><p>关于两个类的具体应用场景可以理解为，自己在创建一个工程时可以使用Comparable进行排序，当工程创建完毕时添加新的排序功能时，可以使用Comparator，无需改变类的结构。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git使用小结</title>
    <url>/2020/04/13/Git%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Git使用小结"><a href="#Git使用小结" class="headerlink" title="Git使用小结"></a>Git使用小结</h1><p>小结Git常用指令，以及如何将本地代码同步/更新到Github的常用指令</p>
<h2 id="一、初始配置"><a href="#一、初始配置" class="headerlink" title="一、初始配置"></a>一、初始配置</h2><p>git安装完成后，需要设置一下，在命令行输入 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></div>

<p> <strong>–global</strong>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 </p>
<h2 id="二、常用指令"><a href="#二、常用指令" class="headerlink" title="二、常用指令"></a>二、常用指令</h2><p>进入到自己的项目文件下右键选择Git Bash Here打开git客户端 </p>
<p>初始化项目：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></div>

<p>将文件添加到本地仓库：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure></div>

<p>将文件提交到仓库</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;注释内容&quot;</span><br></pre></td></tr></table></figure></div>

<p>关联远程项目（你的远程仓库地址）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;xxx.git</span><br></pre></td></tr></table></figure></div>

<p>本地推送到远程（ <strong>第一次</strong>推送<strong>master分支</strong>的所有内容）</p>
<blockquote>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。 </p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></div>

<p>查看Git状态</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></div>

<h2 id="三、更新文件到Github"><a href="#三、更新文件到Github" class="headerlink" title="三、更新文件到Github"></a>三、更新文件到Github</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit -m &quot;注释内容&quot;</span><br><span class="line">git pull origin master   #从远程抓取分支，使用git pull，如果有冲突，要先处理冲突</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></div>

<p> 查看远程库信息：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>会显示可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。 </p>
</blockquote>
]]></content>
      <categories>
        <category>Git&amp;Github</category>
      </categories>
      <tags>
        <tag>Git&amp;Github</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap底层实现源码分析</title>
    <url>/2020/03/16/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="HashMap底层实现原理"><a href="#HashMap底层实现原理" class="headerlink" title="HashMap底层实现原理"></a>HashMap底层实现原理</h1><h2 id="0-样例数据"><a href="#0-样例数据" class="headerlink" title="0.样例数据"></a>0.样例数据</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//唯一的工作初始化负债因子（this.loadFactor = DEFAULT_LOAD_FACTOR）为0.75f</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//添加kv</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">65</span>; i &lt; <span class="number">91</span>; i++) &#123;</span><br><span class="line">            map.put(String.valueOf(i),count);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种遍历方式</span></span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        Iterator&lt;String&gt; iterator = keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            String key = iterator.next();</span><br><span class="line">            System.out.println(key+ <span class="string">" =&gt; "</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"******************************"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种遍历方式</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iteratorMap = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iteratorMap.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Integer&gt; mapEntry = iteratorMap.next();</span><br><span class="line">            System.out.println(mapEntry);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"******************************"</span>);</span><br><span class="line">        <span class="comment">//第三种遍历方式</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">" =&gt; "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="1-类信息"><a href="#1-类信息" class="headerlink" title="1. 类信息"></a>1. 类信息</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></div>

<h2 id="2-基本属性"><a href="#2-基本属性" class="headerlink" title="2. 基本属性"></a>2. 基本属性</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>; <span class="comment">//序列化版本号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认容量16(左移4位相当于乘以2的4次方)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;<span class="comment">//最大容量（1073741824）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;<span class="comment">//默认负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">//链表节点转换红黑树节点的阈值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">//红黑树节点转换链表节点的阈值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;<span class="comment">// 转红黑树时, table的最小长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本hash节点, 继承自Entry，此时的Node节点就是相当于Entry节点的实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//hashMap数组的表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">//entry节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">//添加的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">//合理的初始化数组长度，根据tableSizeFor()得到，用于手动设置时使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">//负载因子，用于手动设置时使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器一：定义Node[]数组初始长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">    <span class="comment">//为Node[]数组设置负债因子</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//为Node[]数组设置一个合理的值</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化Node[]数组长度，根据传入的值以2的n次方对数组进行扩容</span></span><br><span class="line"><span class="comment">//（例如：存入传入值为9，数组容量为16，在(8,16]范围内将不会再次扩容）。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= <span class="number">1</span> &lt;&lt; <span class="number">30</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">30</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器二：调用HashMap(int initialCapacity, float loadFactor)构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造器三：仅创建HashMap对象，并初始化负债因子为0.75f</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="3-hash算法"><a href="#3-hash算法" class="headerlink" title="3. hash算法"></a>3. hash算法</h2><p>HashMap定位数组索引位置，直接决定了hash方法的离散性能。下面是定位哈希桶数组的源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算key的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">// 1.先拿到key的hashCode值,基本数据类型会使用其包装类重载的hashCode()方法去计算hash值，引用数据类型根据是否重写去计算 </span></span><br><span class="line">        <span class="comment">// 2.将hashCode的高16位参与运算</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将(tab.length - 1) 与 hash值进行&amp;运算</span></span><br><span class="line">    <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对值进行Hash计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = valu</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 当KEY值为A测试数据，A的hash为: 31 * hash + ANSI码值65</span></span><br><span class="line"><span class="comment">        * 当KEY值为AB测试数据，AB的hash为：31 * 65 + 66</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>HashMap底层数组的长度总是2的n次方，并且取模运算为“h mod table.length”，对应上面的公式，可以得到该运算等同于“h &amp; (table.length - 1)”。这是HashMap在速度上的优化，因为&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，还优化了高位运算的算法，将hashCode的高16位与hashCode进行异或运算，主要是为了在table的length较小的时候，让高位也参与运算，并且不会有太大的开销。</p>
<h2 id="4-get方法"><a href="#4-get方法" class="headerlink" title="4. get方法"></a>4. get方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用的GET方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际执行的GET方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">	Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// table不为空 &amp;&amp; table长度大于0 &amp;&amp; table索引位置(根据hash值计算出)节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// first的key等于传入的key则返回first对象</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//first的key不等于传入的key则说明是链表，向下遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否为TreeNode，是则为红黑树</span></span><br><span class="line">            <span class="comment">// 如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//走下列步骤表示是链表，循环至节点的key与传入的key值相等</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到符合的返回空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="5-put方法"><a href="#5-put方法" class="headerlink" title="5. put方法"></a>5. put方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//掉用的PUT方法，hash(key)调用本例中的hash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//实际执行的PUT方法 </span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// table是否为空或者length等于0, 如果是则调用resize方法进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 通过hash值计算索引位置, 如果table表该索引位置节点为空则新增一个</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">// 将索引位置的头节点赋值给p</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// table表该索引位置不为空</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断p节点的hash值和key值是否跟传入的hash值和key值相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">// 如果相等, 则p节点即为要查找的目标节点，赋值给e</span></span><br><span class="line">        <span class="comment">// 判断p节点是否为TreeNode, 如果是则调用红黑树的putTreeVal方法查找目标节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 走到这代表p节点为普通链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历此链表, binCount用于统计节点数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//p.next为空代表目标节点不存在</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//新增一个节点插入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果节点数目超过8个，调用treeifyBin方法将该链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//e节点的hash值和key值都与传入的相等, 则e即为目标节点,跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e不为空则代表根据传入的hash值和key值查找到了节点,将该节点的value覆盖,返回oldValue</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 用于LinkedHashMap</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map修改次数加1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//map节点数加1，如果超过阀值，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">// 用于LinkedHashMap</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从上面的源码分析可以看出</p>
<p>1、如果节点已经存在，则更新原值</p>
<p>2、如果节点不存在，则插入数组中，如果数组已经有值，则判断是非是红黑树，如果是，则调用红黑树方法插入</p>
<p>3、如果插入的是链表，插入尾部，然后判断节点数是否超过8，如果超过，则转换为红黑树</p>
<p>4、先插入的数据，后面判断是否超过阀值再进行的扩容</p>
<p>putTreeVal,插入红黑树方法就不看了，看下treeifyBin方法，该方法是将链表转化为红黑树,</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; </span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// table为空或者table的长度小于64, 进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) </span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 根据hash值计算索引值, 遍历该索引位置的链表</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;   </span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>); <span class="comment">// 链表节点转红黑树节点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)    <span class="comment">// tl为空代表为第一次循环</span></span><br><span class="line">                hd = p; <span class="comment">// 头结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;    <span class="comment">// 当前节点的prev属性设为上一个节点</span></span><br><span class="line">                tl.next = p;    <span class="comment">// 上一个节点的next属性设置为当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            tl = p; <span class="comment">// tl赋值为p, 在下一次循环中作为上一个节点</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);    <span class="comment">// e指向下一个节点</span></span><br><span class="line">        <span class="comment">// 将table该索引位置赋值为新转的TreeNode的头节点</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>) </span><br><span class="line">            hd.treeify(tab);    <span class="comment">// 以头结点为根结点, 构建红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到，会先判断tab的节点数是否超过64，如果没超过，则进行扩容，如果超过了才会转换为红黑树</p>
<p>可以得到两个结论</p>
<p>1、什么时候转换为红黑树</p>
<p>当链表数目超过8,并且map节点数量超过64，才会转换为红黑树</p>
<p>2、什么时候扩容（前提是map数目没有超过最大容量值  1&lt;&lt;30 ）</p>
<p>新增节点时，发生了碰撞，并且节点数目超过阀值</p>
<p>新增节点时，发生了碰撞，节点数量木有超过阀值，但是链表数目&gt;8,map节点&lt;64时</p>
<p>再看下resize()方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">//oldTab保存未扩容的tab</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">//oldTab最大容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//oldTab阀值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果老map有值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 老table的容量超过最大容量值，设置阈值为Integer.MAX_VALUE，返回老表</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            <span class="comment">//老table的容量没有超过最大容量值，将新容量赋值为老容量*2，如果新容量&lt;最大容量并且老容量&gt;=16, 则将新阈值设置为原来的两倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值</span></span><br><span class="line">            newCap = oldThr;    <span class="comment">// 则将新表的容量设置为老表的阈值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;   <span class="comment">//老表的容量为0, 老表的阈值为0, 则为空表，设置默认容量和阈值</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果新阈值为空, 则通过新的容量*负载因子获得新阈值</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前阈值赋值为刚计算出来的新的阈值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;  <span class="comment">// 将当前的表赋值为新定义的表</span></span><br><span class="line">        <span class="comment">// 如果老表不为空, 则需遍历将节点赋值给新表</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// 将索引值为j的老表头节点赋值给e</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>; <span class="comment">//将老表的节点设置为空, 以便垃圾收集器回收空间</span></span><br><span class="line">                    <span class="comment">// 如果e.next为空, 则代表老表的该位置只有1个节点,</span></span><br><span class="line">                    <span class="comment">// 通过hash值计算新表的索引位置, 直接将该节点放在该位置</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">//</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//e.next不为空,判断是否是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//是普通链表</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为:</span></span><br><span class="line">                            <span class="comment">//	老表的索引位置＋oldCap</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>; <span class="comment">// 最后一个节点的next设为空</span></span><br><span class="line">                            newTab[j] = loHead; <span class="comment">// 将原索引位置的节点设置为对应的头结点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>; <span class="comment">// 最后一个节点的next设为空</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead; <span class="comment">// 将索引位置为原索引+oldCap的节点设置为对应的头结点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看出，扩容时，节点重hash只分布在原索引位置与原索引+oldCap位置，为什么呢</p>
<p>假设老表的容量为16，即oldCap=16，则新表容量为16*2=32，假设节点1的hash值为0000 0000 0000 0000 0000 1111 0000 1010，节点2的hash值为0000 0000 0000 0000 0000 1111 0001 1010，则节点1和节点2在老表的索引位置计算如下图计算1，由于老表的长度限制，节点1和节点2的索引位置只取决于节点hash值的最后4位。再看计算2，计算2为新表的索引计算，可以知道如果两个节点在老表的索引位置相同，则新表的索引位置只取决于节点hash值倒数第5位的值，而此位置的值刚好为老表的容量值16，此时节点在新表的索引位置只有两种情况：原索引位置和原索引+oldCap位置（在此例中即为10和10+16=26）。由于结果只取决于节点hash值的倒数第5位，而此位置的值刚好为老表的容量值16，因此此时新表的索引位置的计算可以替换为计算3，直接使用节点的hash值与老表的容量16进行位于运算，如果结果为0则该节点在新表的索引位置为原索引位置，否则该节点在新表的索引位置为原索引+oldCap位置。</p>
<h2 id="6-remove-方法"><a href="#6-remove-方法" class="headerlink" title="6. remove()方法"></a>6. remove()方法</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 如果table不为空并且根据hash值计算出来的索引位置不为空, 将该位置的节点赋值给p</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果p的hash值和key都与入参的相同, 则p即为目标节点, 赋值给node</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;    <span class="comment">// 否则向下遍历节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  <span class="comment">// 如果p是TreeNode则调用红黑树的方法查找节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;    <span class="comment">// 遍历链表查找符合条件的节点</span></span><br><span class="line">                    <span class="comment">// 当节点的hash值和key与传入的相同,则该节点即为目标节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;    <span class="comment">// 赋值给node, 并跳出循环</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;  <span class="comment">// p节点赋值为本次结束的e</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">// 指向像一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果node不为空(即根据传入key和hash值查找到目标节点)，则进行移除操作</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123; </span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)   <span class="comment">// 如果是TreeNode则调用红黑树的移除方法</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">// 走到这代表节点是普通链表节点</span></span><br><span class="line">            <span class="comment">// 如果node是该索引位置的头结点则直接将该索引位置的值赋值为node的next节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">// 否则将node的上一个节点的next属性设置为node的next节点, </span></span><br><span class="line">            <span class="comment">// 即将node节点移除, 将node的上下节点进行关联(链表的移除)    </span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount; <span class="comment">// 修改次数+1</span></span><br><span class="line">            --size; <span class="comment">// table的总节点数-1</span></span><br><span class="line">            afterNodeRemoval(node); <span class="comment">// 供LinkedHashMap使用</span></span><br><span class="line">            <span class="keyword">return</span> node;    <span class="comment">// 返回被移除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="7-JDK1-7和1-8的区别"><a href="#7-JDK1-7和1-8的区别" class="headerlink" title="7. JDK1.7和1.8的区别"></a>7. JDK1.7和1.8的区别</h2><p>1、JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率）</p>
<p>2、JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</p>
<p>3、扩容后数据存储位置的计算方式也不一样：1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1），而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。</p>
<p>4、jdk1.7 先扩容再put ，jdk1.8 先put再扩容</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客安装及部署</title>
    <url>/2020/03/12/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h1><blockquote>
<p>node -v #查看node版本<br>npm -v #查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">http://registry.npm.taobao.org</a> #安装淘宝的cnpm 管理器<br>cnpm -v #查看cnpm版本</p>
</blockquote>
<h1 id="hexo安装及配置"><a href="#hexo安装及配置" class="headerlink" title="hexo安装及配置"></a>hexo安装及配置</h1><blockquote>
<p>hexo -v #查看hexo版本<br>mkdir blog #创建blog目录<br>cd blog #进入blog目录<br>sudo hexo init #生成博客 初始化博客</p>
<p>hexo s #启动本地博客服务<br><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> #本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章</p>
</blockquote>
<p>在blog目录下</p>
<a id="more"></a>
<blockquote>
<p>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p>
</blockquote>
<p>配置_config.yml</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repo:</span> <span class="string">https://github.com/YourGithubName/YourGithubName.github.io.git</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div>

<p>部署到Github仓库里</p>
<blockquote>
<p>hexo d</p>
<p><a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> #访问这个地址可以查看博客</p>
</blockquote>
<h2 id="yilia主题配置"><a href="#yilia主题配置" class="headerlink" title="yilia主题配置"></a>yilia主题配置</h2><ul>
<li>下载yilia主题到本地<ul>
<li>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</li>
</ul>
</li>
<li>修改hexo根目录下的 _config.yml 文件 </li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">yml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">yilia</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>部署到github<ul>
<li>hexo clean #清理一下</li>
<li>hexo g #生成</li>
<li>hexo d #部署到远程Github仓库</li>
</ul>
</li>
<li>查看博客 ：  <a href="https://YourGithubName.github.io/" target="_blank" rel="noopener">https://YourGithubName.github.io/</a> </li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO相关总结归纳</title>
    <url>/2020/04/29/Java-IO%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中final关键字小结</title>
    <url>/2020/04/10/Java%E4%B8%ADfinal%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Java中final关键字小结"><a href="#Java中final关键字小结" class="headerlink" title="Java中final关键字小结"></a>Java中final关键字小结</h1><h2 id="一、final、finally、finalize的区别"><a href="#一、final、finally、finalize的区别" class="headerlink" title="一、final、finally、finalize的区别"></a>一、final、finally、finalize的区别</h2><p>final：</p>
<blockquote>
<p>修饰符（关键字）有三种用法：修饰类、变量和方法。</p>
<p>修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。</p>
<p>修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。（下一节代码示例）</p>
<p>修饰方法时，也同样只能使用，不能在子类中被重写。 </p>
</blockquote>
<p>finally:</p>
<blockquote>
<p>通常放在 try…catch 的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在finally块中。</p>
</blockquote>
<p>finalize：</p>
<blockquote>
<p>Object 类中定义的方法。</p>
<p>Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p>
<p>这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。</p>
</blockquote>
<h2 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zd_important_test_nbst</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserTest userTest = <span class="keyword">new</span> UserTest();</span><br><span class="line">        System.out.println(userTest.getA());</span><br><span class="line">        UserTest userTest1 = <span class="keyword">new</span> UserTest(<span class="number">6</span>);</span><br><span class="line">        System.out.println(userTest1.getA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * final修饰的变量，要么一开始就初始化（饿汉式），要么就在构造方法里初始化（懒汉式）。</span></span><br><span class="line"><span class="comment">     * 一旦初始化完成，就不能修改。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 【String中同样，使用private final修饰char[]】所以String是不可变的。</span></span><br><span class="line"><span class="comment">     * （通过反射可以破坏其不可变性）</span></span><br><span class="line"><span class="comment">     * 其他博客会提到上述内容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserTest</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//会报错，因为a是final</span></span><br><span class="line"><span class="comment">//    public void setA(int b) &#123;</span></span><br><span class="line"><span class="comment">//        this.a = b;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下为idea默认生成的hashcode和equals，可忽略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在Object的源码中，hashcode是native方法，使用c语言实现的，综合类的信息计算出的hashcode值</span></span><br><span class="line"><span class="comment">     * equals底层就是“==”</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        UserTest userTest = (UserTest) o;</span><br><span class="line">        <span class="keyword">return</span> a == userTest.a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java空指针问题的本质</title>
    <url>/2020/04/18/Java%E7%A9%BA%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java静态代码块的加载时机</title>
    <url>/2020/04/10/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="Java静态代码块的加载时机"><a href="#Java静态代码块的加载时机" class="headerlink" title="Java静态代码块的加载时机"></a>Java静态代码块的加载时机</h2><p>在java中，静态代码块其实并不是随着类的加载而加载。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode经典10道题</title>
    <url>/2020/03/22/LeetCode%E7%BB%8F%E5%85%B810%E9%81%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="LeetCode题目精选"><a href="#LeetCode题目精选" class="headerlink" title="LeetCode题目精选"></a>LeetCode题目精选</h1><ol>
<li>两数之和</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></div>

<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; map.get(complement), i &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>爬楼梯</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure></div>

<p>示例 2：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></div>

<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>翻转二叉树</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>
<p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure></div>

<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode right = invertTree(root.right);</span><br><span class="line">    TreeNode left = invertTree(root.left);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>反转链表</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
<p>反转一个单链表。</p>
<p>示例:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure></div>

<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextTemp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>LRU缓存机制</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache/</a></p>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></figure></div>

<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LRUCache 对象会以如下语句构造和调用:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li>最长回文子串</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure></div>

<p>示例 2：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></div>

<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="7">
<li>有效的括号</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses/</a></p>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：<br>    1. 左括号必须用相同类型的右括号闭合。<br>    2. 左括号必须以正确的顺序闭合。</p>
<p>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></div>

<p>示例 2:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></div>

<p>示例 3:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></div>

<p>示例 4:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></div>

<p>示例 5:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></div>

<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Hash table that takes care of the mappings.</span></span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;Character, Character&gt; mappings;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize hash map with mappings. This simply makes the code easier to read.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mappings = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">    <span class="keyword">this</span>.mappings.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">    <span class="keyword">this</span>.mappings.put(<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>);</span><br><span class="line">    <span class="keyword">this</span>.mappings.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize a stack to be used in the algorithm.</span></span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the current character is a closing bracket.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.mappings.containsKey(c)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the top element of the stack. If the stack is empty, set a dummy value of '#'</span></span><br><span class="line">        <span class="keyword">char</span> topElement = stack.empty() ? <span class="string">'#'</span> : stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the mapping for this bracket doesn't match the stack's top element, return false.</span></span><br><span class="line">        <span class="keyword">if</span> (topElement != <span class="keyword">this</span>.mappings.get(c)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If it was an opening bracket, push to the stack.</span></span><br><span class="line">        stack.push(c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the stack still contains elements, then it is an invalid expression.</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="8">
<li>数组中的第K个最大元素</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure></div>

<p>示例 2:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></div>

<p>说明:</p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> [] nums;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="keyword">this</span>.nums[a];</span><br><span class="line">    <span class="keyword">this</span>.nums[a] = <span class="keyword">this</span>.nums[b];</span><br><span class="line">    <span class="keyword">this</span>.nums[b] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pivot_index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="keyword">this</span>.nums[pivot_index];</span><br><span class="line">    <span class="comment">// 1. move pivot to end</span></span><br><span class="line">    swap(pivot_index, right);</span><br><span class="line">    <span class="keyword">int</span> store_index = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. move all smaller elements to the left</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.nums[i] &lt; pivot) &#123;</span><br><span class="line">        swap(store_index, i);</span><br><span class="line">        store_index++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. move pivot to its final place</span></span><br><span class="line">    swap(store_index, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> store_index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k_smallest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Returns the k-th smallest element of list within left..right.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="comment">// If the list contains only one element,</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.nums[left];  <span class="comment">// return that element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// select a random pivot_index</span></span><br><span class="line">    Random random_num = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> pivot_index = left + random_num.nextInt(right - left); </span><br><span class="line">    </span><br><span class="line">    pivot_index = partition(left, right, pivot_index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the pivot is on (N - k)th smallest position</span></span><br><span class="line">    <span class="keyword">if</span> (k_smallest == pivot_index)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.nums[k_smallest];</span><br><span class="line">    <span class="comment">// go left side</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k_smallest &lt; pivot_index)</span><br><span class="line">      <span class="keyword">return</span> quickselect(left, pivot_index - <span class="number">1</span>, k_smallest);</span><br><span class="line">    <span class="comment">// go right side</span></span><br><span class="line">    <span class="keyword">return</span> quickselect(pivot_index + <span class="number">1</span>, right, k_smallest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.nums = nums;</span><br><span class="line">    <span class="keyword">int</span> size = nums.length;</span><br><span class="line">    <span class="comment">// kth largest is (N - k)th smallest</span></span><br><span class="line">    <span class="keyword">return</span> quickselect(<span class="number">0</span>, size - <span class="number">1</span>, size - k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="9">
<li>实现 Trie (前缀树)</li>
</ol>
<p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trie trie &#x3D; new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     &#x2F;&#x2F; 返回 true</span><br></pre></td></tr></table></figure></div>

<p>说明:</p>
<ul>
<li>你可以假设所有的输入都是由小写字母 a-z 构成的。</li>
<li>保证所有输入均为非空字符串。</li>
</ul>
<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> currentChar = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(currentChar)) &#123;</span><br><span class="line">                node.put(currentChar, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(currentChar);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search a prefix or whole key in trie and</span></span><br><span class="line">    <span class="comment">// returns the node where search ends</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> curLetter = word.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (node.containsKey(curLetter)) &#123;</span><br><span class="line">               node = node.get(curLetter);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">       TrieNode node = searchPrefix(word);</span><br><span class="line">       <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="10">
<li>编辑距离</li>
</ol>
<p>链接：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a></p>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：<br>    1. 插入一个字符<br>    2. 删除一个字符<br>    3. 替换一个字符</p>
<p>示例 1:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure></div>

<p>示例 2:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure></div>

<p>题解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = word1.length();</span><br><span class="line">    <span class="keyword">int</span> m = word2.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if one of the strings is empty</span></span><br><span class="line">    <span class="keyword">if</span> (n * m == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> n + m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// array to store the convertion history</span></span><br><span class="line">    <span class="keyword">int</span> [][] d = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init boundaries</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      d[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">      d[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DP compute </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = d[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> down = d[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left_down = d[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) != word2.charAt(j - <span class="number">1</span>))</span><br><span class="line">          left_down += <span class="number">1</span>;</span><br><span class="line">        d[i][j] = Math.min(left, Math.min(down, left_down));</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n][m];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL的执行顺序问题</title>
    <url>/2020/04/10/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="SQL的执行顺序问题"><a href="#SQL的执行顺序问题" class="headerlink" title="SQL的执行顺序问题"></a>SQL的执行顺序问题</h2><p>众所周知，sql的执行顺序：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">from... where...group by... having....select ... <span class="keyword">order</span> by... <span class="keyword">limit</span></span><br></pre></td></tr></table></figure></div>

<p>但是，有一个“bug”，在 <strong>MySQL</strong> 中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, <span class="keyword">COUNT</span>(title) <span class="keyword">AS</span> t <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> title <span class="keyword">HAVING</span> t &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<p>这样的语句是可以执行的。</p>
<p>正常来说，having在select之前执行，但是却可以使用select的别名，这是为什么呢？</p>
<p>查阅了一切资料，做出如下解释：</p>
<h4 id="解释一"><a href="#解释一" class="headerlink" title="解释一"></a>解释一</h4><blockquote>
<p>mysql的处理方式是中间生成虚拟表（或者叫临时表），而这个虚拟表的生成的列靠的就是select。</p>
<p>所以猜测类似having之后的操作，其实内部已经根据select生成了虚拟表，列自然也是as后的。</p>
</blockquote>
<h4 id="解释二"><a href="#解释二" class="headerlink" title="解释二"></a>解释二</h4><blockquote>
<p>之所以MYSQL可以这么做是因为MYSQL用的是临时表，</p>
<p>在having前已经产生了数据，所以可以用别名，但SQL Sever不可以，SQL是在having后才Select。</p>
</blockquote>
]]></content>
      <categories>
        <category>SQL</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>String_StringBuffer_StringBuilder分析总结</title>
    <url>/2020/04/11/String_StringBuffer_StringBuilder%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="String-StringBuffer-StringBuilder分析总结"><a href="#String-StringBuffer-StringBuilder分析总结" class="headerlink" title="String_StringBuffer_StringBuilder分析总结"></a>String_StringBuffer_StringBuilder分析总结</h1><p>本文对Java语言中的String，StringBuffer，StringBuilder类进行分析对比，</p>
<p>并String类型进行简单原理分析。</p>
<h2 id="String，StringBuffer，StringBuilder的区别"><a href="#String，StringBuffer，StringBuilder的区别" class="headerlink" title="String，StringBuffer，StringBuilder的区别"></a>String，StringBuffer，StringBuilder的区别</h2><p><strong>1、可变与不可变</strong></p>
<p>　　String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure></div>

<p>　　StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure></div>

<p><strong>2、是否多线程安全</strong></p>
<p>　　String中的对象是不可变的，也就可以理解为常量，<strong>显然线程安全</strong>。</p>
<p>　　AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。</p>
<p>　　StringBuilder并没有对方法进行加同步锁，所以是<strong>非线程安全的</strong>。 </p>
<p>​        StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全的</strong>。看如下源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.reverse();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(str, <span class="number">0</span>);        <span class="comment">//存在 public synchronized int indexOf(String str, int fromIndex) 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3、StringBuilder与StringBuffer共同点</strong></p>
<p>　　StringBuilder与StringBuffer有公共父类AbstractStringBuilder(<strong>抽象类</strong>)。</p>
<p>　　抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。</p>
<p>　　StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(…)。只是StringBuffer会在方法上加synchronized关键字，进行同步。</p>
<p>　　如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。</p>
<h2 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h2><p>String类<strong>部分</strong>源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>说明：</p>
<ul>
<li>private final char value[];说明String不可变</li>
<li>其实不可变指的是其<strong>字符串内容</strong>不可变，<strong>字符串对象</strong>的地址其实是可以改变的，示例如下：</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"ABCabc"</span>;</span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//a = ABCabc</span></span><br><span class="line">a = a.replace(<span class="string">'A'</span>, <span class="string">'a'</span>);</span><br><span class="line">System.out.println(<span class="string">"a = "</span> + a);  <span class="comment">//a = aBCabc</span></span><br></pre></td></tr></table></figure></div>

<p>​        这个例子的本质是，字符串对象a指向了一个新的字符串数组。</p>
<ul>
<li>如果真的要去修改String内容的话，其实也是可以的，使用<strong>反射</strong>机制就可以实现，示例如下：</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>; </span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s); <span class="comment">//Hello World</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField("value");</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">//Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="参考博客："><a href="#参考博客：" class="headerlink" title="参考博客："></a>参考博客：</h2><blockquote>
<p><a href="https://www.cnblogs.com/leskang/p/6110631.html" target="_blank" rel="noopener">https://www.cnblogs.com/leskang/p/6110631.html</a> </p>
<p><a href="https://www.cnblogs.com/xudong-bupt/p/3961159.html" target="_blank" rel="noopener">https://www.cnblogs.com/xudong-bupt/p/3961159.html</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>flume总结与思考</title>
    <url>/2020/04/24/flume%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>大数据</category>
        <category>flume</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>面试</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka分区分配策略</title>
    <url>/2020/04/23/kafka%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="kafka分区分配策略"><a href="#kafka分区分配策略" class="headerlink" title="kafka分区分配策略"></a>kafka分区分配策略</h1><p>kafka系列总结之：kafka分区分配策略[转载&amp;归纳]</p>
<ul>
<li>kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。</li>
<li>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据 </li>
</ul>
<p>kafka官网：</p>
<blockquote>
<p>kafka.apache.org</p>
</blockquote>
<p>kafka分区分配策略文章索引</p>
<p>1、 <a href="https://blog.csdn.net/u013256816/article/details/81123600" target="_blank" rel="noopener">Kafka分区分配策略（1）——RangeAssignor</a></p>
<p>2、 <a href="https://blog.csdn.net/u013256816/article/details/81123625" target="_blank" rel="noopener">Kafka分区分配策略（2）——RoundRobinAssignor和StickyAssignor</a></p>
<p>3、 <a href="https://blog.csdn.net/u013256816/article/details/81123858" target="_blank" rel="noopener">Kafka分区分配策略（3）——自定义分区分配策略</a> </p>
<p>4、 <a href="https://blog.csdn.net/u013256816/article/details/81123907" target="_blank" rel="noopener">Kafka分区分配策略（4）——分配的实施</a></p>
<blockquote>
<p>[注]作者为 《深入理解Kafka:核心设计与实践原理》 的作者：朱忠华老师</p>
<p>作者更多kafka技术文章： <a href="https://blog.csdn.net/u013256816/category_6500871.html" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/category_6500871.html</a> </p>
<p>作者个人博客： <a href="http://honeypps.com/" target="_blank" rel="noopener">http://honeypps.com/</a></p>
<p>作者CSDN博客： <a href="https://blog.csdn.net/u013256816" target="_blank" rel="noopener">https://blog.csdn.net/u013256816</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>大数据</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka高效读写数据</title>
    <url>/2020/04/27/kafka%E9%AB%98%E6%95%88%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="kafka高效读写数据"><a href="#kafka高效读写数据" class="headerlink" title="kafka高效读写数据"></a>kafka高效读写数据</h1><h2 id="一、分布式集群"><a href="#一、分布式集群" class="headerlink" title="一、分布式集群"></a>一、分布式集群</h2><p>Kafka本身是分布式集群；同时采用分区技术，并发度高。  </p>
<blockquote>
<p>zookeeper在kafka中的作用：kafka集群中有一个broker会被选举成controller，负责管理集群broker的上下线，所有的topic分区副本分配和leader选举等工作。controller的管理工作都依赖于zk。</p>
</blockquote>
<h2 id="二、顺序写磁盘"><a href="#二、顺序写磁盘" class="headerlink" title="二、顺序写磁盘"></a>二、顺序写磁盘</h2><p>Kafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端，为顺序写。官网有数据表明，同样的磁盘，顺序写能到600M/s，而随机写只有100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。</p>
<h2 id="三、零复制技术"><a href="#三、零复制技术" class="headerlink" title="三、零复制技术"></a>三、零复制技术</h2><p>kafka零复制技术示意图：</p>
<p><a href="https://pic.downk.cc/item/5ea7012ec2a9a83be5e629f2.png" data-fancybox="group" data-caption="kafka零拷贝技术" class="fancybox"><img alt="kafka零拷贝技术" title="kafka零拷贝技术" data-src="https://pic.downk.cc/item/5ea7012ec2a9a83be5e629f2.png" class="lazyload"></a></p>
<p>java复制技术示意图：</p>
<p>（仅仅复制文件，没有对于文件的应用，效率很低。</p>
<p>文件要经过操作系统层（OS层）Buffer缓存传给java应用层输入流，输入流再将数据写到输出流，输出流将数据写到OS层缓存，缓存在将数据写到新的文件。。。）</p>
<p><a href="https://pic.downk.cc/item/5ea701a6c2a9a83be5e6b749.png" data-fancybox="group" data-caption="java拷贝技术原理图解" class="fancybox"><img alt="java拷贝技术原理图解" title="java拷贝技术原理图解" data-src="https://pic.downk.cc/item/5ea701a6c2a9a83be5e6b749.png" class="lazyload"></a></p>
<p>因为java复制技术在拷贝文件时效率较低，所以对上图做出优化，如下图所示：</p>
<p>（应用层通知操作系统层：仅仅是复制文件，所以操作系统层就不会将数据传给应用层，直接在操作系统层复制文件即可。）</p>
<p><a href="https://pic.downk.cc/item/5ea701c6c2a9a83be5e6e1e8.png" data-fancybox="group" data-caption="零拷贝技术图解" class="fancybox"><img alt="零拷贝技术图解" title="零拷贝技术图解" data-src="https://pic.downk.cc/item/5ea701c6c2a9a83be5e6e1e8.png" class="lazyload"></a></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>scala中的flatMap和foldLeft函数</title>
    <url>/2020/04/21/scala%E4%B8%AD%E7%9A%84flatMap%E5%92%8CfoldLeft%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="scala中的flatMap和foldLeft函数"><a href="#scala中的flatMap和foldLeft函数" class="headerlink" title="scala中的flatMap和foldLeft函数"></a>scala中的flatMap和foldLeft函数</h1><p>scala由于其函数式编程的特性，在大数据的处理中被广泛使用。</p>
<p>此文针对scala集合中两个常用的，却不太好理解的函数进行示例讲解。</p>
<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>scala中最重要的函数之一，映射扁平化</p>
<p>把握以下三点即可：</p>
<blockquote>
<p>1、flatMap = map + flatten</p>
<p>2、什么类型调用的flatMap方法，则返回的也是什么类型</p>
<p>3、<strong>先对集合中的每个元素进行map，</strong></p>
<p>​      <strong>再对map后的每个元素（map后的每个元素必须还是集合）中的每个元素进行flatten</strong></p>
</blockquote>
<p>[注] 进行map的对象可以是只含一层的集合，但进行flatten操作的对象必需是至少含两层的集合</p>
<p>map和flatten示例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test0001</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 集合映射</span></span><br><span class="line">    println(<span class="string">"map =&gt; "</span> + list.map(x=&gt;&#123;x*<span class="number">2</span>&#125;)) <span class="comment">//map =&gt; List(2, 4, 6, 8)</span></span><br><span class="line">    println(<span class="string">"map =&gt; "</span> + list.map(x=&gt;x*<span class="number">2</span>))   <span class="comment">//map =&gt; List(2, 4, 6, 8)</span></span><br><span class="line">    println(<span class="string">"map =&gt; "</span> + list.map(_*<span class="number">2</span>))      <span class="comment">//map =&gt; List(2, 4, 6, 8)</span></span><br><span class="line">    <span class="comment">// 集合扁平化</span></span><br><span class="line">    <span class="keyword">val</span> list1 = <span class="type">List</span>(</span><br><span class="line">      <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">      <span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">    )</span><br><span class="line">    println(<span class="string">"flatten =&gt;"</span> + list1.flatten)   <span class="comment">//flatten =&gt;List(1, 2, 3, 4)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>flatMap示例一：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> words = <span class="type">Set</span>(<span class="string">"scala"</span>, <span class="string">"spark"</span>, <span class="string">"hadoop"</span>)</span><br><span class="line"><span class="keyword">val</span> result = words.flatMap(x =&gt; x.toUpperCase)</span><br><span class="line">println(result)  <span class="comment">//Set(A, L, P, C, H, K, R, O, D, S)</span></span><br></pre></td></tr></table></figure></div>

<p>flatMap示例二：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tuples: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">"Hello Scala"</span>, <span class="number">4</span>), (<span class="string">"Hello Spark"</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">val</span> strings: <span class="type">List</span>[<span class="type">String</span>] = tuples.map(t=&gt;&#123;(t._1+<span class="string">" "</span>)*t._2&#125;)</span><br><span class="line"><span class="comment">//List(Hello Scala Hello Scala Hello Scala Hello Scala , Hello Spark Hello Spark )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> flatMapList: <span class="type">List</span>[<span class="type">String</span>] = strings.flatMap(t=&gt;&#123;t.split(<span class="string">" "</span>)&#125;)</span><br><span class="line"><span class="comment">//List(Hello, Scala, Hello, Scala, Hello, Scala, Hello, Scala, Hello, Spark, Hello, Spark)</span></span><br></pre></td></tr></table></figure></div>

<p>flatMap示例三：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> linesList = <span class="type">List</span>((<span class="string">"Hello Scala"</span>, <span class="number">4</span>), (<span class="string">"Hello Spark"</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">val</span> flatMapList: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = linesList.flatMap(t =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> line: <span class="type">String</span> = t._1</span><br><span class="line">    <span class="keyword">val</span> words = line.split(<span class="string">" "</span>)</span><br><span class="line">    words.map(w =&gt; (w, t._2))</span><br><span class="line">&#125;)</span><br><span class="line">println(flatMapList)  <span class="comment">//List((Hello,4), (Scala,4), (Hello,2), (Spark,2))</span></span><br></pre></td></tr></table></figure></div>

<p>根据上述三个原则即可算出函数结果。</p>
<h2 id="foldLeft"><a href="#foldLeft" class="headerlink" title="foldLeft"></a>foldLeft</h2><p>集合折叠函数，fold、foldRight底层都是基于foldLeft函数。</p>
<p>所以本文用到的函数可以不用严格区分，主要阐述其原理。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](z: <span class="type">A1</span>)(op: (<span class="type">A1</span>, <span class="type">A1</span>) =&gt; <span class="type">A1</span>): <span class="type">A1</span> = foldLeft(z)(op)</span><br></pre></td></tr></table></figure></div>

<p>就是将集合的数据和集合之外的数据进行聚合操作。</p>
<p>fold方法有函数柯里化，有2个参数列表</p>
<ul>
<li><p>第一个参数列表：集合之外的数据</p>
</li>
<li><p>第二个参数列表：表示计算规则</p>
</li>
</ul>
<p>fold示例一：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 集合折叠</span></span><br><span class="line">println(<span class="string">"fold =&gt; "</span> + list.fold(<span class="number">0</span>)(_+_))    <span class="comment">//10</span></span><br><span class="line"><span class="comment">// 集合折叠(左)</span></span><br><span class="line">println(<span class="string">"foldLeft =&gt; "</span> + list.foldLeft(<span class="number">0</span>)(_+_)) <span class="comment">//10</span></span><br></pre></td></tr></table></figure></div>

<p>  fold示例二：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Scala21_Collection_Method4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 将两个Map集合进行合并(merge)处理</span></span><br><span class="line">    <span class="keyword">val</span> map1 = mutable.<span class="type">Map</span>(<span class="string">"a"</span> -&gt; <span class="number">1</span>, <span class="string">"b"</span> -&gt; <span class="number">2</span>, <span class="string">"c"</span> -&gt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> map2 = mutable.<span class="type">Map</span>(<span class="string">"a"</span> -&gt; <span class="number">4</span>, <span class="string">"d"</span> -&gt; <span class="number">5</span>, <span class="string">"c"</span> -&gt; <span class="number">6</span>)</span><br><span class="line">    <span class="comment">// Map( "a"-&gt;5, "b"-&gt;2, "c"-&gt;9 ,"d"-&gt;5)</span></span><br><span class="line">    <span class="keyword">val</span> map3 = map2.foldLeft(map1)(</span><br><span class="line">      (map, kv) =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> k = kv._1</span><br><span class="line">        <span class="keyword">val</span> v = kv._2</span><br><span class="line">        <span class="comment">//map.update(k, map.getOrElse(k, 0) + v)</span></span><br><span class="line">        map(k) = map.getOrElse(k, <span class="number">0</span>) + v</span><br><span class="line">        map</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    println(map3) <span class="comment">//Map(b -&gt; 2, d -&gt; 5, a -&gt; 5, c -&gt; 9)</span></span><br><span class="line">    </span><br><span class="line">    println(map1) <span class="comment">//Map(b -&gt; 2, d -&gt; 5, a -&gt; 5, c -&gt; 9)</span></span><br><span class="line">    println(map2) <span class="comment">//Map(d -&gt; 5, a -&gt; 4, c -&gt; 6)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>原理示意图如下：</p>
<p><a href="https://pic.downk.cc/item/5e9f0b95c2a9a83be5c27ef7.png" data-fancybox="group" data-caption="folfLeft原理图" class="fancybox"><img alt="folfLeft原理图" title="folfLeft原理图" data-src="https://pic.downk.cc/item/5e9f0b95c2a9a83be5c27ef7.png" class="lazyload"></a></p>
<p><strong>总结：</strong></p>
<p><strong>其实，在foldleft函数中，第二个参数规定的就是，</strong></p>
<p><strong>foldleft第一个参数和foldleft调用者的第一个元素的运算规则</strong></p>
<p>可以用如下公式理解：</p>
<blockquote>
<p>a. foldLeft( b )( (b,a的第一个元素)=&gt;{} )</p>
</blockquote>
<p>（对应上面示意图：红色块为b，蓝色块为a）</p>
<p>只不过在此公式中b和a的第一个元素都是动态变化的：</p>
<p>​    b一直在迭代，a会继续往后顺序取后面的值。</p>
<p>​    <strong>其实函数最终返回值就是b的值（上面的例子map1和map3相等也能证明这一点，本质就是map1把值赋给了map3），且a不发生改变。</strong></p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>scala</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题：sleep和wait的区别</title>
    <url>/2020/04/14/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Java中sleep和wait方法的区别"><a href="#Java中sleep和wait方法的区别" class="headerlink" title="Java中sleep和wait方法的区别"></a>Java中sleep和wait方法的区别</h1><p> sleep和wait都能使线程处于阻塞状态，但二者有着本质区别。 </p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread();</span><br><span class="line">        <span class="comment">//【本质区别】静态方法和成员方法</span></span><br><span class="line">        <span class="comment">//【静态方法】，绑定的是类。休眠的线程不是t1，是当前运行的main线程</span></span><br><span class="line">        <span class="comment">//和对象都没有关系，所以不存在什么对象锁</span></span><br><span class="line">        t1.sleep(<span class="number">1000</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【成员方法】，等待的线程就是t2</span></span><br><span class="line">        <span class="comment">//有同步/synchronized关键字才能拿到对象锁。</span></span><br><span class="line">        t2.wait();</span><br><span class="line">        t2.wait(<span class="number">1000</span>);<span class="comment">//wait也可以加等待时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//【扩展】scala中的伴生对象就是对静态语法的模拟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>【核心】静态方法、成员方法<ol>
<li>sleep是Thread类的静态方法。sleep的作用是让线程休眠道制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行。</li>
<li>wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会属将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者。 </li>
</ol>
</li>
<li>sleep方法没有释放锁（lock），而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 </li>
<li>【使用范围】<ol>
<li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，</li>
<li>而sleep可以在任何地方使用</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[spark]十一种方式实现WordCount</title>
    <url>/2020/04/27/spark-%E5%8D%81%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0WordCount/</url>
    <content><![CDATA[<h1 id="Spark-十一种方式实现WordCount"><a href="#Spark-十一种方式实现WordCount" class="headerlink" title="[Spark]十一种方式实现WordCount"></a>[Spark]十一种方式实现WordCount</h1><p>使用Spark中的11种方法实现经典的WordCount算法。</p>
<p>其中，10种SparkRDD（算子）+ 1种自定义累加器实现。</p>
<blockquote>
<p>特朗普：没人比我更懂WordCount！（滑稽）</p>
</blockquote>
<h2 id="Why-WordCount？"><a href="#Why-WordCount？" class="headerlink" title="Why WordCount？"></a>Why WordCount？</h2><ul>
<li>大数据中最经典的算法，相当于编程语言中的“Hello World”。</li>
<li>在大数据处理中，大多数复杂的问题通常被拆分成一个个小问题，这些小问题一般都是基于WordCount算法。所以，WordCount是重中之重，是大数据处理算法的基石。</li>
</ul>
<h2 id="10种Spark算子实现"><a href="#10种Spark算子实现" class="headerlink" title="10种Spark算子实现"></a>10种Spark算子实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * spark-使用十种[算子]实现wordcount</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RDDWordcount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"spark"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">//    val rdd = sc.textFile("input/wc.txt").flatMap(datas =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//      datas.split(" ")</span></span><br><span class="line">    <span class="comment">//    &#125;)</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"hadoop"</span>, <span class="string">"hello"</span>, <span class="string">"spark"</span>, <span class="string">"hello"</span>, <span class="string">"scala"</span>, <span class="string">"hello"</span>, <span class="string">"scala"</span>, <span class="string">"spark"</span>))</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================1===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.countByValue().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================2===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).countByKey().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================3===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).reduceByKey(_ + _).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================4===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).groupByKey().mapValues(_.size).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================5===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).aggregateByKey(<span class="number">0</span>)(_ + _, _ + _).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================6===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).foldByKey(<span class="number">0</span>)(_ + _).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================7===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).combineByKey(</span><br><span class="line">      (num: <span class="type">Int</span>) =&gt; num,</span><br><span class="line">      (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">        x + y</span><br><span class="line">      &#125;,</span><br><span class="line">      (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; &#123;</span><br><span class="line">        x + y</span><br><span class="line">      &#125;</span><br><span class="line">    ).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================8===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).groupBy(_._1).map(kv =&gt; &#123;</span><br><span class="line">      (kv._1, kv._2.size)</span><br><span class="line">    &#125;).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================9===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.aggregate(mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]())(</span><br><span class="line">      (map, word) =&gt; &#123;</span><br><span class="line">        map(word) = map.getOrElse(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        map</span><br><span class="line">      &#125;,</span><br><span class="line">      (map1, map2) =&gt; &#123;</span><br><span class="line">        map1.foldLeft(map2)(</span><br><span class="line">          (finalMap, kv) =&gt; &#123;</span><br><span class="line">            finalMap(kv._1) = finalMap.getOrElse(kv._1, <span class="number">0</span>) + kv._2</span><br><span class="line">            finalMap</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    ).foreach(println)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"=================10===================="</span>)</span><br><span class="line"></span><br><span class="line">    rdd.map(s =&gt; mutable.<span class="type">Map</span>(s -&gt; <span class="number">1</span>)).fold(mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]())(</span><br><span class="line">      (map1, map2) =&gt; &#123;</span><br><span class="line">        map1.foldLeft(map2)(</span><br><span class="line">          (finalMap, kv) =&gt; &#123;</span><br><span class="line">            finalMap(kv._1) = finalMap.getOrElse(kv._1, <span class="number">0</span>) + kv._2</span><br><span class="line">            finalMap</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    ).foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">=================<span class="number">1</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">2</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">3</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">4</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">5</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">6</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">7</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">8</span>====================</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">=================<span class="number">9</span>====================</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">(hello,<span class="number">3</span>)</span><br><span class="line">=================<span class="number">10</span>====================</span><br><span class="line">(hadoop,<span class="number">1</span>)</span><br><span class="line">(spark,<span class="number">2</span>)</span><br><span class="line">(scala,<span class="number">2</span>)</span><br><span class="line">(hello,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div>

<h2 id="自定义累加器实现"><a href="#自定义累加器实现" class="headerlink" title="自定义累加器实现"></a>自定义累加器实现</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">AccumulatorV2</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyAccTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"acc"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Spark - 自定义累加器 - wordcount</span></span><br><span class="line">    <span class="comment">// 累加器可以不使用shuffle就完成数据的聚合功能</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">"hadoop spark"</span>, <span class="string">"hello"</span>, <span class="string">"spark"</span>, <span class="string">"hello"</span>, <span class="string">"scala"</span>, <span class="string">"hello"</span>, <span class="string">"scala"</span>, <span class="string">"spark"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 1. 创建累加器</span></span><br><span class="line">    <span class="keyword">val</span> acc = <span class="keyword">new</span> <span class="type">WordCountAccumulator</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 2. 向Spark注册累加器</span></span><br><span class="line">    sc.register(acc, <span class="string">"wordcount"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 3. 使用累加器</span></span><br><span class="line">    rdd.foreach(</span><br><span class="line">      words =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> ws = words.split(<span class="string">" "</span>)</span><br><span class="line">        ws.foreach(</span><br><span class="line">          word =&gt; &#123;</span><br><span class="line">            acc.add(word)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    println(acc.value) <span class="comment">//Map(hadoop -&gt; 1, spark -&gt; 3, scala -&gt; 2, hello -&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义累加器 Map&#123;(Word - Count), (Word - Count)&#125;</span></span><br><span class="line">  <span class="comment">// 1, 继承AccumulatorV2, 定义泛型</span></span><br><span class="line">  <span class="comment">//    IN :  向累加器传递的值的类型 , Out : 累加器的返回结果类型</span></span><br><span class="line">  <span class="comment">// 2. 重写方法</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WordCountAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]] </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> innerMap = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 累加器是否初始化</span></span><br><span class="line">    <span class="comment">// Z</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = innerMap.isEmpty</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 复制累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]] = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">WordCountAccumulator</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 重置累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      innerMap.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 累加数据</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(word: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> cnt = innerMap.getOrElse(word, <span class="number">0</span>)</span><br><span class="line">      innerMap.update(word, cnt + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 合并累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="comment">// 两个Map的合并</span></span><br><span class="line">      <span class="keyword">var</span> map1 = <span class="keyword">this</span>.innerMap</span><br><span class="line">      <span class="keyword">var</span> map2 = other.value</span><br><span class="line"></span><br><span class="line">      innerMap = map1.foldLeft(map2)(</span><br><span class="line">        (map, kv) =&gt; &#123;</span><br><span class="line">          <span class="keyword">val</span> k = kv._1</span><br><span class="line">          <span class="keyword">val</span> v = kv._2</span><br><span class="line">          map(k) = map.getOrElse(k, <span class="number">0</span>) + v</span><br><span class="line">          map</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 获取累加器的值，就是累加器的返回结果</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = innerMap</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出结果：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">scala</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span>(spark -&gt; <span class="number">3</span>, hadoop -&gt; <span class="number">1</span>, scala -&gt; <span class="number">2</span>, hello -&gt; <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>大数据</category>
        <category>spark</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>scala</tag>
        <tag>spark</tag>
        <tag>wordcount</tag>
      </tags>
  </entry>
  <entry>
    <title>关于HashMap的两道小面试题</title>
    <url>/2020/04/11/%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E4%B8%A4%E9%81%93%E5%B0%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>关于i=i++的分析与思考</title>
    <url>/2020/04/11/%E5%85%B3%E4%BA%8Ei-i-%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap文章推荐</title>
    <url>/2020/04/30/HashMap%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="HashMap文章推荐"><a href="#HashMap文章推荐" class="headerlink" title="HashMap文章推荐"></a>HashMap文章推荐</h1><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p>
<p>【强烈推荐】来自<strong>美团技术团队</strong>，里面的参考文章也非常好</p>
<p><a href="https://zhuanlan.zhihu.com/p/96426441" target="_blank" rel="noopener">《吊打面试官》系列-HashMap</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/97902016" target="_blank" rel="noopener">《吊打面试官》系列-ConcurrentHashMap &amp; HashTable</a></p>
<p>来自敖丙（蘑菇街大佬），从面试官角度阐述关键技术点，十分硬核，全是干货。</p>
<p><a href="https://zhuanlan.zhihu.com/p/125628540" target="_blank" rel="noopener">一个HashMap跟面试官扯了半个小时</a></p>
<p>面试者角度阐述HashMap。</p>
<p>有空闲时间的话，我自己也会出一篇，甚至是一系列的HashMap文章，</p>
<p>比如</p>
<ul>
<li>源码分析，</li>
<li>知识点总结，</li>
<li>常考面试题归档 等等</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>易错点</tag>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
