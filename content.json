{"meta":{"title":"MasterYangBlog","subtitle":"","description":"","author":"Yang4","url":"https://masteryang4.github.io","root":"/"},"pages":[{"title":"About me","date":"2020-04-15T16:13:50.000Z","updated":"2020-06-14T15:13:27.703Z","comments":true,"path":"about/index.html","permalink":"https://masteryang4.github.io/about/index.html","excerpt":"","text":"json123456789&#123; \"Name\": \"Yang Sen\", \"School\": \"WHU\" \"Sex\": \" ♂ \", \"Address\": \"Shanghai.China\", \"Github\": \"https://github.com/masteryang4\", \"Blog\": \"www.yangsen94.top\", \"E-mail\": \"2692474773@qq.com\"&#125; 技术栈： Java，Python，Scala，大数据，Web，机器学习&amp;深度学习技术等 欢迎互相交♂流♂学习~"},{"title":"文章分类","date":"2020-04-13T13:58:22.000Z","updated":"2020-04-15T15:54:13.404Z","comments":true,"path":"categories/index.html","permalink":"https://masteryang4.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-13T13:58:35.000Z","updated":"2020-06-17T14:04:23.097Z","comments":true,"path":"link/index.html","permalink":"https://masteryang4.github.io/link/index.html","excerpt":"","text":"Codesheep程序羊： https://www.codesheep.cn/ 廖雪峰的官方网站： https://www.liaoxuefeng.com/ 牛客网： https://www.nowcoder.com/ 左耳朵耗子（酷壳）： https://coolshell.cn/ 敖丙三太子： https://github.com/AobingJava 知乎： https://www.zhihu.com/ 王道计算机考研： http://cskaoyan.com/forum.php"},{"title":"留言板","date":"2020-04-19T12:00:02.000Z","updated":"2020-04-19T12:10:25.372Z","comments":true,"path":"messageboard/index.html","permalink":"https://masteryang4.github.io/messageboard/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-13T13:57:16.000Z","updated":"2020-04-15T15:58:24.136Z","comments":true,"path":"tags/index.html","permalink":"https://masteryang4.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jvm小结","slug":"jvm小结","date":"2020-08-09T16:47:43.000Z","updated":"2020-08-10T02:08:22.677Z","comments":true,"path":"2020/08/10/jvm小结/","link":"","permalink":"https://masteryang4.github.io/2020/08/10/jvm%E5%B0%8F%E7%BB%93/","excerpt":"","text":"JVM简介JVM作用在Java语言中，最重要的莫过于Java虚拟机。为什么需要有Java虚拟机呢？ Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。因此，直接在硬件上运行这种复杂的程序并不现实。所以呢，在运行 Java 程序之前，我们需要对其进行一番转换。 转换的过程为通过编译器将 Java 程序转换成该虚拟机所能识别的指令序列，也称 Java 字节码。Java虚拟机会将字节码，即class文件加载到JVM中。由JVM进行解释和执行。除了 Java 外，Scala、Clojure、Groovy，以及时下热门的 Kotlin，这些语言都可以运行在 Java 虚拟机之上 JVM是运行在操作系统之上的，它与硬件没有直接的交互 JVM分类​ Sun Classis VM: 世界上第一款商用的虚拟机，已经完全淘汰。 ​ HotSpot VM： Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。最初由一家名为“Longview Technologies”的小公司设计，后被Sun公司收购。 ​ Jrockit: 由BEA公司开发的专注于服务器端应用的虚拟机。号称世界上最快的虚拟机。优势在于其垃圾收集器和MissionControl服务套件。BEA Jrockit Mission Control在2005年12月推出，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。它包括三个独立的应用程序：内存泄露检测器（Memory Leak Detector），JVM运行时分析器（Runtime Analyzer）和管理控制台(Management Console)。 ​ J9：J9由IBM公司开发，曾广泛应用于IBM公司系统内部及IBM小型机上。现已经捐献给Eclipse基金会。 JVM组成 Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。执行 Java 代码首先需要使用类加载器将它编译而成的 class 文件加载到 Java 虚拟机中。加载后的 Java 类会被存放于方法区（Method Area）中。实际运行时，虚拟机会执行方法区内的代码。 在虚拟机中，方法区和堆为线程共享，也是垃圾回收的重点照顾区域。栈空间为线程私有，基本不会出现垃圾回收。 Java 虚拟机将栈细分为面向 Java 方法的 Java 方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，以及存放各个线程执行位置的 PC 寄存器(程序计数器)。 在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧(栈的一片区域)，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。 类加载器类加载器，即ClassLoader,它负责加载class文件，class文件在文件开头有特定的文件标示，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 分类虚拟机自带的类加载器： 启动类加载器（Bootstrap）：主要负责加载jre中的最为基础、最为重要的类。如$JAVA_HOME/jre/lib/rt.jar（runtime）等，以及由虚拟机参数 -Xbootclasspath 指定的类。由于它由由C++代码实现，没有对应的java对象，因此在java中，尝试获取此类时，只能使用null来指代。 扩展类加载器（Extension），由Java代码实现，用于加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类，以及由系统变量 java.ext.dirs 指定的类。如$JAVA_HOME/jre/lib/ext/*.jar。 应用程序类加载器（AppClassLoader）,由Java代码实现， 它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。 用户自定义的加载器：Java.lang.ClassLoader的子类，用户可以定制类的加载方式。例如可以对 class 文件进行加密，加载时再利用自定义的类加载器对其解密。 除了BootStrap Class Loader，其他的类加载器，都是Java.lang.ClassLoader的子类。其他的类加载器都由加载sum.misc.Launcher类后得到。 双亲委派机制双亲委派模型：每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。 优势： ①这采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。 ②其次是考虑到安全因素，防止java核心api中定义类型不会被用户恶意替换和篡改，从而引发错误。 java123456package java.lang;public class String &#123; public String() &#123; System.out.println(\"自己伪造的String\"); &#125;&#125; JVM内存模型 Execution EngineExecution Engine执行引擎负责解释命令，提交操作系统执行。在 HotSpot 里面，将字节码翻译为机器码的翻译过程有两种形式：第一种是解释执行，即逐条将字节码翻译成机器码并执行；第二种是即时编译（Just-In-Time compilation，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行。 前者的优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。 Native Interface &amp; Native Method Stack在每个操作系统内部，都定义了很多本地方法库，例如windows中以.dll文件为主，Linux总以.so文件为主。 这些本地方法库中，定义了很多调用本地操作系统的方法，也称之为本地方法接口(Native Interface)。 本地方法接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须要调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraie（本地方法库）。 ​ 目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，或者是使用Java语言开发安卓操作系统的硬件驱动等。 ​ 例如： java123456public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); PC寄存器（程序计数器）每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,就是即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。 ​ PC寄存器主要负责计数和调度。它可以看作是当前线程所执行的字节码的行号指示器。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。 方法区（Method Area）方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区属于共享区间。 ​ 静态变量+常量+类信息(构造方法/接口定义)+运行时常量池存在方法区中。 ​ But ​ 实例变量存在堆内存中,和方法区无关。 ​ 方法区是《Java虚拟机规范》中规定的一个概念，在JDK1.7之前，HotSpot使用永久区实现方法区。 ​ 1.8之后，由元空间实现。 栈栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就结束，生命周期和线程一致，是线程私有的。 一个线程中的每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。 在栈区域规定了两种异常状态：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，在扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常。 堆逻辑设计堆是java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。堆内存的大小是可以调节的（通过 -Xmx 和 -Xms 控制）。 所有的对象实例以及数组都要在堆上分配。 如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 ​ java堆是垃圾收集器管理的主要区域，因此也被成为“GC堆”（Garbage Collected Heap）。 堆内存逻辑上分为三部分： ​ Young Generation Space 新生区(新生代) Young/New ​ Tenure generation space 养老区(养老代) Old/ Tenure ​ Permanent Space 永久区(永久代)（1.8后为元空间） Perm 物理设计在Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收 新生代分为eden区、s0区、s1区，s0和s1也被称为from和to区域，他们是两块大小相等并且可以互换角色的空间。绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则进入s0或s1区，之后每经过一次新生代回收，如果对象存活则它的年龄就加1，对象达到一定的年龄（默认15）后，则进入老年代。 永久区永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会轻易被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。 如果出现java.lang.OutOfMemoryError: PermGen space，说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。 Jdk1.6及之前： 有永久代, 常量池1.6在方法区 Jdk1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆 Jdk1.8及之后： 无永久代，常量池1.8在元空间 实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。 对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现，jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走。 常量池（Constant Pool）是方法区的一部分，Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。 JVM参数设置常见参数设置 1.7的堆结构 参数名 含义 -XX:+PrintGC 每次触发GC的时候打印相关日志 -XX:+UseSerialGC 串行回收 -XX:+PrintGCDetails 更详细的GC日志 -Xms 堆初始值(默认为物理内存的1/64) -Xmx 堆最大可用值(默认为物理内存的1/4) -Xmn 新生代堆初始值 -XX:SurvivorRatio 用来设置新生代中eden空间和from/to空间的比例，默认为8 -XX:NewRatio 配置新生代与老年代占比，默认1:2 -Xss 每个线程的堆栈大小，默认为1M，此值不能设置过大，否则会减少线程并发数。 VM初始分配的堆内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的堆内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制； 空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。 查看当前JVM内存 java12345678public static void main(String[] args) &#123; System.out.print(\"最大内存\"); System.out.println(Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + \"M\"); System.out.print(\"当前可用内存\"); System.out.println(Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + \"M\"); System.out.print(\"当前申请内存\"); System.out.println(Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + \"M\"); &#125; 设置示例： ​ -Xms20m -Xmx20m -Xmn1m -XX:SurvivorRatio=2 -XX:+PrintGCDetails -XX:+UseSerialGC代表 堆内存初始化值20m,堆内存最大值20m，新生代最大值可用1m，eden空间和from/to空间的比例为2/1，打印详细的GC信息，使用串行GC回收器。 常见异常OutOfMemoryError错误原因: java.lang.OutOfMemoryError: Java heap space 堆内存溢出 解决办法:调大堆内存大小 java123456789// -Xms1m -Xmx10m -XX:+PrintGCDetails List&lt;Object&gt; listObject = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"i:\" + i); Byte[] bytes = new Byte[1 * 1024 * 1024]; listObject.add(bytes); &#125; System.out.println(\"添加成功...\"); StackOverflowError错误原因: java.lang.StackOverflowError表示为栈内存溢出，一般产生于递归调用。 解决办法:设置线程最大调用深度，默认是1M -Xss5m 设置最大调用深度 java123456789101112131415public class StackTest &#123; private static int count; public static void count()&#123; try &#123; count++; count(); &#125; catch (Throwable e) &#123; System.out.println(\"最大深度:\"+count); e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; count(); &#125;&#125; GCGC简介JVM中的Garbage Collection，简称GC，它会不定时去堆内存中清理不可达对象。 如果一个对象变成了不可达对象，这并不代表它会立刻被回收。在GC时，不可达的对象并不会立刻回收。 垃圾回收在一个Java程序中的执行是自动执行的，不受外界干预的。程序员唯一能做的就是通过调用System.gc() 方法来”建议”执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。这也是垃圾收集器的最主要的缺点。当然相对于它给程序员带来的巨大方便性而言，这个缺点是瑕不掩瑜的。 finalize()Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。 这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object类中定义的，因此所有的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。 GC的工作特点在GC工作中，通过某种算法来对JVM中的内存区域进行检测，对检测到的不可达对象，进行垃圾回收。 理论上GC过程中会频繁收集Young区，很少收集Old区，基本不动Perm区（元空间/方法区）。 GC的分类JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC）， 新生代GC（minor GC）：只针对新生代区域的GC。 ​ 老年代GC（major GC or Full GC）：针对老年代的GC，偶尔伴随对新生代的GC以及对永久代的GC。 一般情况下，当出现了 Major GC，经常会伴随至少一次的 Minor GC（但非绝对的，在 ParallelScavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）。 MajorGC 的速度一般会比 Minor GC 慢 10倍以上。 Minor GC触发机制：当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor满不会引发GC。 Full GC触发机制：当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代，当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载 标记不可达对象引用计数法引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到循环指向的存在。 首先需要声明，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存。 什么是引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加１；当引用失效时，计数器值减１.任何时刻计数器值为０的对象就是不可能再被使用的。 主流的java虚拟机中没有使用引用计数法的最主要的原因是它很难解决对象之间相互循环引用的问题。 例如： java123456789101112public class MyObject &#123; public Object ref; public String name; public static void main(String[] args) &#123; MyObject myObject1 = new MyObject(); MyObject myObject2 = new MyObject(); myObject1.ref=myObject2; myObject2.ref=myObject1; myObject1=null; myObject2=null; &#125;&#125; 将myObject1和myObject2赋值为null后，虚拟机依然无法回收，因为他们还相互指向和依赖。 GC ROOTS算法根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。真正标记对象为可回收状态至少要标记两次. 简单理解，可以理解为堆外指向堆内的引用。 以下对象可以选取GC ROOTS节点： (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。 (2). 方法区中的类静态属性引用的对象。 (3). 方法区中常量引用的对象。 (4). 本地方法栈中JNI(Native方法)引用的对象。 垃圾回收的三种方式当标记完所有的存活对象时，我们便可以进行死亡对象的回收工作了。主流的基础回收方式可分为三种。 清除第一种是清除（sweep），即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。 清除这种回收方式的原理及其简单，但是有两个缺点。一是会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。另一个则是分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。 压缩第二种是压缩（compact），即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。 复制第三种则是复制（copy），即把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。复制这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。 总结回收死亡对象的内存共有三种方式，分别为：会造成内存碎片的清除、性能开销较大的压缩、以及堆使用效率较低的复制。当然，现代的垃圾回收器往往会综合上述几种回收方式，综合它们优点的同时规避它们的缺点。 垃圾回收算法设计思想在Java的大部分应用场景下，对象的存活复合这样一个规律，即大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。 ​ 基于这样一个规律，在JVM中，使用分代回收思想来回收垃圾。简单来说，就是将堆空间划分为两代，分别叫做新生代和老年代。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。 ​ Java 虚拟机可以给不同代使用不同的回收算法。对于新生代，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。 对于老年代，由于大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。一般在堆空间即将或者已经耗尽时，才会触发触发针对老年代的回收。这时候，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。） 堆的划分Java 虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。 默认情况下，Java 虚拟机采取的是一种动态分配的策略（对应 Java 虚拟机参数 -XX:+UsePSAdaptiveSurvivorSizePolicy），根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。 当然，你也可以通过参数 -XX:SurvivorRatio 来固定这个比例。但是需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的堆空间将越高。 标记复制(Mark-Copying)算法当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。当 Eden 区的空间耗尽了怎么办？这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。 ​ 新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。 ​ Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。 ​ 万一存活对象数量比较多，那么To域的内存可能不够存放，这个时候会借助老年代的空间。 ​ 因此Minor GC使用的则是标记-复制算法。将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。 口诀：复制必交换，谁空谁为to 标记清除(Mark-Sweep)算法老年代一般是由标记清除或者是标记清除与标记整理的混合实现。 ​ 标记清除算法一般应用于老年代,因为老年代的对象生命周期比较长。该算法先对所有可访问的对象，做个标记再遍历堆，把未被标记的对象回收（标记活的）。 ​ 缺点： ①回收时，应用需要挂起，也就是stop the world，导致用户体验非常差劲 ②由于需要遍历全堆对象，效率比较低（递归与全堆对象遍历）。 ③造成内存碎片化 标记压缩(Mark–Compact)算法标记清除算法和标记压缩算法非常相同，但是标记压缩算法在标记清除算法之上解决内存碎片化。 优点：解决内存碎片化问题。也消除了复制算法当中，内存减半的高额代价 缺点：效率低，压缩阶段，由于移动了可用对象，需要去更新引用。 标记清除压缩(Mark-Sweep-Compact)算法标记清除压缩(Mark-Sweep-Compact)算法是标记清除算法和标记压缩算法的结合算法。其原理和标记清除算法一致，只不过会在多次GC后，进行一次Compact操作！ 垃圾回收器串行回收和并行回收串行回收: JDK1.5前的默认算法 缺点是只有一个线程，执行垃圾回收时程序停止的时间比较长。 并行回收: 多个线程执行垃圾回收适合于高吞吐量的系统，回收时系统会停止运行。 Serial收集器串行收集器是最古老，最稳定以及效率高的收集器，是一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程（Stop The World）直到它收集结束。 特点：CPU利用率最高，停顿时间即用户等待时间比较长。 适用场景：小型应用。 通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。 Parallel New收集器Parallel New收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代采用复制算法、老年代采用标记-压缩 参数控制：-XX:+UseParNewGC 使用ParNew收集器 -XX:ParallelGCThreads 限制线程数量 Parallel Scavenge收集器(jdk1.8默认)Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩，采用多线程来通过扫描并压缩堆。 特点：停顿时间短，回收效率高，对吞吐量要求高。 适用场景：大型应用，科学计算，大规模数据采集等。 通过JVM参数 -XX:+UseParallelGC 打开并发标记扫描垃圾回收器。 cms收集器【重点】CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 并发预处理 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 并发重置 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。 优点:并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。 特点：响应时间优先，减少垃圾收集停顿时间。 适应场景：大型服务器等。 通过JVM参数 -XX:+UseConcMarkSweepGC设置 G1收集器(jdk1.9默认)【重点】G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记-压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。 特点：支持很大的堆，高吞吐量 --支持多CPU和垃圾回收线程 --在主线程暂停的情况下，使用并行收集 --在主线程运行的情况下，使用并发收集实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收 通过JVM参数 -XX:+UseG1GC 使用G1垃圾回收器 注意: 并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 总结针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge和 Parallel New。这三个采用的都是标记-复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。 针对老年代的垃圾回收器也有三个：Serial Old 和Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是标记-压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。 CMS 采用的是标记-清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。 推荐参考： https://blog.csdn.net/okForrest27/article/details/107330039","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"JVM","slug":"Java/JVM","permalink":"https://masteryang4.github.io/categories/Java/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://masteryang4.github.io/tags/JVM/"}]},{"title":"判断一个链表是否有环","slug":"判断一个链表是否有环","date":"2020-08-09T15:58:09.000Z","updated":"2020-08-09T15:59:03.052Z","comments":true,"path":"2020/08/09/判断一个链表是否有环/","link":"","permalink":"https://masteryang4.github.io/2020/08/09/%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/","excerpt":"","text":"问题描述怎么能够更高效地判断一个链表是否有环？ 首先创建两个指针p1和p2（在Java里就是两个对象引用），让它们同时指向这个链表的头节点。 然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环。 复杂度分析假设链表的节点数量为n，则该算法的时间复杂度为O(n)。 除两个指针外，没有使用任何额外的存储空间，所以空间复杂度是O(1) 代码实现java123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LinkedListCycle &#123; /** * 判断是否有环 * @param head 链表头节点 */ public static boolean isCycle(Node head) &#123; Node p1 = head; Node p2 = head; while (p2!=null &amp;&amp; p2.next!=null)&#123; // 【注意】 p1 = p1.next; p2 = p2.next.next; if(p1 == p2)&#123; return true; &#125; &#125; return false; &#125; /** * 链表节点 */ private static class Node &#123; int data; Node next; Node(int data) &#123; this.data = data; &#125; &#125; public static void main(String[] args) throws Exception &#123; Node node1 = new Node(5); Node node2 = new Node(3); Node node3 = new Node(7); Node node4 = new Node(2); Node node5 = new Node(6); node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5; node5.next = node2; System.out.println(isCycle(node1)); &#125;&#125; 扩展如果链表有环，如何求出环的长？ 当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时，统计出来的前进次数就是环长。 因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针再次相遇时，p2比p1多走了整整1圈因此，环长 = 每一次速度差 × 前进次数 = 前进次数 参考文献 https://www.cnblogs.com/zhaoqingqing/p/11853924.html","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://masteryang4.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"链表反转","slug":"链表反转","date":"2020-08-09T15:56:45.000Z","updated":"2020-08-09T15:57:49.241Z","comments":true,"path":"2020/08/09/链表反转/","link":"","permalink":"https://masteryang4.github.io/2020/08/09/%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"反转单链表Code12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL java1234567891011public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; &#125; return prev;&#125;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://masteryang4.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"堆排序总结","slug":"堆排序总结","date":"2020-08-09T15:49:30.000Z","updated":"2020-08-09T15:56:25.771Z","comments":true,"path":"2020/08/09/堆排序总结/","link":"","permalink":"https://masteryang4.github.io/2020/08/09/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/","excerpt":"","text":"堆的定义堆是一种数据结构，一种叫做完全二叉树的数据结构。 堆的性质这里我们用到两种堆，其实也算是一种。 大顶堆：每个节点的值都大于或者等于它的左右子节点的值。 小顶堆：每个节点的值都小于或者等于它的左右子节点的值。 把这种逻辑结构映射到数组中 ，数组arr逻辑上就是一个堆。 从这里我们可以得出以下性质 对于大顶堆：arr[i] &gt;= arr[2i + 1] &amp;&amp; arr[i] &gt;= arr[2i + 2] 对于小顶堆：arr[i] &lt;= arr[2i + 1] &amp;&amp; arr[i] &lt;= arr[2i + 2] 堆排序的基本思想1、将要排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素； 2、将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；3、重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了。 那么，该如何知道最后一个非叶子节点的位置，也就是索引值？ 对于一个完全二叉树，在填满的情况下（非叶子节点都有两个子节点），每一层的元素个数是上一层的二倍，根节点数量是1，所以最后一层的节点数量，一定是之前所有层节点总数+1，所以，我们能找到最后一层的第一个节点的索引，即节点总数/2（根节点索引为0），这也就是第一个叶子节点，所以第一个非叶子节点的索引就是第一个叶子结点的索引-1。那么对于填不满的二叉树呢？这个计算方式仍然适用，当我们从上往下，从左往右填充二叉树的过程中，第一个叶子节点，一定是序列长度/2，所以第一个非叶子节点的索引就是arr.length / 2 -1。 现在找到了最后一个非叶子节点，即元素值为2的节点，比较它的左右节点的值，是否比他大，如果大就换位置。这里因为1&lt;2，所以，不需要任何操作，继续比较下一个，即元素值为8的节点，它的左节点值为9比它本身大，所以需要交换 java代码实现java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Arrays;public class HeapSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 1, 6, 2, 5, 3, 7, 4&#125;; heapSort(arr); System.out.println(Arrays.toString(arr)); //[1, 2, 3, 4, 5, 6, 7, 8] &#125; public static void heapSort(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return; &#125; int len = arr.length; // 构建大顶堆，这里其实就是把待排序序列，变成一个大顶堆结构的数组 buildMaxHeap(arr, len); // 交换堆顶和当前末尾的节点，重置大顶堆 for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; &#125; private static void buildMaxHeap(int[] arr, int len) &#123; // 从最后一个非叶节点开始向前遍历，调整节点性质，使之成为大顶堆 for (int i = (int) Math.floor(len / 2) - 1; i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private static void heapify(int[] arr, int i, int len) &#123; // 先根据堆性质，找出它左右节点的索引 int left = 2 * i + 1; int right = 2 * i + 2; // 默认当前节点（父节点）是最大值。 int largestIndex = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largestIndex]) &#123; // 如果有左节点，并且左节点的值更大，更新最大值的索引 largestIndex = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largestIndex]) &#123; // 如果有右节点，并且右节点的值更大，更新最大值的索引 largestIndex = right; &#125; if (largestIndex != i) &#123; // 如果最大值不是当前非叶子节点的值，那么就把当前节点和最大值的子节点值互换 swap(arr, i, largestIndex); // 因为互换之后，子节点的值变了，如果该子节点也有自己的子节点，仍需要再次调整。 heapify(arr, largestIndex, len); &#125; &#125; private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 复杂度堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。 最好和最坏的情况时间复杂度都是O(nlogn)，空间复杂度O(1)。","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序算法","slug":"排序算法","permalink":"https://masteryang4.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"https://masteryang4.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Synchronized与Lock的区别","slug":"Synchronized与Lock的区别","date":"2020-08-09T15:46:01.000Z","updated":"2020-08-09T15:47:20.852Z","comments":true,"path":"2020/08/09/Synchronized与Lock的区别/","link":"","permalink":"https://masteryang4.github.io/2020/08/09/Synchronized%E4%B8%8ELock%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Synchronized与Lock的区别参考一 来源：lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现； 异常是否释放锁：synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁； 而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。） 是否响应中断lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断； 是否知道获取锁Lock可以通过trylock来知道有没有获取锁，而synchronized不能； Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离） 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，而Lock可以使用Condition进行线程之间的调度， 参考二 1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类； 2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； 3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； 5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） 6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 参考： https://www.cnblogs.com/iyyy/p/7993788.html ​ https://blog.csdn.net/hefenglian/article/details/82383569","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"JUC","slug":"Java/JUC","permalink":"https://masteryang4.github.io/categories/Java/JUC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"JUC","slug":"JUC","permalink":"https://masteryang4.github.io/tags/JUC/"}]},{"title":"flink系列12电商用户行为分析","slug":"flink系列12电商用户行为分析","date":"2020-08-09T15:44:47.000Z","updated":"2020-08-10T02:09:24.908Z","comments":true,"path":"2020/08/09/flink系列12电商用户行为分析/","link":"","permalink":"https://masteryang4.github.io/2020/08/09/flink%E7%B3%BB%E5%88%9712%E7%94%B5%E5%95%86%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90/","excerpt":"","text":"数据集解析淘宝数据集解析我们准备了一份淘宝用户行为数据集，保存为csv文件。本数据集包含了淘宝上某一天随机一百万用户的所有行为（包括点击、购买、收藏、喜欢）。数据集的每一行表示一条用户行为，由用户ID、商品ID、商品类目ID、行为类型和时间戳组成，并以逗号分隔。关于数据集中每一列的详细描述如下： 字段名 数据类型 说明 userId Long 脱敏后的用户ID itemId Long 脱敏后的商品ID categoryId Int 脱敏后的商品所属类别ID behavior String 用户行为类型，包括：(‘pv’, ‘buy’, ‘cart’, ‘fav’) timestamp Long 行为发生的时间戳，单位秒 Apache服务器日志数据集解析这里以apache服务器的一份log为例，每一行日志记录了访问者的IP、userId、访问时间、访问方法以及访问的url，具体描述如下： 字段名 数据类型 说明 ip String 访问的IP userId Long 访问的userId eventTime Long 访问时间 method String 访问方法 GET/POST/PUT/DELETE url String 访问的url 实时热门商品统计首先要实现的是实时热门商品统计，我们将会基于UserBehavior数据集来进行分析。 基本需求 每隔5分钟输出最近一小时内点击量最多的前N个商品 点击量用浏览次数(“pv”)来衡量 解决思路 . 在所有用户行为数据中，过滤出浏览(“pv”)行为进行统计 . 构建滑动窗口，窗口长度为1小时，滑动距离为5分钟 . 窗口计算使用增量聚合函数和全窗口聚合函数相结合的方法 . 使用窗口结束时间作为key，对DataStream进行keyBy()操作 . 将KeyedStream中的元素存储到ListState中，当水位线超过窗口结束时间时，排序输出 数据准备 将数据文件UserBehavior.csv复制到资源文件目录src/main/resources下。 程序主体 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 把数据需要ETL成UserBehavior类型case class UserBehavior(userId: Long, itemId: Long, categoryId: Int, behavior: String, timestamp: Long)// 全窗口聚合函数输出的数据类型case class ItemViewCount(itemId: Long, windowEnd: Long, count: Long) object HotItems &#123; def main(args: Array[String]): Unit = &#123; // 创建一个 StreamExecutionEnvironment val env = StreamExecutionEnvironment.getExecutionEnvironment // 设定Time类型为EventTime env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) // 为了打印到控制台的结果不乱序， // 我们配置全局的并发为1，这里改变并发对结果正确性没有影响 env.setParallelism(1) val stream = env // 以window下为例，需替换成数据集的绝对路径 .readTextFile(\"YOUR_PATH\\\\resources\\\\UserBehavior.csv\") .map(line =&gt; &#123; val linearray = line.split(\",\") UserBehavior(linearray(0).toLong, linearray(1).toLong, linearray(2).toInt, linearray(3), linearray(4).toLong) &#125;) // 过滤出点击事件 .filter(_.behavior == \"pv\") // 指定时间戳和Watermark，这里我们已经知道了数据集的时间戳是单调递增的了。 .assignAscendingTimestamps(_.timestamp * 1000) // 根据商品Id分流 .keyBy(_.itemId) // 开窗操作 .timeWindow(Time.minutes(60), Time.minutes(5)) // 窗口计算操作 .aggregate(new CountAgg(), new WindowResultFunction()) // 根据窗口结束时间分流 .keyBy(_.windowEnd) // 求点击量前3名的商品 .process(new TopNHotItems(3)) // 打印结果 stream.print() // 别忘了执行 env.execute(\"Hot Items Job\") &#125;&#125; 真实业务场景一般都是乱序的，所以一般不用assignAscendingTimestamps，而是使用BoundedOutOfOrdernessTimestampExtractor。 增量聚合函数逻辑编写 scala12345678// COUNT统计的聚合函数实现，每出现一条记录就加一class CountAgg extends AggregateFunction[UserBehavior, Long, Long] &#123; override def createAccumulator(): Long = 0L override def add(userBehavior: UserBehavior, acc: Long): Long = acc + 1 override def getResult(acc: Long): Long = acc override def merge(acc1: Long, acc2: Long): Long = acc1 + acc2&#125; 全窗口聚合函数逻辑编写 其实就是将增量聚合的结果包上一层窗口信息和key的信息。 代码如下： scala12345678910// 用于输出窗口的结果class WindowResultFunction extends ProcessWindowFunction[Long, ItemViewCount, String, TimeWindow] &#123; override def process(key: String, context: Context, elements: Iterable[Long], out: Collector[ItemViewCount]): Unit = &#123; out.collect(ItemViewCount(key, context.window.getEnd, elements.iterator.next())) &#125;&#125; 现在我们就得到了每个商品在每个窗口的点击量的数据流。 计算最热门TopN商品 scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class TopNHotItems(topSize: Int) extends KeyedProcessFunction[Long, ItemViewCount, String] &#123; // 惰性赋值一个状态变量 lazy val itemState = getRuntimeContext.getListState( new ListStateDescriptor[ItemViewCount](\"items\", Types.of[ItemViewCount]) ) // 来一条数据都会调用一次 override def processElement(value: ItemViewCount, ctx: KeyedProcessFunction[Long, ItemViewCount, String]#Context, out: Collector[String]): Unit = &#123; itemState.add(value) ctx.timerService().registerEventTimeTimer(value.windowEnd + 1) &#125; // 定时器事件 override def onTimer( ts: Long, ctx: KeyedProcessFunction[Long, ItemViewCount, String]#OnTimerContext, out: Collector[String] ): Unit = &#123; val allItems: ListBuffer[ItemViewCount] = ListBuffer() // 导入一些隐式类型转换 import scala.collection.JavaConversions._ for (item &lt;- itemState.get) &#123; allItems += item &#125; // 清空状态变量，释放空间 itemState.clear() // 降序排列 val sortedItems = allItems.sortBy(-_.count).take(topSize) val result = new StringBuilder result.append(\"====================================\\n\") result.append(\"时间: \").append(new Timestamp(ts - 1)).append(\"\\n\") for (i &lt;- sortedItems.indices) &#123; val currentItem = sortedItems(i) result.append(\"No\") .append(i+1) .append(\":\") .append(\" 商品ID=\") .append(currentItem.itemId) .append(\" 浏览量=\") .append(currentItem.count) .append(\"\\n\") &#125; result.append(\"====================================\\n\\n\") Thread.sleep(1000) out.collect(result.toString()) &#125;&#125; 更换Kafka作为数据源 实际生产环境中，我们的数据流往往是从Kafka获取到的。如果要让代码更贴近生产实际，我们只需将source更换为Kafka即可： 注意：这里Kafka的版本要用2.2！ 添加依赖： xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;&lt;/dependency&gt; 编写代码： scala1234567891011121314151617181920212223val properties = new Properties()properties.setProperty(\"bootstrap.servers\", \"localhost:9092\")properties.setProperty(\"group.id\", \"consumer-group\")properties.setProperty( \"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\")properties.setProperty( \"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\")properties.setProperty(\"auto.offset.reset\", \"latest\")val env = StreamExecutionEnvironment.getExecutionEnvironmentenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)env.setParallelism(1)val stream = env .addSource(new FlinkKafkaConsumer[String]( \"hotitems\", new SimpleStringSchema(), properties) ) 当然，根据实际的需要，我们还可以将Sink指定为Kafka、ES、Redis或其它存储，这里就不一一展开实现了。 kafka生产者程序 添加依赖 xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka_2.11&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt; 编写代码： scala1234567891011121314151617181920212223242526272829import java.util.Propertiesimport org.apache.kafka.clients.producer.&#123;KafkaProducer, ProducerRecord&#125;object KafkaProducerUtil &#123; def main(args: Array[String]): Unit = &#123; writeToKafka(\"hotitems\") &#125; def writeToKafka(topic: String): Unit = &#123; val props = new Properties() props.put(\"bootstrap.servers\", \"localhost:9092\") props.put( \"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\" ) props.put( \"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\" ) val producer = new KafkaProducer[String, String](props) val bufferedSource = io.Source.fromFile(\"UserBehavior.csv文件的绝对路径\") for (line &lt;- bufferedSource.getLines) &#123; val record = new ProducerRecord[String, String](topic, line) producer.send(record) &#125; producer.close() &#125;&#125; 实时流量统计 基本需求 从web服务器的日志中，统计实时的访问流量 统计每分钟的ip访问量，取出访问量最大的5个地址，每5秒更新一次 解决思路 将apache服务器日志中的时间，转换为时间戳，作为Event Time 构建滑动窗口，窗口长度为1分钟，滑动距离为5秒 数据准备 将apache服务器的日志文件apache.log复制到资源文件目录src/main/resources下，我们将从这里读取数据。 代码实现 我们现在要实现的模块是“实时流量统计”。对于一个电商平台而言，用户登录的入口流量、不同页面的访问流量都是值得分析的重要数据，而这些数据，可以简单地从web服务器的日志中提取出来。我们在这里实现最基本的“页面浏览数”的统计，也就是读取服务器日志中的每一行log，统计在一段时间内用户访问url的次数。 具体做法为：每隔5秒，输出最近10分钟内访问量最多的前N个URL。可以看出，这个需求与之前“实时热门商品统计”非常类似，所以我们完全可以借鉴此前的代码。 完整代码如下： scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package com.ysss.projectimport java.sql.Timestampimport java.text.SimpleDateFormatimport org.apache.flink.api.common.functions.AggregateFunctionimport org.apache.flink.api.common.state.ListStateDescriptorimport org.apache.flink.api.scala.typeutils.Typesimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.functions.KeyedProcessFunctionimport org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractorimport org.apache.flink.streaming.api.scala._import org.apache.flink.streaming.api.scala.function.ProcessWindowFunctionimport org.apache.flink.streaming.api.windowing.time.Timeimport org.apache.flink.streaming.api.windowing.windows.TimeWindowimport org.apache.flink.util.Collectorimport scala.collection.mutable.ListBufferobject ApacheLogAnalysis &#123; case class ApacheLogEvent(ip: String, userId: String, eventTime: Long, method: String, url: String) case class UrlViewCount(url: String, windowEnd: Long, count: Long) def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) env.setParallelism(1) val stream = env // 文件的绝对路径 .readTextFile(\"apache.log的绝对路径\") .map(line =&gt; &#123; val linearray = line.split(\" \") // 把时间戳ETL成毫秒 val simpleDateFormat = new SimpleDateFormat(\"dd/MM/yyyy:HH:mm:ss\") val timestamp = simpleDateFormat.parse(linearray(3)).getTime ApacheLogEvent(linearray(0), linearray(2), timestamp, linearray(5), linearray(6)) &#125;) .assignTimestampsAndWatermarks( new BoundedOutOfOrdernessTimestampExtractor[ApacheLogEvent]( Time.milliseconds(1000) ) &#123; override def extractTimestamp(t: ApacheLogEvent): Long = &#123; t.eventTime &#125; &#125; ) .keyBy(_.url) .timeWindow(Time.minutes(10), Time.seconds(5)) .aggregate(new CountAgg(), new WindowResultFunction()) .keyBy(_.windowEnd) .process(new TopNHotUrls(5)) .print() env.execute(\"Traffic Analysis Job\") &#125; class CountAgg extends AggregateFunction[ApacheLogEvent, Long, Long] &#123; override def createAccumulator(): Long = 0L override def add(apacheLogEvent: ApacheLogEvent, acc: Long): Long = acc + 1 override def getResult(acc: Long): Long = acc override def merge(acc1: Long, acc2: Long): Long = acc1 + acc2 &#125; class WindowResultFunction extends ProcessWindowFunction[Long, UrlViewCount, String, TimeWindow] &#123; override def process(key: String, context: Context, elements: Iterable[Long], out: Collector[UrlViewCount]): Unit = &#123; out.collect(UrlViewCount(key, context.window.getEnd, elements.iterator.next())) &#125; &#125; class TopNHotUrls(topSize: Int) extends KeyedProcessFunction[Long, UrlViewCount, String] &#123; lazy val urlState = getRuntimeContext.getListState( new ListStateDescriptor[UrlViewCount]( \"urlState-state\", Types.of[UrlViewCount] ) ) override def processElement( input: UrlViewCount, context: KeyedProcessFunction[Long, UrlViewCount, String]#Context, collector: Collector[String] ): Unit = &#123; // 每条数据都保存到状态中 urlState.add(input) context .timerService .registerEventTimeTimer(input.windowEnd + 1) &#125; override def onTimer( timestamp: Long, ctx: KeyedProcessFunction[Long, UrlViewCount, String]#OnTimerContext, out: Collector[String] ): Unit = &#123; // 获取收到的所有URL访问量 val allUrlViews: ListBuffer[UrlViewCount] = ListBuffer() import scala.collection.JavaConversions._ for (urlView &lt;- urlState.get) &#123; allUrlViews += urlView &#125; // 提前清除状态中的数据，释放空间 urlState.clear() // 按照访问量从大到小排序 val sortedUrlViews = allUrlViews.sortBy(_.count)(Ordering.Long.reverse) .take(topSize) // 将排名信息格式化成 String, 便于打印 var result: StringBuilder = new StringBuilder result .append(\"====================================\\n\") .append(\"时间: \") .append(new Timestamp(timestamp - 1)) .append(\"\\n\") for (i &lt;- sortedUrlViews.indices) &#123; val currentUrlView: UrlViewCount = sortedUrlViews(i) // e.g. No1： URL=/blog/tags/firefox?flav=rss20 流量=55 result .append(\"No\") .append(i + 1) .append(\": \") .append(\" URL=\") .append(currentUrlView.url) .append(\" 流量=\") .append(currentUrlView.count) .append(\"\\n\") &#125; result .append(\"====================================\\n\\n\") // 控制输出频率，模拟实时滚动结果 Thread.sleep(1000) out.collect(result.toString) &#125; &#125;&#125; Uv统计的布隆过滤器实现依赖： xml12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/dependency&gt; 完整代码如下： scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.ysssimport com.ysss.UserBehavior.UserActionimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.scala._import org.apache.flink.streaming.api.scala.function.ProcessWindowFunctionimport org.apache.flink.streaming.api.windowing.time.Timeimport org.apache.flink.streaming.api.windowing.triggers.&#123;Trigger, TriggerResult&#125;import org.apache.flink.streaming.api.windowing.triggers.Trigger.TriggerContextimport org.apache.flink.streaming.api.windowing.windows.TimeWindowimport org.apache.flink.util.Collectorimport redis.clients.jedis.Jedisobject UvWithBloomFilter &#123; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val stream = env .readTextFile(\"UserBehavior.csv的绝对路径\") .map(line =&gt; &#123; val arr = line.split(\",\") UserAction(arr(0), arr(1), arr(2), arr(3), arr(4).toLong * 1000) &#125;) .assignAscendingTimestamps(_.ts) .filter(_.behavior == \"pv\") .map(r =&gt; (\"dummyKey\", r.userId)) .keyBy(_._1) .timeWindow(Time.minutes(60), Time.minutes(5)) .trigger(new MyTrigger123) .process(new MyProcess) stream.print() env.execute() &#125; class MyProcess extends ProcessWindowFunction[(String, String), (Long, Long), String, TimeWindow] &#123; lazy val jedis = new Jedis(\"localhost\", 6379) lazy val bloom = new Bloom(1 &lt;&lt; 29) override def process(key: String, context: Context, vals: Iterable[(String, String)], out: Collector[(Long, Long)]): Unit = &#123; val storeKey = context.window.getEnd.toString var count = 0L if (jedis.hget(\"UvCountHashTable\", storeKey) != null) &#123; count = jedis.hget(\"UvCountHashTable\", storeKey).toLong &#125; val userId = vals.last._2 val offset = bloom.hash(userId, 61) val isExist = jedis.getbit(storeKey, offset) if (!isExist) &#123; jedis.setbit(storeKey, offset, true) jedis.hset(\"UvCountHashTable\", storeKey, (count + 1).toString) &#125;// out.collect((count, storeKey.toLong)) &#125; &#125; class MyTrigger123 extends Trigger[(String, String), TimeWindow] &#123; override def onEventTime(time: Long, window: TimeWindow, ctx: TriggerContext): TriggerResult = &#123; if (ctx.getCurrentWatermark &gt;= window.getEnd) &#123; val jedis = new Jedis(\"localhost\", 6379) val key = window.getEnd.toString TriggerResult.FIRE_AND_PURGE println(key, jedis.hget(\"UvCountHashTable\", key)) &#125; TriggerResult.CONTINUE &#125; override def onProcessingTime( time: Long, window: TimeWindow, ctx: TriggerContext ): TriggerResult = &#123; TriggerResult.CONTINUE &#125; override def clear( window: TimeWindow, ctx: Trigger.TriggerContext ): Unit = &#123;&#125; override def onElement(element: (String, String), timestamp: Long, window: TimeWindow, ctx: TriggerContext): TriggerResult = &#123; TriggerResult.FIRE_AND_PURGE &#125; &#125; class Bloom(size: Long) extends Serializable &#123; private val cap = size def hash(value: String, seed: Int): Long = &#123; var result = 0 for (i &lt;- 0 until value.length) &#123; result = result * seed + value.charAt(i) &#125; (cap - 1) &amp; result &#125; &#125;&#125; APP分渠道数据统计完整代码如下： scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.ysssimport java.util.&#123;Calendar, UUID&#125;import org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.functions.source.RichParallelSourceFunctionimport org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContextimport org.apache.flink.streaming.api.scala._import org.apache.flink.streaming.api.scala.function.ProcessWindowFunctionimport org.apache.flink.streaming.api.windowing.time.Timeimport org.apache.flink.streaming.api.windowing.windows.TimeWindowimport org.apache.flink.util.Collectorimport scala.util.Randomobject AppMarketingByChannel &#123; case class MarketingUserBehavior(userId: String, behavior: String, channel: String, ts: Long) class SimulatedEventSource extends RichParallelSourceFunction[MarketingUserBehavior] &#123; var running = true val channelSet = Seq(\"AppStore\", \"XiaomiStore\") val behaviorTypes = Seq(\"BROWSE\", \"CLICK\") val rand = new Random override def run(ctx: SourceContext[MarketingUserBehavior]): Unit = &#123; while (running) &#123; val userId = UUID.randomUUID().toString val behaviorType = behaviorTypes(rand.nextInt(behaviorTypes.size)) val channel = channelSet(rand.nextInt(channelSet.size)) val ts = Calendar.getInstance().getTimeInMillis ctx.collect(MarketingUserBehavior(userId, behaviorType, channel, ts)) Thread.sleep(10) &#125; &#125; override def cancel(): Unit = running = false &#125; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val stream = env .addSource(new SimulatedEventSource) .assignAscendingTimestamps(_.ts) .filter(_.behavior != \"UNINSTALL\") .map(r =&gt; &#123; ((r.channel, r.behavior), 1L) &#125;) .keyBy(_._1) .timeWindow(Time.seconds(5), Time.seconds(1)) .process(new MarketingCountByChannel) stream.print() env.execute() &#125; class MarketingCountByChannel extends ProcessWindowFunction[((String, String), Long), (String, Long, Long), (String, String), TimeWindow] &#123; override def process(key: (String,String), context: Context, elements: Iterable[((String, String), Long)], out: Collector[(String, Long, Long)]): Unit = &#123; out.collect((key._1, elements.size, context.window.getEnd)) &#125; &#125;&#125; APP不分渠道数据统计完整代码如下： scala12345678910111213141516171819202122232425262728293031323334353637383940package com.ysssimport com.ysss.AppMarketingByChannel.SimulatedEventSourceimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.scala._import org.apache.flink.streaming.api.scala.function.ProcessWindowFunctionimport org.apache.flink.streaming.api.windowing.time.Timeimport org.apache.flink.streaming.api.windowing.windows.TimeWindowimport org.apache.flink.util.Collectorobject AppMarketingStatistics &#123; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val stream = env .addSource(new SimulatedEventSource) .assignAscendingTimestamps(_.ts) .filter(_.behavior != \"UNINSTALL\") .map(r =&gt; &#123; (\"dummyKey\", 1L) &#125;) .keyBy(_._1) .timeWindow(Time.seconds(5), Time.seconds(1)) .process(new MarketingCountTotal) stream.print() env.execute() &#125; class MarketingCountTotal extends ProcessWindowFunction[(String, Long), (String, Long, Long), String, TimeWindow] &#123; override def process(key: String, context: Context, elements: Iterable[(String, Long)], out: Collector[(String, Long, Long)]): Unit = &#123; out.collect((key, elements.size, context.window.getEnd)) &#125; &#125;&#125; 恶意登陆实现scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.ysssimport com.ysss.FlinkCepExample.LoginEventimport org.apache.flink.api.common.state.&#123;ListStateDescriptor, ValueStateDescriptor&#125;import org.apache.flink.api.scala.typeutils.Typesimport org.apache.flink.cep.scala.pattern.Patternimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.functions.KeyedProcessFunctionimport org.apache.flink.streaming.api.scala._import org.apache.flink.util.Collectorimport scala.collection.mutable.ListBufferobject LoginFailWithoutCEP &#123; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) env.setParallelism(1) val stream = env .fromElements( LoginEvent(\"1\", \"0.0.0.0\", \"fail\", \"1\"), LoginEvent(\"1\", \"0.0.0.0\", \"success\", \"2\"), LoginEvent(\"1\", \"0.0.0.0\", \"fail\", \"3\"), LoginEvent(\"1\", \"0.0.0.0\", \"fail\", \"4\") ) .assignAscendingTimestamps(_.ts.toLong * 1000) .keyBy(_.userId) .process(new MatchFunction) stream.print() env.execute() &#125; class MatchFunction extends KeyedProcessFunction[String, LoginEvent, String] &#123; lazy val loginState = getRuntimeContext.getListState( new ListStateDescriptor[LoginEvent](\"login-fail\", Types.of[LoginEvent]) ) lazy val timestamp = getRuntimeContext.getState( new ValueStateDescriptor[Long](\"ts\", Types.of[Long]) ) override def processElement( value: LoginEvent, ctx: KeyedProcessFunction[String, LoginEvent, String]#Context, out: Collector[String] ): Unit = &#123; if (value.loginStatus == \"fail\") &#123; loginState.add(value) if (!timestamp.value()) &#123; timestamp.update(value.ts.toLong * 1000 + 5000L) ctx .timerService() .registerEventTimeTimer(value.ts.toLong * 1000 + 5000L) &#125; &#125; if (value.loginStatus == \"success\") &#123; loginState.clear() ctx .timerService() .deleteEventTimeTimer(timestamp.value()) &#125; &#125; override def onTimer( ts: Long, ctx: KeyedProcessFunction[String, LoginEvent, String]#OnTimerContext, out: Collector[String] ): Unit = &#123; val allLogins = ListBuffer[LoginEvent]() import scala.collection.JavaConversions._ for (login &lt;- loginState.get) &#123; allLogins += login &#125; loginState.clear() if (allLogins.length &gt; 1) &#123; out.collect(\"5s以内连续两次登陆失败\") &#125; &#125; &#125;&#125; 订单支付实时监控 基本需求 用户下单之后，应设置订单失效时间，以提高用户支付的意愿，并降低系统风险 用户下单后15分钟未支付，则输出监控信息 解决思路 利用CEP库进行事件流的模式匹配，并设定匹配的时间间隔 使用Flink CEP来实现在电商平台中，最终创造收入和利润的是用户下单购买的环节；更具体一点，是用户真正完成支付动作的时候。用户下单的行为可以表明用户对商品的需求，但在现实中，并不是每次下单都会被用户立刻支付。当拖延一段时间后，用户支付的意愿会降低。所以为了让用户更有紧迫感从而提高支付转化率，同时也为了防范订单支付环节的安全风险，电商网站往往会对订单状态进行监控，设置一个失效时间（比如15分钟），如果下单后一段时间仍未支付，订单就会被取消。 我们将会利用CEP库来实现这个功能。我们先将事件流按照订单号orderId分流，然后定义这样的一个事件模式：在15分钟内，事件“create”与“pay”严格紧邻： scala12345val orderPayPattern = Pattern.begin[OrderEvent](\"begin\") .where(_.eventType == \"create\") .next(\"next\") .where(_.eventType == \"pay\") .within(Time.seconds(5)) 这样调用.select方法时，就可以同时获取到匹配出的事件和超时未匹配的事件了。 在src/main/scala下继续创建OrderTimeout.scala文件，新建一个单例对象。定义样例类OrderEvent，这是输入的订单事件流；另外还有OrderResult，这是输出显示的订单状态结果。由于没有现成的数据，我们还是用几条自定义的示例数据来做演示。 完整代码如下： scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import org.apache.flink.cep.scala.CEPimport org.apache.flink.cep.scala.pattern.Patternimport org.apache.flink.streaming.api.scala._import org.apache.flink.streaming.api.windowing.time.Timeimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.util.Collectorimport scala.collection.Mapcase class OrderEvent(orderId: String, eventType: String, eventTime: String)object OrderTimeout &#123; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val orderEventStream = env.fromCollection(List( OrderEvent(\"1\", \"create\", \"1558430842\"), OrderEvent(\"2\", \"create\", \"1558430843\"), OrderEvent(\"2\", \"pay\", \"1558430844\"), OrderEvent(\"3\", \"pay\", \"1558430942\"), OrderEvent(\"4\", \"pay\", \"1558430943\") )).assignAscendingTimestamps(_.eventTime.toLong * 1000)// val orders: DataStream[String] = env// .socketTextStream(\"localhost\", 9999)//// val orderEventStream = orders// .map(s =&gt; &#123;// println(s)// val slist = s.split(\"\\\\|\")// println(slist)// OrderEvent(slist(0), slist(1), slist(2))// &#125;)// .assignAscendingTimestamps(_.eventTime.toLong * 1000) val orderPayPattern = Pattern.begin[OrderEvent](\"begin\") .where(_.eventType.equals(\"create\")) .next(\"next\") .where(_.eventType.equals(\"pay\")) .within(Time.seconds(5)) val orderTimeoutOutput = OutputTag[OrderEvent](\"orderTimeout\") val patternStream = CEP.pattern( orderEventStream.keyBy(\"orderId\"), orderPayPattern) val timeoutFunction = ( map: Map[String, Iterable[OrderEvent]], timestamp: Long, out: Collector[OrderEvent] ) =&gt; &#123; print(timestamp) val orderStart = map.get(\"begin\").get.head out.collect(orderStart) &#125; val selectFunction = ( map: Map[String, Iterable[OrderEvent]], out: Collector[OrderEvent] ) =&gt; &#123;&#125; val timeoutOrder = patternStream .flatSelect(orderTimeoutOutput)(timeoutFunction)(selectFunction) timeoutOrder.getSideOutput(orderTimeoutOutput).print() env.execute &#125;&#125; 使用Process Function实现订单超时需求scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.ysss.projectimport org.apache.flink.api.common.state.ValueStateDescriptorimport org.apache.flink.api.scala.typeutils.Typesimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.functions.KeyedProcessFunctionimport org.apache.flink.streaming.api.scala._import org.apache.flink.util.Collectorobject OrderTimeoutWIthoutCep &#123; case class OrderEvent(orderId: String, eventType: String, eventTime: String) def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) env.setParallelism(1) val stream = env .fromElements( OrderEvent(\"1\", \"create\", \"2\"), OrderEvent(\"2\", \"create\", \"3\"), OrderEvent(\"2\", \"pay\", \"4\") ) .assignAscendingTimestamps(_.eventTime.toLong * 1000L) .keyBy(_.orderId) .process(new OrderMatchFunc) stream.print() env.execute() &#125; class OrderMatchFunc extends KeyedProcessFunction[String, OrderEvent, String] &#123; lazy val orderState = getRuntimeContext.getState( new ValueStateDescriptor[OrderEvent](\"saved order\", Types.of[OrderEvent]) ) override def processElement(value: OrderEvent, ctx: KeyedProcessFunction[String, OrderEvent, String]#Context, out: Collector[String]): Unit = &#123; if (value.eventType.equals(\"create\")) &#123; if (orderState.value() == null) &#123; // 为什么要判空？因为可能出现`pay`先到的情况 // 如果orderState为空，保存`create`事件 orderState.update(value) &#125; &#125; else &#123; // 保存`pay`事件 orderState.update(value) &#125; ctx.timerService().registerEventTimeTimer(value.eventTime.toLong * 1000 + 5000L) &#125; override def onTimer(timestamp: Long, ctx: KeyedProcessFunction[String, OrderEvent, String]#OnTimerContext, out: Collector[String]): Unit = &#123; val savedOrder = orderState.value() if (savedOrder != null &amp;&amp; savedOrder.eventType.equals(\"create\")) &#123; out.collect(\"超时订单的ID为：\" + savedOrder.orderId) &#125; orderState.clear() &#125; &#125;&#125; 实时对帐：实现两条流的Join完整代码如下： scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import org.apache.flink.api.common.state.&#123;ValueState, ValueStateDescriptor&#125;import org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.functions.co.CoProcessFunctionimport org.apache.flink.streaming.api.scala.OutputTagimport org.apache.flink.streaming.api.scala._import org.apache.flink.util.Collectorcase class OrderEvent(orderId: String, eventType: String, eventTime: String)case class PayEvent(orderId: String, eventType: String, eventTime: String)object TwoStreamsJoin &#123; val unmatchedOrders = new OutputTag[OrderEvent](\"unmatchedOrders\")&#123;&#125; val unmatchedPays = new OutputTag[PayEvent](\"unmatchedPays\")&#123;&#125; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) env.setParallelism(1) val orders = env .fromCollection(List( OrderEvent(\"1\", \"create\", \"1558430842\"), OrderEvent(\"2\", \"create\", \"1558430843\"), OrderEvent(\"1\", \"pay\", \"1558430844\"), OrderEvent(\"2\", \"pay\", \"1558430845\"), OrderEvent(\"3\", \"create\", \"1558430849\"), OrderEvent(\"3\", \"pay\", \"1558430849\") )).assignAscendingTimestamps(_.eventTime.toLong * 1000) .keyBy(\"orderId\") val pays = env.fromCollection(List( PayEvent(\"1\", \"weixin\", \"1558430847\"), PayEvent(\"2\", \"zhifubao\", \"1558430848\"), PayEvent(\"4\", \"zhifubao\", \"1558430850\") )).assignAscendingTimestamps(_.eventTime.toLong * 1000) .keyBy(\"orderId\") val processed = orders .connect(pays) .process(new EnrichmentFunction) processed.getSideOutput[PayEvent](unmatchedPays).print() processed.getSideOutput[OrderEvent](unmatchedOrders).print() env.execute &#125; class EnrichmentFunction extends CoProcessFunction[ OrderEvent, PayEvent, (OrderEvent, PayEvent)] &#123; lazy val orderState: ValueState[OrderEvent] = getRuntimeContext .getState(new ValueStateDescriptor[OrderEvent](\"saved order\", classOf[OrderEvent])) lazy val payState: ValueState[PayEvent] = getRuntimeContext .getState(new ValueStateDescriptor[PayEvent](\"saved pay\", classOf[PayEvent])) override def processElement1( order: OrderEvent, context: CoProcessFunction[OrderEvent, PayEvent, (OrderEvent, PayEvent)]#Context, out: Collector[(OrderEvent, PayEvent)] ): Unit = &#123; val pay = payState.value() if (pay != null) &#123; payState.clear() out.collect((order, pay)) &#125; else &#123; orderState.update(order) // as soon as the watermark arrives, // we can stop waiting for the corresponding pay context.timerService .registerEventTimeTimer(order.eventTime.toLong * 1000) &#125; &#125; override def processElement2( pay: PayEvent, context: CoProcessFunction[OrderEvent, PayEvent,(OrderEvent, PayEvent)]#Context, out: Collector[(OrderEvent, PayEvent)] ): Unit = &#123; val order = orderState.value() if (order != null) &#123; orderState.clear() out.collect((order, pay)) &#125; else &#123; payState.update(pay) context .timerService .registerEventTimeTimer(pay.eventTime.toLong * 1000) &#125; &#125; override def onTimer( timestamp: Long, ctx: CoProcessFunction[OrderEvent, PayEvent, (OrderEvent, PayEvent)]#OnTimerContext, out: Collector[(OrderEvent, PayEvent)] ): Unit = &#123; if (payState.value != null) &#123; ctx.output(unmatchedPays, payState.value) payState.clear() &#125; if (orderState.value != null) &#123; ctx.output(unmatchedOrders, orderState.value) orderState.clear() &#125; &#125; &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"Runnable和Callable的区别","slug":"Runnable和Callable的区别","date":"2020-08-09T15:41:17.000Z","updated":"2020-08-09T15:45:48.297Z","comments":true,"path":"2020/08/09/Runnable和Callable的区别/","link":"","permalink":"https://masteryang4.github.io/2020/08/09/Runnable%E5%92%8CCallable%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Runnable和Callable的区别 Java多线程有两个重要的接口，Runnable和Callable，分别提供一个run方法和call方法，二者是有较大差异的。 1）Runnable提供run方法，无法通过throws抛出异常，所有CheckedException必须在run方法内部处理。 Callable提供call方法，直接抛出Exception异常。 2）Runnable的run方法无返回值， Callable的call方法提供返回值用来表示任务运行的结果 3）Runnable可以作为Thread构造器的参数，通过开启新的线程来执行，也可以通过线程池来执行。 而Callable只能通过线程池执行。 4）Runnable接口中的落地方法是call方法；Callable接口中的落地方法是run方法 参考： https://blog.csdn.net/mryang125/article/details/81878168","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"JUC","slug":"Java/JUC","permalink":"https://masteryang4.github.io/categories/Java/JUC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"JUC","slug":"JUC","permalink":"https://masteryang4.github.io/tags/JUC/"}]},{"title":"读书笔记节选一","slug":"读书笔记节选一","date":"2020-08-08T12:19:58.000Z","updated":"2020-08-08T12:20:53.671Z","comments":true,"path":"2020/08/08/读书笔记节选一/","link":"","permalink":"https://masteryang4.github.io/2020/08/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E8%8A%82%E9%80%89%E4%B8%80/","excerpt":"","text":"今天这个故事，关于人是如何废掉的。 1995年，美国旧金山举行过一个全球精英会议。500名政经精英在会上，为全球化的世界进行分析与规划。 大家一致认为： 1，八二定律真切地存在。 2，竞争会越来越激烈，而80%的人，将越来越贫穷，地位越来越下降，淘汰率也越来越高。 可是问题来了，这80%的loser，与其余20%的精英之间，必然存在冲突。 冲突如果剧烈，社会就会动荡。如何解决这一问题呢？ 布热津斯基就此提出了著名的“奶头乐”理论。 所谓奶头乐，就是指采取娱乐化、低智化、游戏化、低成本、轻易就能获取刺激性快乐的办法，卸除底层人口的不满。 所以，娱乐要越多越好，游戏要越普及越好，综艺与真人秀要随处可见，低智的、无逻辑的、甚至堪称脑残的偶像剧要一部接一部。 当这些东西触手可及，底层人就会安分下来，快乐地、毫无怨言地、无知无觉地继续贫穷，继续无所得，然后虚度一生。 这虽然是大洋彼岸的事件，但奶头乐的现象，在我们身边同样存在。 曾有人说过，给一个人一根网线，一个小房间，一个外卖电话，就足以毁了一个人。 因为，当一个人置身于充满感官刺激的娱乐、碎片化的信息和无规则的游戏中时，你的注意力全部被占据，时间全被消耗，你的欲望能轻易被满足，自律会一点一点丧失，意志力逐渐瘫软。 你不会再思考。也不再向往艰难的事业。你会恐惧挑战，恐惧前行。 你会在一个接一个的综艺中，在一坨又一坨的微博资讯里，一阵接一阵的低质量欢娱中，走向你的颓废。 王尔德说过一句话：“人生只有两种悲剧，一种是：一直得不到。另一种是：太容易得到。” 一直得不到，是为永生遗憾。 太容易得到，要么会变味（边际效用递减），要么会上瘾（沉溺于直接刺激）。无论哪一种，都绝非善事。 要知道，人真正能成长，取决于不断的自我挑战。 是明知很苦，仍然前行；明知不易，仍然投入。 当一个人不断突破，在杂乱的信息里分花错柳，在活色生香的影像中保持高强度自律，目标明确，遇山开路，遇水搭桥，终于在某一天，他获得“我真的做到了”的大高潮，这种高峰体验，会令他受益一生。 因为，这才是真正的幸福——努力过，实现过，我无悔。 第二个故事，关于多任务执行所带来的消耗。 一个熟人，也是写字的。 文笔好，细节把控一流，出过多篇爆文。倘若一直专注写下去，不说成为名作家，至少，凭借一支笔，也能活得体面又阔绰。 可惜，她同时做了太多事。 前天她在做教材编改；今天她在接待领导，陪饭陪酒陪唱歌，想在就职的工作里混上一官半职；又过几天，她说自己正在和老公疯狂撕逼，打得天翻地覆，鸡犬不宁；没多久，开始做公益，准备去贫困山区支教； 但这个决心没下几天，又变了，说要开直播，做网红，教人搭配衣服和化妆； 直播没做几天，又生出一事儿，说有朋友拉她入伙，一起干房产，决定以后也同时做房地产销售…… 就这样，她一份漂亮的成绩单也没有交出来。 几年过去了，我们早已经做出了或大或小的成就，只有她，仍然一无所成，甚至仍然赤贫。 是谁说，什么都做，就等于什么都没做。 人的精力是有限的。 假设精力总量是100，分在10个任务上，那就每个任务，都只能使上10%的精力与注意力。 这种低质的投入，当然带不来高回报。 而你还会一天到晚说：“好累啊，忙得没个停，也没赚到半个钱……” 为什么会这样？ 就因为，当举足轻重的一件事VS无足轻重的多数事，理智的人，都会选择前者。他们知道，只有将80%以上的精力，都投注在前者上，才会真正有成效，也会真正为自己带来收益。 冯仑曾经讲过一件事。 一个著名的企业，大家都眼睁睁地看着它走下坡路。曾经的业内标杆，如今成了大家的负面教材。曾经金光闪闪放光彩，如今黯然无光危机重重。 为什么会这样？ 因为老板的心散了。 为了资本，什么项目都开。这也做，那也做，主营项目停滞不前，结果哪个业务都没有精进。 企业如此，人也一样。 倘若你也不想穷忙而无所得，那么，谨记一条：用80%，甚至90%的精力，去做最最最最重要的那件事。 这样，才会带来真正的成长。 一个人的废掉，往往是悄无声息的。 它没有预警，也没有提示，但你反观自己，如果有如下症状，就应该警醒了： 一是太懒。懒于改变，懒于坚持。 二是太闲。将时间与注意力，都放在索取低密度的信息、瞬间回报的快感中。 三是太无逻辑。一旦做事，眉毛胡子一把抓，抓不到重点，也摸不清门路，光阴消耗，疲累不堪，一无所得。 如果你还喜欢找借口，推诿责任，不面对，不学习，不负责，那你就是行走的危险二字。 时代正在大洗牌。贪图“奶头乐”的人，会逐渐被淘汰。迷恋感官愉悦的人，会在睁眼时，发现自己已跟不上时代的滚滚车流。 如果你想活得更无愧此生，改变趁当下，学习趁此时。不要再敷衍自己。因为生命已在追问：“你，到底赋予我什么意义？” *作者：周冲，2015年离开体制，放弃公职，从事自由写作。新书《我更喜欢努力的自己》正在热卖中。微博：周冲周冲","categories":[{"name":"其他","slug":"其他","permalink":"https://masteryang4.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://masteryang4.github.io/tags/%E5%85%B6%E4%BB%96/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://masteryang4.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"flink系列11Table API 和 Flink SQL","slug":"flink系列11Table-API-和-Flink-SQL","date":"2020-07-02T03:51:53.000Z","updated":"2020-07-02T03:56:32.076Z","comments":true,"path":"2020/07/02/flink系列11Table-API-和-Flink-SQL/","link":"","permalink":"https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9711Table-API-%E5%92%8C-Flink-SQL/","excerpt":"","text":"Table API 和 Flink SQL整体介绍什么是 Table API 和 Flink SQLFlink本身是批流统一的处理框架，所以Table API和SQL，就是批流统一的上层处理API。目前功能尚未完善，处于活跃的开发阶段。 Table API是一套内嵌在Java和Scala语言中的查询API，它允许我们以非常直观的方式，组合来自一些关系运算符的查询（比如select、filter和join）。而对于Flink SQL，就是直接可以在代码中写SQL，来实现一些查询（Query）操作。Flink的SQL支持，基于实现了SQL标准的Apache Calcite（Apache开源SQL解析工具）。 无论输入是批输入还是流式输入，在这两套API中，指定的查询都具有相同的语义，得到相同的结果。 需要引入的依赖Table API和SQL需要引入的依赖有两个：planner和bridge。 xml12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-planner_2.11&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-table-api-scala-bridge_2.11&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt;&lt;/dependency&gt; flink-table-planner：planner计划器，是table API最主要的部分，提供了运行时环境和生成程序执行计划的planner； flink-table-api-scala-bridge：bridge桥接器，主要负责table API和 DataStream/DataSet API的连接支持，按照语言分java和scala。 这里的两个依赖，是IDE环境下运行需要添加的；如果是生产环境，lib目录下默认已经有了planner，就只需要有bridge就可以了。 当然，如果想使用用户自定义函数，或是跟kafka做连接，需要有一个SQL client，这个包含在flink-table-common里。 两种planner（old &amp; blink）的区别 批流统一：Blink将批处理作业，视为流式处理的特殊情况。所以，blink不支持表和DataSet之间的转换，批处理作业将不转换为DataSet应用程序，而是跟流处理一样，转换为DataStream程序来处理。 因为批流统一，Blink planner也不支持BatchTableSource，而使用有界的StreamTableSource代替。 Blink planner只支持全新的目录，不支持已弃用的ExternalCatalog。 旧planner和Blink planner的FilterableTableSource实现不兼容。旧的planner会把PlannerExpressions下推到filterableTableSource中，而blink planner则会把Expressions下推。 基于字符串的键值配置选项仅适用于Blink planner。 PlannerConfig在两个planner中的实现不同。 Blink planner会将多个sink优化在一个DAG中（仅在TableEnvironment上受支持，而在StreamTableEnvironment上不受支持）。而旧planner的优化总是将每一个sink放在一个新的DAG中，其中所有DAG彼此独立。 旧的planner不支持目录统计，而Blink planner支持。 API调用基本程序结构Table API 和 SQL 的程序结构，与流式处理的程序结构类似；也可以近似地认为有这么几步：首先创建执行环境，然后定义source、transform和sink。 具体操作流程如下： scala12345678910111213val tableEnv = ... // 创建表的执行环境// 创建一张表，用于读取数据tableEnv.connect(...).createTemporaryTable(\"inputTable\")// 注册一张表，用于把计算结果输出tableEnv.connect(...).createTemporaryTable(\"outputTable\")// 通过 Table API 查询算子，得到一张结果表val result = tableEnv.from(\"inputTable\").select(...)// 通过 SQL查询语句，得到一张结果表val sqlResult = tableEnv.sqlQuery(\"SELECT ... FROM inputTable ...\")// 将结果表写入输出表中result.insertInto(\"outputTable\") 创建表环境创建表环境最简单的方式，就是基于流处理执行环境，调create方法直接创建： scala1val tableEnv = StreamTableEnvironment.create(env) 表环境（TableEnvironment）是flink中集成Table API &amp; SQL的核心概念。它负责: 注册catalog 在内部 catalog 中注册表 执行 SQL 查询 注册用户自定义函数 将 DataStream 或 DataSet 转换为表 保存对 ExecutionEnvironment 或 StreamExecutionEnvironment 的引用 在创建TableEnv的时候，可以多传入一个EnvironmentSettings或者TableConfig参数，可以用来配置TableEnvironment的一些特性。 比如，配置老版本的流式查询（Flink-Streaming-Query）： scala1234567val settings = EnvironmentSettings .newInstance() .useOldPlanner() // 使用老版本planner .inStreamingMode() // 流处理模式 .build() val tableEnv = StreamTableEnvironment.create(env, settings) 基于老版本的批处理环境（Flink-Batch-Query）： scala12val batchEnv = ExecutionEnvironment.getExecutionEnvironmentval batchTableEnv = BatchTableEnvironment.create(batchEnv) 基于blink版本的流处理环境（Blink-Streaming-Query）： scala1234567val bsSettings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inStreamingMode() .build()val bsTableEnv = StreamTableEnvironment.create(env, bsSettings) 基于blink版本的批处理环境（Blink-Batch-Query）： scala123456val bbSettings = EnvironmentSettings .newInstance() .useBlinkPlanner() .inBatchMode().build() val bbTableEnv = TableEnvironment.create(bbSettings) 在Catalog中注册表表（Table）的概念TableEnvironment可以注册目录Catalog，并可以基于Catalog注册表。它会维护一个Catalog-Table表之间的map。 表（Table）是由一个“标识符”来指定的，由3部分组成：Catalog名、数据库（database）名和对象名（表名）。如果没有指定目录或数据库，就使用当前的默认值。 表可以是常规的（Table，表），或者虚拟的（View，视图）。常规表（Table）一般可以用来描述外部数据，比如文件、数据库表或消息队列的数据，也可以直接从 DataStream转换而来。视图可以从现有的表中创建，通常是table API或者SQL查询的一个结果。 连接到文件系统（Csv格式）连接外部系统在Catalog中注册表，直接调用tableEnv.connect()就可以，里面参数要传入一个ConnectorDescriptor，也就是connector描述器。对于文件系统的connector而言，flink内部已经提供了，就叫做FileSystem()。 代码如下： scala12345678910tableEnv .connect(new FileSystem().path(\"sensor.txt\")) // 定义表数据来源，外部连接 .withFormat(new OldCsv()) // 定义从外部系统读取数据之后的格式化方法 .withSchema( new Schema() .field(\"id\", DataTypes.STRING()) .field(\"timestamp\", DataTypes.BIGINT()) .field(\"temperature\", DataTypes.DOUBLE()) ) // 定义表结构 .createTemporaryTable(\"inputTable\") // 创建临时表 这是旧版本的csv格式描述器。由于它是非标的，跟外部系统对接并不通用，所以将被弃用，以后会被一个符合RFC-4180标准的新format描述器取代。新的描述器就叫Csv()，但flink没有直接提供，需要引入依赖flink-csv： xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-csv&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt;&lt;/dependency&gt; 代码非常类似，只需要把withFormat里的OldCsv改成Csv就可以了。 连接到Kafkakafka的连接器flink-kafka-connector中，1.10版本的已经提供了Table API的支持。我们可以在 connect方法中直接传入一个叫做Kafka的类，这就是kafka连接器的描述器ConnectorDescriptor。 scala12345678910111213141516tableEnv .connect( new Kafka() .version(\"0.11\") // 定义kafka的版本 .topic(\"sensor\") // 定义主题 .property(\"zookeeper.connect\", \"localhost:2181\") .property(\"bootstrap.servers\", \"localhost:9092\") ) .withFormat(new Csv()) .withSchema( new Schema() .field(\"id\", DataTypes.STRING()) .field(\"timestamp\", DataTypes.BIGINT()) .field(\"temperature\", DataTypes.DOUBLE()) ) .createTemporaryTable(\"kafkaInputTable\") 当然也可以连接到ElasticSearch、MySql、HBase、Hive等外部系统，实现方式基本上是类似的。 表的查询利用外部系统的连接器connector，我们可以读写数据，并在环境的Catalog中注册表。接下来就可以对表做查询转换了。 Flink给我们提供了两种查询方式：Table API和 SQL。 Table API的调用Table API是集成在Scala和Java语言内的查询API。与SQL不同，Table API的查询不会用字符串表示，而是在宿主语言中一步一步调用完成的。 Table API基于代表一张“表”的Table类，并提供一整套操作处理的方法API。这些方法会返回一个新的Table对象，这个对象就表示对输入表应用转换操作的结果。有些关系型转换操作，可以由多个方法调用组成，构成链式调用结构。例如table.select(…).filter(…)，其中select（…）表示选择表中指定的字段，filter(…)表示筛选条件。 代码中的实现如下： scala12345val sensorTable: Table = tableEnv.from(\"inputTable\")val resultTable: Table = senorTable .select(\"id, temperature\") .filter(\"id ='sensor_1'\") SQL查询Flink的SQL集成，基于的是Apache Calcite，它实现了SQL标准。在Flink中，用常规字符串来定义SQL查询语句。SQL 查询的结果，是一个新的 Table。 代码实现如下： scala12val resultSqlTable: Table = tableEnv .sqlQuery(\"select id, temperature from inputTable where id ='sensor_1'\") 或者： scala123456val resultSqlTable: Table = tableEnv.sqlQuery( \"\"\" |select id, temperature |from inputTable |where id = 'sensor_1' \"\"\".stripMargin) 当然，也可以加上聚合操作，比如我们统计每个sensor温度数据出现的个数，做个count统计： scala123val aggResultTable = sensorTable .groupBy('id) .select('id, 'id.count as 'count) SQL的实现： scala12val aggResultSqlTable = tableEnv .sqlQuery(\"select id, count(id) as cnt from inputTable group by id\") 这里Table API里指定的字段，前面加了一个单引号&#39;，这是Table API中定义的Expression类型的写法，可以很方便地表示一个表中的字段。 字段可以直接全部用双引号引起来，也可以用半边单引号+字段名的方式。以后的代码中，一般都用后一种形式。 将DataStream转换成表Flink允许我们把Table和DataStream做转换：我们可以基于一个DataStream，先流式地读取数据源，然后map成样例类，再把它转成Table。Table的列字段（column fields），就是样例类里的字段，这样就不用再麻烦地定义schema了。 代码表达代码中实现非常简单，直接用tableEnv.fromDataStream()就可以了。默认转换后的 Table schema 和 DataStream 中的字段定义一一对应，也可以单独指定出来。 这就允许我们更换字段的顺序、重命名，或者只选取某些字段出来，相当于做了一次map操作（或者Table API的 select操作）。 代码具体如下： scala12345678910val inputStream: DataStream[String] = env.readTextFile(\"sensor.txt\")val dataStream: DataStream[SensorReading] = inputStream .map(data =&gt; &#123; val dataArray = data.split(\",\") SensorReading(dataArray(0), dataArray(1).toLong, dataArray(2).toDouble) &#125;)val sensorTable: Table = tableEnv.fromDataStream(dataStream)val sensorTable2 = tableEnv.fromDataStream(dataStream, 'id, 'timestamp as 'ts) 数据类型与Table schema的对应在上节的例子中，DataStream 中的数据类型，与表的 Schema 之间的对应关系，是按照样例类中的字段名来对应的（name-based mapping），所以还可以用as做重命名。 另外一种对应方式是，直接按照字段的位置来对应（position-based mapping），对应的过程中，就可以直接指定新的字段名了。 基于名称的对应： scala12val sensorTable = tableEnv .fromDataStream(dataStream, 'timestamp as 'ts, 'id as 'myId, 'temperature) 基于位置的对应： scala12val sensorTable = tableEnv .fromDataStream(dataStream, 'myId, 'ts) Flink的DataStream和 DataSet API支持多种类型。 组合类型，比如元组（内置Scala和Java元组）、POJO、Scala case类和Flink的Row类型等，允许具有多个字段的嵌套数据结构，这些字段可以在Table的表达式中访问。其他类型，则被视为原子类型。 元组类型和原子类型，一般用位置对应会好一些；如果非要用名称对应，也是可以的： 元组类型，默认的名称是 “_1”, “_2”；而原子类型，默认名称是 ”f0”。 创建临时视图（Temporary View）创建临时视图的第一种方式，就是直接从DataStream转换而来。同样，可以直接对应字段转换；也可以在转换的时候，指定相应的字段。 代码如下： scala123tableEnv.createTemporaryView(\"sensorView\", dataStream)tableEnv.createTemporaryView(\"sensorView\", dataStream, 'id, 'temperature, 'timestamp as 'ts) 另外，当然还可以基于Table创建视图： scala1tableEnv.createTemporaryView(\"sensorView\", sensorTable) View和Table的Schema完全相同。事实上，在Table API中，可以认为View和Table是等价的。 输出表表的输出，是通过将数据写入 TableSink 来实现的。TableSink 是一个通用接口，可以支持不同的文件格式、存储数据库和消息队列。 具体实现，输出表最直接的方法，就是通过 Table.insertInto() 方法将一个 Table 写入注册过的 TableSink 中。 输出到文件代码如下： scala12345678910111213// 注册输出表tableEnv.connect( new FileSystem().path(\"…\\\\resources\\\\out.txt\") ) // 定义到文件系统的连接 .withFormat(new Csv()) // 定义格式化方法，Csv格式 .withSchema( new Schema() .field(\"id\", DataTypes.STRING()) .field(\"temp\", DataTypes.DOUBLE()) ) // 定义表结构 .createTemporaryTable(\"outputTable\") // 创建临时表resultSqlTable.insertInto(\"outputTable\") 更新模式（Update Mode）在流处理过程中，表的处理并不像传统定义的那样简单。 对于流式查询（Streaming Queries），需要声明如何在（动态）表和外部连接器之间执行转换。与外部系统交换的消息类型，由更新模式（update mode）指定。 Flink Table API中的更新模式有以下三种： 追加模式（Append Mode） 在追加模式下，表（动态表）和外部连接器只交换插入（Insert）消息。 撤回模式（Retract Mode） 在撤回模式下，表和外部连接器交换的是：添加（Add）和撤回（Retract）消息。 插入（Insert）会被编码为添加消息； 删除（Delete）则编码为撤回消息； 更新（Update）则会编码为，已更新行（上一行）的撤回消息，和更新行（新行）的添加消息。 在此模式下，不能定义key，这一点跟upsert模式完全不同。 Upsert（更新插入）模式 在Upsert模式下，动态表和外部连接器交换Upsert和Delete消息。 这个模式需要一个唯一的key，通过这个key可以传递更新消息。为了正确应用消息，外部连接器需要知道这个唯一key的属性。 插入（Insert）和更新（Update）都被编码为Upsert消息； 删除（Delete）编码为Delete信息。 这种模式和Retract模式的主要区别在于，Update操作是用单个消息编码的，所以效率会更高。 输出到Kafka除了输出到文件，也可以输出到Kafka。我们可以结合前面Kafka作为输入数据，构建数据管道，kafka进，kafka出。 代码如下： scala1234567891011121314151617// 输出到 kafkatableEnv.connect( new Kafka() .version(\"0.11\") .topic(\"sinkTest\") .property(\"zookeeper.connect\", \"localhost:2181\") .property(\"bootstrap.servers\", \"localhost:9092\") ) .withFormat(new Csv()) .withSchema( new Schema() .field(\"id\", DataTypes.STRING()) .field(\"temp\", DataTypes.DOUBLE()) ) .createTemporaryTable(\"kafkaOutputTable\") resultTable.insertInto(\"kafkaOutputTable\") 输出到ElasticSearchElasticSearch的connector可以在upsert（update+insert，更新插入）模式下操作，这样就可以使用Query定义的键（key）与外部系统交换UPSERT/DELETE消息。 另外，对于“仅追加”（append-only）的查询，connector还可以在append 模式下操作，这样就可以与外部系统只交换insert消息。 es目前支持的数据格式，只有Json，而flink本身并没有对应的支持，所以还需要引入依赖： xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-json&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt;&lt;/dependency&gt; 代码实现如下： scala123456789101112131415161718// 输出到estableEnv.connect( new Elasticsearch() .version(\"6\") .host(\"localhost\", 9200, \"http\") .index(\"sensor\") .documentType(\"temp\") ) .inUpsertMode() // 指定是 Upsert 模式 .withFormat(new Json()) .withSchema( new Schema() .field(\"id\", DataTypes.STRING()) .field(\"count\", DataTypes.BIGINT()) ) .createTemporaryTable(\"esOutputTable\") aggResultTable.insertInto(\"esOutputTable\") 输出到MySqlFlink专门为Table API的jdbc连接提供了flink-jdbc连接器，我们需要先引入依赖： xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-jdbc_2.11&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt;&lt;/dependency&gt; jdbc连接的代码实现比较特殊，因为没有对应的java/scala类实现ConnectorDescriptor，所以不能直接tableEnv.connect()。不过Flink SQL留下了执行DDL的接口：tableEnv.sqlUpdate()。 对于jdbc的创建表操作，天生就适合直接写DDL来实现，所以我们的代码可以这样写： scala123456789101112131415161718// 输出到 Mysqlval sinkDDL: String = \"\"\" |create table jdbcOutputTable ( | id varchar(20) not null, | cnt bigint not null |) with ( | 'connector.type' = 'jdbc', | 'connector.url' = 'jdbc:mysql://localhost:3306/test', | 'connector.table' = 'sensor_count', | 'connector.driver' = 'com.mysql.jdbc.Driver', | 'connector.username' = 'root', | 'connector.password' = '123456' |) \"\"\".stripMargintableEnv.sqlUpdate(sinkDDL)aggResultSqlTable.insertInto(\"jdbcOutputTable\") 将表转换成DataStream表可以转换为DataStream或DataSet。这样，自定义流处理或批处理程序就可以继续在 Table API或SQL查询的结果上运行了。 将表转换为DataStream或DataSet时，需要指定生成的数据类型，即要将表的每一行转换成的数据类型。通常，最方便的转换类型就是Row。当然，因为结果的所有字段类型都是明确的，我们也经常会用元组类型来表示。 表作为流式查询的结果，是动态更新的。所以，将这种动态查询转换成的数据流，同样需要对表的更新操作进行编码，进而有不同的转换模式。 Table API中表到DataStream有两种模式： 追加模式（Append Mode） 用于表只会被插入（Insert）操作更改的场景。 撤回模式（Retract Mode） 用于任何场景。有些类似于更新模式中Retract模式，它只有Insert和Delete两类操作。 得到的数据会增加一个Boolean类型的标识位（返回的第一个字段），用它来表示到底是新增的数据（Insert），还是被删除的数据（老数据，Delete）。 代码实现如下： scala12345678val resultStream: DataStream[Row] = tableEnv .toAppendStream[Row](resultTable)val aggResultStream: DataStream[(Boolean, (String, Long))] = tableEnv .toRetractStream[(String, Long)](aggResultTable)resultStream.print(\"result\")aggResultStream.print(\"aggResult\") 所以，没有经过groupby之类聚合操作，可以直接用toAppendStream来转换；而如果经过了聚合，有更新操作，一般就必须用toRetractDstream。 Query的解释和执行Table API提供了一种机制来解释（Explain）计算表的逻辑和优化查询计划。这是通过TableEnvironment.explain（table）方法或TableEnvironment.explain（）方法完成的。 explain方法会返回一个字符串，描述三个计划： 未优化的逻辑查询计划 优化后的逻辑查询计划 实际执行计划 我们可以在代码中查看执行计划： scala12val explaination: String = tableEnv.explain(resultTable)println(explaination) Query的解释和执行过程，老planner和blink planner大体是一致的，又有所不同。整体来讲，Query都会表示成一个逻辑查询计划，然后分两步解释： 优化查询计划 解释成 DataStream 或者 DataSet程序 而Blink版本是批流统一的，所以所有的Query，只会被解释成DataStream程序；另外在批处理环境TableEnvironment下，Blink版本要到tableEnv.execute()执行调用才开始解释。 流处理中的特殊概念Table API和SQL，本质上还是基于关系型表的操作方式；而关系型表、关系代数，以及SQL本身，一般是有界的，更适合批处理的场景。这就导致在进行流处理的过程中，理解会稍微复杂一些，需要引入一些特殊概念。 流处理和关系代数（表，及SQL）的区别 关系代数（表）/SQL 流处理 处理的数据对象 字段元组的有界集合 字段元组的无限序列 查询（Query）对数据的访问 可以访问到完整的数据输入 无法访问所有数据，必须持续等待流式输入 查询终止条件 生成固定大小的结果集后终止 永不停止，根据持续收到的数据不断更新查询结果 可以看到，其实关系代数（主要就是指关系型数据库中的表）和SQL，主要就是针对批处理的，这和流处理有天生的隔阂。 动态表（Dynamic Tables）因为流处理面对的数据，是连续不断的，这和我们熟悉的关系型数据库中保存的“表”完全不同。所以，如果我们把流数据转换成Table，然后执行类似于table的select操作，结果就不是一成不变的，而是随着新数据的到来，会不停更新。 我们可以随着新数据的到来，不停地在之前的基础上更新结果。这样得到的表，在Flink Table API概念里，就叫做“动态表”（Dynamic Tables）。 动态表是Flink对流数据的Table API和SQL支持的核心概念。与表示批处理数据的静态表不同，动态表是随时间变化的。动态表可以像静态的批处理表一样进行查询，查询一个动态表会产生持续查询（Continuous Query）。连续查询永远不会终止，并会生成另一个动态表。查询（Query）会不断更新其动态结果表，以反映其动态输入表上的更改。 流式持续查询的过程下图显示了流、动态表和连续查询的关系： 流式持续查询的过程为： 流被转换为动态表。 对动态表计算连续查询，生成新的动态表。 生成的动态表被转换回流。 将流转换成表（Table）为了处理带有关系查询的流，必须先将其转换为表。 从概念上讲，流的每个数据记录，都被解释为对结果表的插入（Insert）修改。因为流式持续不断的，而且之前的输出结果无法改变。本质上，我们其实是从一个、只有插入操作的changelog（更新日志）流，来构建一个表。 为了更好地说明动态表和持续查询的概念，我们来举一个具体的例子。 比如，我们现在的输入数据，就是用户在网站上的访问行为，数据类型（Schema）如下： 12345&#123; user: VARCHAR, // 用户名 cTime: TIMESTAMP, // 访问某个URL的时间戳 url: VARCHAR // 用户访问的URL&#125; 下图显示了如何将访问URL事件流，或者叫点击事件流（左侧）转换为表（右侧）。 随着插入更多的访问事件流记录，生成的表将不断增长。 持续查询（Continuous Query）持续查询，会在动态表上做计算处理，并作为结果生成新的动态表。与批处理查询不同，连续查询从不终止，并根据输入表上的更新更新其结果表。 在任何时间点，连续查询的结果在语义上，等同于在输入表的快照上，以批处理模式执行的同一查询的结果。 在下面的示例中，我们展示了对点击事件流中的一个持续查询。 这个Query很简单，是一个分组聚合做count统计的查询。它将用户字段上的clicks表分组，并统计访问的url数。图中显示了随着时间的推移，当clicks表被其他行更新时如何计算查询。 将动态表转换成流与常规的数据库表一样，动态表可以通过插入（Insert）、更新（Update）和删除（Delete）更改，进行持续的修改。将动态表转换为流或将其写入外部系统时，需要对这些更改进行编码。Flink的Table API和SQL支持三种方式对动态表的更改进行编码： 仅追加（Append-only）流 仅通过插入（Insert）更改，来修改的动态表，可以直接转换为“仅追加”流。这个流中发出的数据，就是动态表中新增的每一行。 撤回（Retract）流 Retract流是包含两类消息的流，添加（Add）消息和撤回（Retract）消息。 动态表通过将INSERT 编码为add消息、DELETE 编码为retract消息、UPDATE编码为被更改行（前一行）的retract消息和更新后行（新行）的add消息，转换为retract流。 下图显示了将动态表转换为Retract流的过程。 Upsert（更新插入）流 Upsert流包含两种类型的消息：Upsert消息和delete消息。转换为upsert流的动态表，需要有唯一的键（key）。 通过将INSERT和UPDATE更改编码为upsert消息，将DELETE更改编码为DELETE消息，就可以将具有唯一键（Unique Key）的动态表转换为流。 下图显示了将动态表转换为upsert流的过程。 这些概念我们之前都已提到过。需要注意的是，在代码里将动态表转换为DataStream时，仅支持Append和Retract流。而向外部系统输出动态表的TableSink接口，则可以有不同的实现，比如之前我们讲到的ES，就可以有Upsert模式。 时间特性基于时间的操作（比如Table API和SQL中窗口操作），需要定义相关的时间语义和时间数据来源的信息。所以，Table可以提供一个逻辑上的时间字段，用于在表处理程序中，指示时间和访问相应的时间戳。 时间属性，可以是每个表schema的一部分。一旦定义了时间属性，它就可以作为一个字段引用，并且可以在基于时间的操作中使用。 时间属性的行为类似于常规时间戳，可以访问，并且进行计算。 处理时间（Processing Time）处理时间语义下，允许表处理程序根据机器的本地时间生成结果。它是时间的最简单概念。它既不需要提取时间戳，也不需要生成watermark。 定义处理时间属性有三种方法：在DataStream转化时直接指定；在定义Table Schema时指定；在创建表的DDL中指定。 DataStream转化成Table时指定 由DataStream转换成表时，可以在后面指定字段名来定义Schema。在定义Schema期间，可以使用.proctime，定义处理时间字段。 注意，这个proctime属性只能通过附加逻辑字段，来扩展物理schema。因此，只能在schema定义的末尾定义它。 代码如下： scala1234567891011// 定义好 DataStreamval inputStream: DataStream[String] = env.readTextFile(\"\\\\sensor.txt\")val dataStream: DataStream[SensorReading] = inputStream .map(data =&gt; &#123; val dataArray = data.split(\",\") SensorReading(dataArray(0), dataArray(1).toLong, dataArray(2).toDouble) &#125;)// 将 DataStream转换为 Table，并指定时间字段val sensorTable = tableEnv .fromDataStream(dataStream, 'id, 'temperature, 'timestamp, 'pt.proctime) 定义Table Schema时指定 这种方法其实也很简单，只要在定义Schema的时候，加上一个新的字段，并指定成proctime就可以了。 代码如下： scala12345678910111213tableEnv .connect( new FileSystem().path(\"..\\\\sensor.txt\")) .withFormat(new Csv()) .withSchema( new Schema() .field(\"id\", DataTypes.STRING()) .field(\"timestamp\", DataTypes.BIGINT()) .field(\"temperature\", DataTypes.DOUBLE()) .field(\"pt\", DataTypes.TIMESTAMP(3)) .proctime() // 指定 pt字段为处理时间 ) // 定义表结构 .createTemporaryTable(\"inputTable\") // 创建临时表 创建表的DDL中指定 在创建表的DDL中，增加一个字段并指定成proctime，也可以指定当前的时间字段。 代码如下： scala123456789101112131415val sinkDDL: String = \"\"\" |create table dataTable ( | id varchar(20) not null, | ts bigint, | temperature double, | pt AS PROCTIME() |) with ( | 'connector.type' = 'filesystem', | 'connector.path' = 'file:///D:\\\\..\\\\sensor.txt', | 'format.type' = 'csv' |) \"\"\".stripMargintableEnv.sqlUpdate(sinkDDL) // 执行 DDL 注意：运行这段DDL，必须使用Blink Planner。 事件时间（Event Time）事件时间语义，允许表处理程序根据每个记录中包含的时间生成结果。这样即使在有乱序事件或者延迟事件时，也可以获得正确的结果。 为了处理无序事件，并区分流中的准时和迟到事件；Flink需要从事件数据中，提取时间戳，并用来推进事件时间的进展（watermark）。 DataStream转化成Table时指定 在DataStream转换成Table，schema的定义期间，使用.rowtime可以定义事件时间属性。注意，必须在转换的数据流中分配时间戳和watermark。 在将数据流转换为表时，有两种定义时间属性的方法。根据指定的.rowtime字段名是否存在于数据流的架构中，timestamp字段可以： 作为新字段追加到schema 替换现有字段 在这两种情况下，定义的事件时间戳字段，都将保存DataStream中事件时间戳的值。 代码如下： scala1234567891011121314val inputStream: DataStream[String] = env.readTextFile(\"\\\\sensor.txt\")val dataStream: DataStream[SensorReading] = inputStream .map(data =&gt; &#123; val dataArray = data.split(\",\") SensorReading(dataArray(0), dataArray(1).toLong, dataArray(2).toDouble) &#125;) .assignAscendingTimestamps(_.timestamp * 1000L)// 将 DataStream转换为 Table，并指定时间字段val sensorTable = tableEnv .fromDataStream(dataStream, 'id, 'timestamp.rowtime, 'temperature)// 或者，直接追加字段val sensorTable2 = tableEnv .fromDataStream(dataStream, 'id, 'temperature, 'timestamp, 'rt.rowtime) 定义Table Schema时指定 这种方法只要在定义Schema的时候，将事件时间字段，并指定成rowtime就可以了。 代码如下： scala123456789101112131415tableEnv .connect(new FileSystem().path(\"sensor.txt\")) .withFormat(new Csv()) .withSchema( new Schema() .field(\"id\", DataTypes.STRING()) .field(\"timestamp\", DataTypes.BIGINT()) .rowtime( new Rowtime() .timestampsFromField(\"timestamp\") // 从字段中提取时间戳 .watermarksPeriodicBounded(1000) // watermark延迟1秒 ) .field(\"temperature\", DataTypes.DOUBLE()) ) // 定义表结构 .createTemporaryTable(\"inputTable\") // 创建临时表 创建表的DDL中指定 事件时间属性，是使用CREATE TABLE DDL中的WARDMARK语句定义的。watermark语句，定义现有事件时间字段上的watermark生成表达式，该表达式将事件时间字段标记为事件时间属性。 代码如下： scala12345678910111213141516val sinkDDL: String = \"\"\" |create table dataTable ( | id varchar(20) not null, | ts bigint, | temperature double, | rt AS TO_TIMESTAMP( FROM_UNIXTIME(ts) ), | watermark for rt as rt - interval '1' second |) with ( | 'connector.type' = 'filesystem', | 'connector.path' = 'file:///D:\\\\..\\\\sensor.txt', | 'format.type' = 'csv' |) \"\"\".stripMargintableEnv.sqlUpdate(sinkDDL) // 执行 DDL 这里FROM_UNIXTIME是系统内置的时间函数，用来将一个整数（秒数）转换成“YYYY-MM-DD hh:mm:ss”格式（默认，也可以作为第二个String参数传入）的日期时间字符串（date time string）；然后再用TO_TIMESTAMP将其转换成Timestamp。 窗口（Windows）时间语义，要配合窗口操作才能发挥作用。最主要的用途，当然就是开窗口、根据时间段做计算了。下面我们就来看看Table API和SQL中，怎么利用时间字段做窗口操作。 在Table API和SQL中，主要有两种窗口：Group Windows和Over Windows 分组窗口（Group Windows）分组窗口（Group Windows）会根据时间或行计数间隔，将行聚合到有限的组（Group）中，并对每个组的数据执行一次聚合函数。 Table API中的Group Windows都是使用.window（w:GroupWindow）子句定义的，并且必须由as子句指定一个别名。为了按窗口对表进行分组，窗口的别名必须在group by子句中，像常规的分组字段一样引用。 scala1234val table = input .window([w: GroupWindow] as 'w) // 定义窗口，别名 w .groupBy('w, 'a) // 以属性a和窗口w作为分组的key .select('a, 'b.sum) // 聚合字段b的值，求和 或者，还可以把窗口的相关信息，作为字段添加到结果表中： scala1234val table = input .window([w: GroupWindow] as 'w) .groupBy('w, 'a) .select('a, 'w.start, 'w.end, 'w.rowtime, 'b.count) Table API提供了一组具有特定语义的预定义Window类，这些类会被转换为底层DataStream或DataSet的窗口操作。 Table API支持的窗口定义，和我们熟悉的一样，主要也是三种：滚动（Tumbling）、滑动（Sliding）和会话（Session）。 滚动窗口滚动窗口（Tumbling windows）要用Tumble类来定义，另外还有三个方法： over：定义窗口长度 on：用来分组（按时间间隔）或者排序（按行数）的时间字段 as：别名，必须出现在后面的groupBy中 代码如下： scala123456// Tumbling Event-time Window（事件时间字段rowtime.window(Tumble over 10.minutes on 'rowtime as 'w)// Tumbling Processing-time Window（处理时间字段proctime）.window(Tumble over 10.minutes on 'proctime as 'w)// Tumbling Row-count Window (类似于计数窗口，按处理时间排序，10行一组).window(Tumble over 10.rows on 'proctime as 'w) 滑动窗口滑动窗口（Sliding windows）要用Slide类来定义，另外还有四个方法： over：定义窗口长度 every：定义滑动步长 on：用来分组（按时间间隔）或者排序（按行数）的时间字段 as：别名，必须出现在后面的groupBy中 代码如下： scala123456// Sliding Event-time Window.window(Slide over 10.minutes every 5.minutes on 'rowtime as 'w)// Sliding Processing-time window.window(Slide over 10.minutes every 5.minutes on 'proctime as 'w)// Sliding Row-count window.window(Slide over 10.rows every 5.rows on 'proctime as 'w) 会话窗口会话窗口（Session windows）要用Session类来定义，另外还有三个方法： withGap：会话时间间隔 on：用来分组（按时间间隔）或者排序（按行数）的时间字段 as：别名，必须出现在后面的groupBy中 代码如下： scala1234// Session Event-time Window.window(Session withGap 10.minutes on 'rowtime as 'w)// Session Processing-time Window.window(Session withGap 10.minutes on 'proctime as 'w) Over WindowsOver window聚合是标准SQL中已有的（Over子句），可以在查询的SELECT子句中定义。Over window 聚合，会针对每个输入行，计算相邻行范围内的聚合。Over windows使用.window（w:overwindows*）子句定义，并在select()方法中通过别名来引用。 比如这样： scala123val table = input .window([w: OverWindow] as 'w) .select('a, 'b.sum over 'w, 'c.min over 'w) Table API提供了Over类，来配置Over窗口的属性。可以在事件时间或处理时间，以及指定为时间间隔、或行计数的范围内，定义Over windows。 无界的over window是使用常量指定的。也就是说，时间间隔要指定UNBOUNDED_RANGE，或者行计数间隔要指定UNBOUNDED_ROW。而有界的over window是用间隔的大小指定的。 实际代码应用如下： 无界的 over window scala12345678// 无界的事件时间over window (时间字段 \"rowtime\").window(Over partitionBy 'a orderBy 'rowtime preceding UNBOUNDED_RANGE as 'w)//无界的处理时间over window (时间字段\"proctime\").window(Over partitionBy 'a orderBy 'proctime preceding UNBOUNDED_RANGE as 'w)// 无界的事件时间Row-count over window (时间字段 \"rowtime\").window(Over partitionBy 'a orderBy 'rowtime preceding UNBOUNDED_ROW as 'w)//无界的处理时间Row-count over window (时间字段 \"rowtime\").window(Over partitionBy 'a orderBy 'proctime preceding UNBOUNDED_ROW as 'w) 有界的over window scala12345678// 有界的事件时间over window (时间字段 \"rowtime\"，之前1分钟).window(Over partitionBy 'a orderBy 'rowtime preceding 1.minutes as 'w)// 有界的处理时间over window (时间字段 \"rowtime\"，之前1分钟).window(Over partitionBy 'a orderBy 'proctime preceding 1.minutes as 'w)// 有界的事件时间Row-count over window (时间字段 \"rowtime\"，之前10行).window(Over partitionBy 'a orderBy 'rowtime preceding 10.rows as 'w)// 有界的处理时间Row-count over window (时间字段 \"rowtime\"，之前10行).window(Over partitionBy 'a orderBy 'proctime preceding 10.rows as 'w) SQL中窗口的定义我们已经了解了在Table API里window的调用方式，同样，我们也可以在SQL中直接加入窗口的定义和使用。 Group WindowsGroup Windows在SQL查询的Group BY子句中定义。与使用常规GROUP BY子句的查询一样，使用GROUP BY子句的查询会计算每个组的单个结果行。 SQL支持以下Group窗口函数: TUMBLE(time_attr, interval) 定义一个滚动窗口，第一个参数是时间字段，第二个参数是窗口长度。 HOP(time_attr, interval, interval) 定义一个滑动窗口，第一个参数是时间字段，第二个参数是窗口滑动步长，第三个是窗口长度。 SESSION(time_attr, interval) 定义一个会话窗口，第一个参数是时间字段，第二个参数是窗口间隔（Gap）。 另外还有一些辅助函数，可以用来选择Group Window的开始和结束时间戳，以及时间属性。 这里只写TUMBLE_，滑动和会话窗口是类似的（HOP_，SESSION_*）。 TUMBLE_START(time_attr, interval) TUMBLE_END(time_attr, interval) TUMBLE_ROWTIME(time_attr, interval) TUMBLE_PROCTIME(time_attr, interval) Over Windows由于Over本来就是SQL内置支持的语法，所以这在SQL中属于基本的聚合操作。所有聚合必须在同一窗口上定义，也就是说，必须是相同的分区、排序和范围。目前仅支持在当前行范围之前的窗口（无边界和有边界）。 注意，ORDER BY必须在单一的时间属性上指定。 代码如下： sql12345678910111213SELECT COUNT(amount) OVER ( PARTITION BY user ORDER BY proctime ROWS BETWEEN 2 PRECEDING AND CURRENT ROW)FROM Orders// 也可以做多个聚合SELECT COUNT(amount) OVER w, SUM(amount) OVER wFROM OrdersWINDOW w AS ( PARTITION BY user ORDER BY proctime ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) 代码练习（以分组滚动窗口为例）我们可以综合学习过的内容，用一段完整的代码实现一个具体的需求。例如，可以开一个滚动窗口，统计10秒内出现的每个sensor的个数。 代码如下： scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val streamFromFile: DataStream[String] = env.readTextFile(\"sensor.txt\") val dataStream: DataStream[SensorReading] = streamFromFile .map( data =&gt; &#123; val dataArray = data.split(\",\") SensorReading(dataArray(0).trim, dataArray(1).trim.toLong, dataArray(2).trim.toDouble) &#125;) .assignTimestampsAndWatermarks( new BoundedOutOfOrdernessTimestampExtractor[SensorReading]( Time.seconds(1) ) &#123; override def extractTimestamp( element: SensorReading ): Long = element.timestamp * 1000L &#125;) val settings: EnvironmentSettings = EnvironmentSettings .newInstance() .useOldPlanner() .inStreamingMode() .build() val tableEnv: StreamTableEnvironment = StreamTableEnvironment .create(env, settings) val dataTable: Table = tableEnv .fromDataStream(dataStream, 'id, 'temperature, 'timestamp.rowtime) val resultTable: Table = dataTable .window(Tumble over 10.seconds on 'timestamp as 'tw) .groupBy('id, 'tw) .select('id, 'id.count) val sqlDataTable: Table = dataTable .select('id, 'temperature, 'timestamp as 'ts) val resultSqlTable: Table = tableEnv .sqlQuery(\"select id, count(id) from \" + sqlDataTable + \" group by id,tumble(ts,interval '10' second)\") // 把 Table转化成数据流 val resultDstream: DataStream[(Boolean, (String, Long))] = resultSqlTable .toRetractStream[(String, Long)] resultDstream.filter(_._1).print() env.execute()&#125; 函数（Functions）Flink Table 和 SQL内置了很多SQL中支持的函数；如果有无法满足的需要，则可以实现用户自定义的函数（UDF）来解决。 系统内置函数Flink Table API 和 SQL为用户提供了一组用于数据转换的内置函数。SQL中支持的很多函数，Table API和SQL都已经做了实现，其它还在快速开发扩展中。 以下是一些典型函数的举例，全部的内置函数，可以参考官网介绍。 比较函数 SQL： value1 = value2 value1 &gt; value2 Table API： ANY1 === ANY2 ANY1 &gt; ANY2 逻辑函数 SQL： boolean1 OR boolean2 boolean IS FALSE NOT boolean Table API： BOOLEAN1 || BOOLEAN2 BOOLEAN.isFalse !BOOLEAN 算术函数 SQL： numeric1 + numeric2 POWER(numeric1, numeric2) Table API： NUMERIC1 + NUMERIC2 NUMERIC1.power(NUMERIC2) 字符串函数 SQL： string1 || string2 UPPER(string) CHAR_LENGTH(string) Table API： STRING1 + STRING2 STRING.upperCase() STRING.charLength() 时间函数 SQL： DATE string TIMESTAMP string CURRENT_TIME INTERVAL string range Table API： STRING.toDate STRING.toTimestamp currentTime() NUMERIC.days NUMERIC.minutes 聚合函数 SQL： COUNT(*) SUM([ ALL | DISTINCT ] expression) RANK() ROW_NUMBER() Table API： FIELD.count FIELD.sum0 UDF用户定义函数（User-defined Functions，UDF）是一个重要的特性，因为它们显著地扩展了查询（Query）的表达能力。一些系统内置函数无法解决的需求，我们可以用UDF来自定义实现。 注册用户自定义函数UDF在大多数情况下，用户定义的函数必须先注册，然后才能在查询中使用。不需要专门为Scala 的Table API注册函数。 函数通过调用registerFunction（）方法在TableEnvironment中注册。当用户定义的函数被注册时，它被插入到TableEnvironment的函数目录中，这样Table API或SQL解析器就可以识别并正确地解释它。 标量函数（Scalar Functions）用户定义的标量函数，可以将0、1或多个标量值，映射到新的标量值。 为了定义标量函数，必须在org.apache.flink.table.functions中扩展基类Scalar Function，并实现（一个或多个）求值（evaluation，eval）方法。标量函数的行为由求值方法决定，求值方法必须公开声明并命名为eval（直接def声明，没有override）。求值方法的参数类型和返回类型，确定了标量函数的参数和返回类型。 在下面的代码中，我们定义自己的HashCode函数，在TableEnvironment中注册它，并在查询中调用它。 scala123456// 自定义一个标量函数class HashCode( factor: Int ) extends ScalarFunction &#123; def eval( s: String ): Int = &#123; s.hashCode * factor &#125;&#125; 主函数中调用，计算sensor id的哈希值（前面部分照抄，流环境、表环境、读取source、建表）： scala123456789101112131415161718192021222324252627282930313233343536373839404142import org.apache.flink.streaming.api.scala.StreamExecutionEnvironmentimport org.apache.flink.api.scala._import org.apache.flink.table.api.&#123;EnvironmentSettings, Tumble&#125;import org.apache.flink.table.api.scala._import org.apache.flink.table.functions.ScalarFunctionobject TableUDFExample1 &#123; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment val settings = EnvironmentSettings.newInstance() .useBlinkPlanner() .inStreamingMode() .build() val tEnv = StreamTableEnvironment.create(env, settings) env.setParallelism(1) val stream = env.addSource(new SensorSource) val hashCode = new HashCode(10) tEnv.registerFunction(\"hashCode\", new HashCode(10)) val table = tEnv.fromDataStream(stream, 'id) // table api 写法 table .select('id, hashCode('id)) .toAppendStream[(String, Int)] .print() // sql 写法 tEnv.createTemporaryView(\"t\", table, 'id) tEnv .sqlQuery(\"SELECT id, hashCode(id) FROM t\") .toAppendStream[(String, Int)] .print() env.execute() &#125; class HashCode(factor: Int) extends ScalarFunction &#123; def eval(s: String): Int = &#123; s.hashCode() * factor &#125; &#125; &#125; 表函数（Table Functions）与用户定义的标量函数类似，用户定义的表函数，可以将0、1或多个标量值作为输入参数；与标量函数不同的是，它可以返回任意数量的行作为输出，而不是单个值。 为了定义一个表函数，必须扩展org.apache.flink.table.functions中的基类TableFunction并实现（一个或多个）求值方法。表函数的行为由其求值方法决定，求值方法必须是public的，并命名为eval。求值方法的参数类型，决定表函数的所有有效参数。 返回表的类型由TableFunction的泛型类型确定。求值方法使用protected collect（T）方法发出输出行。 在Table API中，Table函数需要与.joinLateral或.leftOuterJoinLateral一起使用。 joinLateral算子，会将外部表中的每一行，与表函数（TableFunction，算子的参数是它的表达式）计算得到的所有行连接起来。 而leftOuterJoinLateral算子，则是左外连接，它同样会将外部表中的每一行与表函数计算生成的所有行连接起来；并且，对于表函数返回的是空表的外部行，也要保留下来。 在SQL中，则需要使用Lateral Table（），或者带有ON TRUE条件的左连接。 下面的代码中，我们将定义一个表函数，在表环境中注册它，并在查询中调用它。 自定义TableFunction： scala12345678// 自定义TableFunctionclass Split(separator: String) extends TableFunction[(String, Int)]&#123; def eval(str: String): Unit = &#123; str.split(separator).foreach( word =&gt; collect((word, word.length)) ) &#125;&#125; 接下来，就是在代码中调用。首先是Table API的方式： scala12345678910111213// Table API中调用，需要用joinLateralval resultTable = sensorTable .joinLateral(split('id) as ('word, 'length)) // as对输出行的字段重命名 .select('id, 'word, 'length) // 或者用leftOuterJoinLateralval resultTable2 = sensorTable .leftOuterJoinLateral(split('id) as ('word, 'length)) .select('id, 'word, 'length) // 转换成流打印输出resultTable.toAppendStream[Row].print(\"1\")resultTable2.toAppendStream[Row].print(\"2\") 然后是SQL的方式： scala123456789101112131415161718192021222324tableEnv.createTemporaryView(\"sensor\", sensorTable)tableEnv.registerFunction(\"split\", split)val resultSqlTable = tableEnv.sqlQuery( \"\"\" |select id, word, length |from |sensor, LATERAL TABLE(split(id)) AS newsensor(word, length) \"\"\".stripMargin) // 或者用左连接的方式val resultSqlTable2 = tableEnv.sqlQuery( \"\"\" |SELECT id, word, length |FROM |sensor | LEFT JOIN | LATERAL TABLE(split(id)) AS newsensor(word, length) | ON TRUE \"\"\".stripMargin)// 转换成流打印输出resultSqlTable.toAppendStream[Row].print(\"1\")resultSqlTable2.toAppendStream[Row].print(\"2\") 聚合函数（Aggregate Functions）用户自定义聚合函数（User-Defined Aggregate Functions，UDAGGs）可以把一个表中的数据，聚合成一个标量值。用户定义的聚合函数，是通过继承AggregateFunction抽象类实现的。 上图中显示了一个聚合的例子。 假设现在有一张表，包含了各种饮料的数据。该表由三列（id、name和price）、五行组成数据。现在我们需要找到表中所有饮料的最高价格，即执行max（）聚合，结果将是一个数值。 AggregateFunction的工作原理如下。 首先，它需要一个累加器，用来保存聚合中间结果的数据结构（状态）。可以通过调用AggregateFunction的createAccumulator（）方法创建空累加器。 随后，对每个输入行调用函数的accumulate（）方法来更新累加器。 处理完所有行后，将调用函数的getValue（）方法来计算并返回最终结果。 AggregationFunction要求必须实现的方法： createAccumulator() accumulate() getValue() 除了上述方法之外，还有一些可选择实现的方法。其中一些方法，可以让系统执行查询更有效率，而另一些方法，对于某些场景是必需的。例如，如果聚合函数应用在会话窗口（session group window）的上下文中，则merge（）方法是必需的。 retract() merge() resetAccumulator() 接下来我们写一个自定义AggregateFunction，计算一下每个sensor的平均温度值。 scala12345678910111213141516// 定义AggregateFunction的Accumulatorclass AvgTempAcc &#123; var sum: Double = 0.0 var count: Int = 0&#125;class AvgTemp extends AggregateFunction[Double, AvgTempAcc] &#123; override def getValue(accumulator: AvgTempAcc): Double = accumulator.sum / accumulator.count override def createAccumulator(): AvgTempAcc = new AvgTempAcc def accumulate(accumulator: AvgTempAcc, temp: Double): Unit =&#123; accumulator.sum += temp accumulator.count += 1 &#125;&#125; 接下来就可以在代码中调用了。 scala1234567891011121314151617181920212223// 创建一个聚合函数实例val avgTemp = new AvgTemp()// Table API的调用val resultTable = sensorTable .groupBy('id) .aggregate(avgTemp('temperature) as 'avgTemp) .select('id, 'avgTemp) // SQL的实现tableEnv.createTemporaryView(\"sensor\", sensorTable)tableEnv.registerFunction(\"avgTemp\", avgTemp)val resultSqlTable = tableEnv.sqlQuery( \"\"\" |SELECT |id, avgTemp(temperature) |FROM |sensor |GROUP BY id \"\"\".stripMargin) // 转换成流打印输出resultTable.toRetractStream[(String, Double)].print(\"agg temp\")resultSqlTable.toRetractStream[Row].print(\"agg temp sql\") 表聚合函数（Table Aggregate Functions）用户定义的表聚合函数（User-Defined Table Aggregate Functions，UDTAGGs），可以把一个表中数据，聚合为具有多行和多列的结果表。这跟AggregateFunction非常类似，只是之前聚合结果是一个标量值，现在变成了一张表。 比如现在我们需要找到表中所有饮料的前2个最高价格，即执行top2()表聚合。我们需要检查5行中的每一行，得到的结果将是一个具有排序后前2个值的表。 用户定义的表聚合函数，是通过继承TableAggregateFunction抽象类来实现的。 TableAggregateFunction的工作原理如下。 首先，它同样需要一个累加器（Accumulator），它是保存聚合中间结果的数据结构。通过调用TableAggregateFunction的createAccumulator()方法可以创建空累加器。 随后，对每个输入行调用函数的accumulate()方法来更新累加器。 处理完所有行后，将调用函数的emitValue()方法来计算并返回最终结果。 AggregationFunction要求必须实现的方法： createAccumulator() accumulate() 除了上述方法之外，还有一些可选择实现的方法。 retract() merge() resetAccumulator() emitValue() emitUpdateWithRetract() 接下来我们写一个自定义TableAggregateFunction，用来提取每个sensor最高的两个温度值。 scala12345678910111213141516171819202122232425// 先定义一个 Accumulatorclass Top2TempAcc&#123; var highestTemp: Double = Int.MinValue var secondHighestTemp: Double = Int.MinValue&#125;// 自定义 TableAggregateFunctionclass Top2Temp extends TableAggregateFunction[(Double, Int), Top2TempAcc]&#123; override def createAccumulator(): Top2TempAcc = new Top2TempAcc def accumulate(acc: Top2TempAcc, temp: Double): Unit =&#123; if( temp &gt; acc.highestTemp )&#123; acc.secondHighestTemp = acc.highestTemp acc.highestTemp = temp &#125; else if( temp &gt; acc.secondHighestTemp )&#123; acc.secondHighestTemp = temp &#125; &#125; def emitValue(acc: Top2TempAcc, out: Collector[(Double, Int)]): Unit =&#123; out.collect(acc.highestTemp, 1) out.collect(acc.secondHighestTemp, 2) &#125;&#125; 接下来就可以在代码中调用了。 scala1234567891011// 创建一个表聚合函数实例val top2Temp = new Top2Temp()// Table API的调用val resultTable = sensorTable .groupBy('id) .flatAggregate( top2Temp('temperature) as ('temp, 'rank) ) .select('id, 'temp, 'rank) // 转换成流打印输出resultTable.toRetractStream[(String, Double, Int)].print(\"agg temp\")resultSqlTable.toRetractStream[Row].print(\"agg temp sql\") 使用Table API结合SQL实现TopN需求scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.ysss.project.topnhotitemsimport java.sql.Timestampimport com.ysss.project.util.UserBehaviorimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.scala.StreamExecutionEnvironmentimport org.apache.flink.api.scala._import org.apache.flink.table.api.&#123;EnvironmentSettings, Tumble&#125;import org.apache.flink.table.api.scala._object HotItemsTable &#123; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment // 有关Blink的配置，样板代码 val settings = EnvironmentSettings.newInstance() .useBlinkPlanner() .inStreamingMode() .build() // 创建流式表的环境 val tEnv = StreamTableEnvironment.create(env, settings) env.setParallelism(1) // 使用事件时间 env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) // 过滤出pv事件，并抽取时间戳 val stream = env .readTextFile(\"`UserBehavior.csv`的绝对路径\") .map(line =&gt; &#123; val arr = line.split(\",\") UserBehavior(arr(0).toLong, arr(1).toLong, arr(2).toInt, arr(3), arr(4).toLong * 1000) &#125;) .filter(_.behavior == \"pv\") .assignAscendingTimestamps(_.timestamp) // 从流中提取两个字段，时间戳；itemId，组成一张表 val table = tEnv.fromDataStream(stream, 'timestamp.rowtime, 'itemId) val t = table .window(Tumble over 60.minutes on 'timestamp as 'w) // 一小时滚动窗口 .groupBy('itemId, 'w) // 根据itemId和窗口进行分组 .aggregate('itemId.count as 'icount) // 对itemId进行计数 .select('itemId, 'icount, 'w.end as 'windowEnd) // 查询三个字段 .toAppendStream[(Long, Long, Timestamp)] // 转换成DataStream // 创建临时表 tEnv.createTemporaryView(\"topn\", t, 'itemId, 'icount, 'windowEnd) // topN查询，Blink支持的特性 val result = tEnv.sqlQuery( \"\"\" |SELECT * |FROM ( | SELECT *, | ROW_NUMBER() OVER | (PARTITION BY windowEnd ORDER BY icount DESC) as row_num | FROM topn) |WHERE row_num &lt;= 5 |\"\"\".stripMargin ) // 使用toRetractStream转换成DataStream，用来实时更新排行榜 // true代表insert, false代表delete result.toRetractStream[(Long, Long, Timestamp, Long)].print() env.execute() &#125;&#125; 只使用Flink SQL实现TopN需求代码 scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.sql.Timestampimport com.ysss.project.util.UserBehaviorimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.scala.StreamExecutionEnvironmentimport org.apache.flink.api.scala._import org.apache.flink.table.api.&#123;EnvironmentSettings, Tumble&#125;import org.apache.flink.table.api.scala._object HotItemsSQL &#123; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment val settings = EnvironmentSettings.newInstance() .useBlinkPlanner() .inStreamingMode() .build() val tEnv = StreamTableEnvironment.create(env, settings) env.setParallelism(1) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val stream = env .readTextFile(\"`UserBehavior.csv`的绝对路径\") .map(line =&gt; &#123; val arr = line.split(\",\") UserBehavior(arr(0).toLong, arr(1).toLong, arr(2).toInt, arr(3), arr(4).toLong * 1000) &#125;) .filter(_.behavior == \"pv\") .assignAscendingTimestamps(_.timestamp) tEnv.createTemporaryView(\"t\", stream, 'itemId, 'timestamp.rowtime as 'ts) val result = tEnv.sqlQuery( \"\"\" |SELECT * |FROM ( | SELECT *, | ROW_NUMBER() OVER | (PARTITION BY windowEnd ORDER BY icount DESC) as row_num | FROM | (SELECT count(itemId) as icount, | TUMBLE_START(ts, INTERVAL '1' HOUR) as windowEnd | FROM t GROUP BY TUMBLE(ts, INTERVAL '1' HOUR), itemId) topn) |WHERE row_num &lt;= 5 |\"\"\".stripMargin ) result.toRetractStream[(Long, Timestamp, Long)].print() env.execute() &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列10Flink CEP简介","slug":"flink系列10Flink-CEP简介","date":"2020-07-02T03:50:56.000Z","updated":"2020-07-02T03:51:39.762Z","comments":true,"path":"2020/07/02/flink系列10Flink-CEP简介/","link":"","permalink":"https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9710Flink-CEP%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Flink CEP简介什么是复杂事件CEP？ 一个或多个由简单事件构成的事件流通过一定的规则匹配，然后输出用户想得到的数据，满足规则的复杂事件。 特征： 目标：从有序的简单事件流中发现一些高阶特征 输入：一个或多个由简单事件构成的事件流 处理：识别简单事件之间的内在联系，多个符合一定规则的简单事件构成复杂事件 输出：满足规则的复杂事件 CEP用于分析低延迟、频繁产生的不同来源的事件流。CEP可以帮助在复杂的、不相关的事件流中找出有意义的模式和复杂的关系，以接近实时或准实时的获得通知并阻止一些行为。 CEP支持在流上进行模式匹配，根据模式的条件不同，分为连续的条件或不连续的条件；模式的条件允许有时间的限制，当在条件范围内没有达到满足的条件时，会导致模式匹配超时。 看起来很简单，但是它有很多不同的功能： 输入的流数据，尽快产生结果 在2个event流上，基于时间进行聚合类的计算 提供实时/准实时的警告和通知 在多样的数据源中产生关联并分析模式 高吞吐、低延迟的处理 市场上有多种CEP的解决方案，例如Spark、Samza、Beam等，但他们都没有提供专门的library支持。但是Flink提供了专门的CEP library。 Flink CEP Flink为CEP提供了专门的Flink CEP library，它包含如下组件： Event Stream pattern定义 pattern检测 生成Alert 首先，开发人员要在DataStream流上定义出模式条件，之后Flink CEP引擎进行模式检测，必要时生成告警。 为了使用Flink CEP，我们需要导入依赖： xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-cep-scala_$&#123;scala.binary.version&#125;&lt;/artifactId&gt; &lt;version&gt;$&#123;flink.version&#125;&lt;/version&gt;&lt;/dependency&gt; Event Streams 登录事件流 scala1234567891011121314151617case class LoginEvent(userId: String, ip: String, eventType: String, eventTime: String)val env = StreamExecutionEnvironment.getExecutionEnvironmentenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)env.setParallelism(1)val loginEventStream = env .fromCollection(List( LoginEvent(\"1\", \"192.168.0.1\", \"fail\", \"1558430842\"), LoginEvent(\"1\", \"192.168.0.2\", \"fail\", \"1558430843\"), LoginEvent(\"1\", \"192.168.0.3\", \"fail\", \"1558430844\"), LoginEvent(\"2\", \"192.168.10.10\", \"success\", \"1558430845\") )) .assignAscendingTimestamps(_.eventTime.toLong * 1000) Pattern API 每个Pattern都应该包含几个步骤，或者叫做state。从一个state到另一个state，通常我们需要定义一些条件，例如下列的代码： scala12345val loginFailPattern = Pattern.begin[LoginEvent](\"begin\") .where(_.eventType.equals(\"fail\")) .next(\"next\") .where(_.eventType.equals(\"fail\")) .within(Time.seconds(10) 每个state都应该有一个标示： 例如: .begin[LoginEvent](&quot;begin&quot;)中的“begin” 每个state都需要有一个唯一的名字，而且需要一个filter来过滤条件，这个过滤条件定义事件需要符合的条件 例如: .where(_.eventType.equals(&quot;fail&quot;)) 我们也可以通过subtype来限制event的子类型： scala1start.subtype(SubEvent.class).where(...); 事实上，你可以多次调用subtype和where方法；而且如果where条件是不相关的，你可以通过or来指定一个单独的filter函数： scala1pattern.where(...).or(...); 之后，我们可以在此条件基础上，通过next或者followedBy方法切换到下一个state，next的意思是说上一步符合条件的元素之后紧挨着的元素；而followedBy并不要求一定是挨着的元素。这两者分别称为严格近邻和非严格近邻。 scala12val strictNext = start.next(\"middle\")val nonStrictNext = start.followedBy(\"middle\") 最后，我们可以将所有的Pattern的条件限定在一定的时间范围内： scala1next.within(Time.seconds(10)) 这个时间可以是Processing Time，也可以是Event Time。 Pattern 检测 通过一个input DataStream以及刚刚我们定义的Pattern，我们可以创建一个PatternStream： scala12345678val input = ...val pattern = ...val patternStream = CEP.pattern(input, pattern)val patternStream = CEP .pattern( loginEventStream.keyBy(_.userId), loginFailPattern ) 一旦获得PatternStream，我们就可以通过select或flatSelect，从一个Map序列找到我们需要的告警信息。 select select方法需要实现一个PatternSelectFunction，通过select方法来输出需要的警告。它接受一个Map对，包含string/event，其中key为state的名字，event则为真是的Event。 scala1234567val loginFailDataStream = patternStream .select((pattern: Map[String, Iterable[LoginEvent]]) =&gt; &#123; val first = pattern.getOrElse(\"begin\", null).iterator.next() val second = pattern.getOrElse(\"next\", null).iterator.next() (second.userId, second.ip, second.eventType) &#125;) 其返回值仅为1条记录。 flatSelect 通过实现PatternFlatSelectFunction，实现与select相似的功能。唯一的区别就是flatSelect方法可以返回多条记录。 超时事件的处理 通过within方法，我们的parttern规则限定在一定的窗口范围内。当有超过窗口时间后还到达的event，我们可以通过在select或flatSelect中，实现PatternTimeoutFunction/PatternFlatTimeoutFunction来处理这种情况。 scala12345678910111213141516val complexResult = patternStream.select(orderTimeoutOutput) &#123; (pattern: Map[String, Iterable[OrderEvent]], timestamp: Long) =&gt; &#123; val createOrder = pattern.get(\"begin\") OrderTimeoutEvent(createOrder.get.iterator.next().orderId, \"timeout\") &#125;&#125; &#123; pattern: Map[String, Iterable[OrderEvent]] =&gt; &#123; val payOrder = pattern.get(\"next\") OrderTimeoutEvent(payOrder.get.iterator.next().orderId, \"success\") &#125;&#125;val timeoutResult = complexResult.getSideOutput(orderTimeoutOutput)complexResult.print()timeoutResult.print() 完整例子: scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.apache.flink.cep.scala.CEPimport org.apache.flink.cep.scala.pattern.Patternimport org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.scala._import org.apache.flink.streaming.api.windowing.time.Timeimport scala.collection.Mapobject ScalaFlinkLoginFail &#123; def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) env.setParallelism(1) val loginEventStream = env.fromCollection(List( LoginEvent(\"1\", \"192.168.0.1\", \"fail\", \"1558430842\"), LoginEvent(\"1\", \"192.168.0.2\", \"fail\", \"1558430843\"), LoginEvent(\"1\", \"192.168.0.3\", \"fail\", \"1558430844\"), LoginEvent(\"2\", \"192.168.10.10\", \"success\", \"1558430845\") )).assignAscendingTimestamps(_.eventTime.toLong) val loginFailPattern = Pattern.begin[LoginEvent](\"begin\") .where(_.eventType.equals(\"fail\")) .next(\"next\") .where(_.eventType.equals(\"fail\")) .within(Time.seconds(10)) val patternStream = CEP.pattern( loginEventStream.keyBy(_.userId), loginFailPattern ) val loginFailDataStream = patternStream .select((pattern: Map[String, Iterable[LoginEvent]]) =&gt; &#123; val first = pattern.getOrElse(\"begin\", null).iterator.next() val second = pattern.getOrElse(\"next\", null).iterator.next() (second.userId, second.ip, second.eventType) &#125;) loginFailDataStream.print env.execute &#125;&#125;case class LoginEvent(userId: String, ip: String, eventType: String, eventTime: String)","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列09搭建Flink运行流式应用","slug":"flink系列09搭建Flink运行流式应用","date":"2020-07-02T03:49:55.000Z","updated":"2020-07-02T03:50:41.204Z","comments":true,"path":"2020/07/02/flink系列09搭建Flink运行流式应用/","link":"","permalink":"https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9709%E6%90%AD%E5%BB%BAFlink%E8%BF%90%E8%A1%8C%E6%B5%81%E5%BC%8F%E5%BA%94%E7%94%A8/","excerpt":"","text":"第九章，搭建Flink运行流式应用部署方式standalone集群standalone集群包含至少一个master进程，以及至少一个TaskManager进程，TaskManager进程运行在一台或者多台机器上。所有的进程都是JVM进程。下图展示了standalone集群的部署。 master进程在不同的线程中运行了一个Dispatcher和一个ResourceManager。一旦它们开始运行，所有TaskManager都将在Resourcemanager中进行注册。下图展示了一个任务如何提交到一个standalone集群中去。 客户端向Dispatcher提交了一个任务，Dispatcher将会启动一个JobManager线程，并提供执行所需的JobGraph。JobManager向ResourceManager请求必要的task slots。一旦请求的slots分配好，JobManager就会部署job。 在standalone这种部署方式中，master和worker进程在失败以后，并不会自动重启。如果有足够的slots可供使用，job是可以从一次worker失败中恢复的。只要我们运行多个worker就好了。但如果job想从master失败中恢复的话，则需要进行高可用(HA)的配置了。 部署步骤 下载压缩包 链接：http://mirror.bit.edu.cn/apache/flink/flink-1.10.1/flink-1.10.1-bin-scala_2.11.tgz 解压缩 Code1$ tar xvfz flink-1.10.1-bin-scala_2.11.tgz 启动集群 Code12$ cd flink-1.10.0$ .&#x2F;bin&#x2F;start-cluster.sh 检查集群状态可以访问：http://localhost:8081 部署分布式集群 所有运行TaskManager的机器的主机名（或者IP地址）都需要写入./conf/slaves文件中。 start-cluster.sh脚本需要所有机器的无密码的SSH登录配置，方便启动TaskManager进程。 Flink的文件夹在所有的机器上都需要有相同的绝对路径。 运行master进程的机器的主机名或者IP地址需要写在./conf/flink-conf.yaml文件的jobmanager.rpc.address配置项。 一旦部署好，我们就可以调用./bin/start-cluster.sh命令启动集群了，脚本会在本地机器启动一个JobManager，然后在每个slave机器上启动一个TaskManager。停止运行，请使用./bin/stop-cluster.sh。 Apache Hadoop YarnYARN是Apache Hadoop的资源管理组件。用来计算集群环境所需要的CPU和内存资源，然后提供给应用程序请求的资源。 Flink在YARN上运行，有两种模式：job模式和session模式。在job模式中，Flink集群用来运行一个单独的job。一旦job结束，Flink集群停止，并释放所有资源。下图展示了Flink的job如何提交到YARN集群。 当客户端提交任务时，客户端将建立和YARN ResourceManager的连接，然后启动一个新的YARN应用的master进程，进程中包含一个JobManager线程和一个ResourceManager。JobManager向ResourceManager请求所需要的slots，用来运行Flink的job。接下来，Flink的ResourceManager将向Yarn的ResourceManager请求容器，然后启动TaskManager进程。一旦启动，TaskManager会将slots注册在Flink的ResourceManager中，Flink的ResourceManager将把slots提供给JobManager。最终，JobManager把job的任务提交给TaskManager执行。 sesison模式将启动一个长期运行的Flink集群，这个集群可以运行多个job，需要手动停止集群。如果以session模式启动，Flink将会连接到YARN的ResourceManager，然后启动一个master进程，包括一个Dispatcher线程和一个Flink的ResourceManager的线程。下图展示了一个Flink YARN session的启动。 当一个job被提交运行，Dispatcher将启动一个JobManager线程，这个线程将向Flink的ResourceManager请求所需要的slots。如果没有足够的slots，Flink的ResourceManager将向YARN的ResourceManager请求额外的容器，来启动TaskManager进程，并在Flink的ResourceManager中注册。一旦所需slots可用，Flink的ResourceManager将吧slots分配给JobManager，然后开始执行job。下图展示了job如何在session模式下执行。 无论是作业模式还是会话模式，Flink的ResourceManager都会自动对故障的TaskManager进行重启。你可以通过./conf/flink-conf.yaml配置文件来控制Flink在YARN上的故障恢复行为。例如，可以配置有多少容器发生故障后终止应用。 无论使用job模式还是sesison模式，都需要能够访问Hadoop。 job模式可以用以下命令来提交任务： Code1$ .&#x2F;bin&#x2F;flink run -m yarn-cluster .&#x2F;path&#x2F;to&#x2F;job.jar 参数-m用来定义提交作业的目标主机。如果加上关键字&quot;yarn-cluster&quot;，客户端会将作业提交到由Hadoop配置所指定的YARN集群上。Flink的CLI客户端还支持很多参数，例如用于控制TaskManager容器内存大小的参数等。有关它们的详细信息，请参阅文档。Flink集群的Web UI由YARN集群某个节点上的主进程负责提供。你可以通过YARN的Web UI对其进行访问，具体链接位置在“Tracking URL: ApplicationMaster”下的Application Overview页面上。 session模式则是 Code12$ .&#x2F;bin&#x2F;yarn-session.sh # 启动一个yarn会话$ .&#x2F;bin&#x2F;flink run .&#x2F;path&#x2F;to&#x2F;job.jar # 向会话提交作业 Flink的Web UI链接可以从YARN Web UI的Application Overview页面上找到。 高可用配置(HA)Flink的高可用配置需要Apache ZooKeeper组件，以及一个分布式文件系统，例如HDFS等等。JobManager将会把相关信息都存储在文件系统中，并将指向文件系统中相关信息的指针保存在ZooKeeper中。一旦失败，一个新的JobManager将从ZooKeeper中指向相关信息的指针所指向的文件系统中读取元数据，并恢复运行。 配置文件编写 Code12345678# REQUIRED: enable HA mode via ZooKeeper high-availability: zookeeper# REQUIRED: provide a list of all ZooKeeper servers of the quorumhigh-availability.zookeeper.quorum: address1:2181[,...],addressX:2181# REQUIRED: set storage location for job metadata in remote storagehigh-availability.storageDir: hdfs:&#x2F;&#x2F;&#x2F;flink&#x2F;recovery# RECOMMENDED: set the base path for all Flink clusters in ZooKeeper.# Isolates Flink from other frameworks using the ZooKeeper cluster.high-availability.zookeeper.path.root: &#x2F;flink standalone集群高可用配置需要在配置文件中加一行集群标识符信息，因为可能多个集群共用一个zookeeper服务。 Code1234# RECOMMENDED: set the path for the Flink cluster in ZooKeeper.# Isolates multiple Flink clusters from each other.# The cluster id is required to look up the metadata of a failed cluster.high-availability.cluster-id: &#x2F;cluster-1 yarn集群高可用配置首先在yarn集群的配置文件yarn-site.xml中加入以下代码 xml12345678&lt;property&gt; &lt;name&gt;yarn.resourcemanager.am.max-attempts&lt;/name&gt; &lt;value&gt;4&lt;/value&gt; &lt;description&gt; The maximum number of application master execution attempts. Default value is 2, i.e., an application is restarted at most once. &lt;/description&gt;&lt;/property&gt; 然后在./conf/flink-conf.yaml加上 Code123# Restart an application at most 3 times (+ the initial start).# Must be less or equal to the configured maximum number of attempts.yarn.application-attempts: 4 与Hadoop集成推荐两种方法 下载包含hadoop的Flink版本。 使用我们之前下载的Flink，然后配置Hadoop的环境变量。 export HADOOP_CLASSPATH={hadoop classpath} 我们还需要提供Hadoop配置文件的路径。只需设置名为HADOOP_CONF_DIR的环境变量就可以了。这样Flink就能够连上YARN的ResourceManager和HDFS了。 保存点操作Code1$ .&#x2F;bin&#x2F;flink savepoint &lt;jobId&gt; [savepointPath] 例如 Code1234567$ .&#x2F;bin&#x2F;flink savepoint bc0b2ad61ecd4a615d92ce25390f61ad \\hdfs:&#x2F;&#x2F;&#x2F;xxx:50070&#x2F;savepointsTriggering savepoint for job bc0b2ad61ecd4a615d92ce25390f61ad.Waiting for response...Savepoint completed. Path: hdfs:&#x2F;&#x2F;&#x2F;xxx:50070&#x2F;savepoints&#x2F;savepoint-bc0b2a-63cf5d5ccef8You can resume your program from this savepoint with the run command. 删除保存点文件 Code1$ .&#x2F;bin&#x2F;flink savepoint -d &lt;savepointPath&gt; 例子 Code12345$ .&#x2F;bin&#x2F;flink savepoint -d \\hdfs:&#x2F;&#x2F;&#x2F;xxx:50070&#x2F;savepoints&#x2F;savepoint-bc0b2a-63cf5d5ccef8Disposing savepoint &#39;hdfs:&#x2F;&#x2F;&#x2F;xxx:50070&#x2F;savepoints&#x2F;savepoint-bc0b2a-63cf5d5ccef8&#39;.Waiting for response...Savepoint &#39;hdfs:&#x2F;&#x2F;&#x2F;xxx:50070&#x2F;savepoints&#x2F;savepoint-bc0b2a-63cf5d5ccef8&#39; disposed. 取消一个应用Code1$ .&#x2F;bin&#x2F;flink cancel &lt;jobId&gt; 取消的同时做保存点操作 Code1$ .&#x2F;bin&#x2F;flink cancel -s [savepointPath] &lt;jobId&gt; 例如 Code123456$ .&#x2F;bin&#x2F;flink cancel -s \\hdfs:&#x2F;&#x2F;&#x2F;xxx:50070&#x2F;savepoints d5fdaff43022954f5f02fcd8f25ef855Cancelling job bc0b2ad61ecd4a615d92ce25390f61ad with savepoint to hdfs:&#x2F;&#x2F;&#x2F;xxx:50070&#x2F;savepoints.Cancelled job bc0b2ad61ecd4a615d92ce25390f61ad. Savepoint stored in hdfs:&#x2F;&#x2F;&#x2F;xxx:50070&#x2F;savepoints&#x2F;savepoint-bc0b2a-d08de07fbb10. 从保存点启动应用程序Code1$ .&#x2F;bin&#x2F;flink run -s &lt;savepointPath&gt; [options] &lt;jobJar&gt; [arguments] 扩容，改变并行度操作Code1$ .&#x2F;bin&#x2F;flink modify &lt;jobId&gt; -p &lt;newParallelism&gt; 例子 Code123$ .&#x2F;bin&#x2F;flink modify bc0b2ad61ecd4a615d92ce25390f61ad -p 16Modify job bc0b2ad61ecd4a615d92ce25390f61ad.Rescaled job bc0b2ad61ecd4a615d92ce25390f61ad. Its new parallelism is 16.","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列08读写外部系统","slug":"flink系列08读写外部系统","date":"2020-07-02T03:48:50.000Z","updated":"2020-07-02T03:49:41.161Z","comments":true,"path":"2020/07/02/flink系列08读写外部系统/","link":"","permalink":"https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9708%E8%AF%BB%E5%86%99%E5%A4%96%E9%83%A8%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"第八章，读写外部系统数据可以存储在不同的系统中，例如：文件系统，对象存储系统（OSS），关系型数据库，Key-Value存储，搜索引擎索引，日志系统，消息队列，等等。每一种系统都是给特定的应用场景设计的，在某一个特定的目标上超越了其他系统。今天的数据架构，往往包含着很多不同的存储系统。在将一个组件加入到我们的系统中时，我们需要问一个问题：“这个组件和架构中的其他组件能多好的一起工作？” 添加一个像Flink这样的数据处理系统，需要仔细的考虑。因为Flink没有自己的存储层，而是读取数据和持久化数据都需要依赖外部存储。所以，对于Flink，针对外部系统提供良好的读取和写入的连接器就很重要了。尽管如此，仅仅能够读写外部系统对于Flink这样想要提供任务故障情况下一致性保证的流处理器来讲，是不够的。 在本章中，我们将会讨论source和sink的连接器。这些连接器影响了Flink的一致性保证，也提供了对于最流行的一些外部系统的读写的连接器。我们还将学习如何实现自定义source和sink连接器，以及如何实现可以向外部系统发送异步读写请求的函数。 应用的一致性保证Flink的检查点和恢复机制定期的会保存应用程序状态的一致性检查点。在故障的情况下，应用程序的状态将会从最近一次完成的检查点恢复，并继续处理。尽管如此，可以使用检查点来重置应用程序的状态无法完全达到令人满意的一致性保证。相反，source和sink的连接器需要和Flink的检查点和恢复机制进行集成才能提供有意义的一致性保证。 为了给应用程序提供恰好处理一次语义的状态一致性保证，应用程序的source连接器需要能够将source的读位置重置到之前保存的检查点位置。当处理一次检查点时，source操作符将会把source的读位置持久化，并在恢复的时候从这些读位置开始重新读取。支持读位置的检查点的source连接器一般来说是基于文件的存储系统，如：文件流或者Kafka source（检查点会持久化某个正在消费的topic的读偏移量）。如果一个应用程序从一个无法存储和重置读位置的source连接器摄入数据，那么当任务出现故障的时候，数据就会丢失。也就是说我们只能提供at-most-once）的一致性保证。 Fink的检查点和恢复机制和可以重置读位置的source连接器结合使用，可以保证应用程序不会丢失任何数据。尽管如此，应用程序可能会发出两次计算结果，因为从上一次检查点恢复的应用程序所计算的结果将会被重新发送一次（一些结果已经发送出去了，这时任务故障，然后从上一次检查点恢复，这些结果将被重新计算一次然后发送出去）。所以，可重置读位置的source和Flink的恢复机制不足以提供端到端的恰好处理一次语义，即使应用程序的状态是恰好处理一次一致性级别。 一个志在提供端到端恰好处理一次语义一致性的应用程序需要特殊的sink连接器。sink连接器可以在不同的情况下使用两种技术来达到恰好处理一次一致性语义：幂等性写入和事务性写入。 幂等性写入一个幂等操作无论执行多少次都会返回同样的结果。例如，重复的向hashmap中插入同样的key-value对就是幂等操作，因为头一次插入操作之后所有的插入操作都不会改变这个hashmap，因为hashmap已经包含这个key-value对了。另一方面，append操作就不是幂等操作了，因为多次append同一个元素将会导致列表每次都会添加一个元素。在流处理程序中，幂等写入操作是很有意思的，因为幂等写入操作可以执行多次但不改变结果。所以它们可以在某种程度上缓和Flink检查点机制带来的重播计算结果的效应。 需要注意的是，依赖于幂等性sink来达到exactly-once语义的应用程序，必须保证在从检查点恢复以后，它将会覆盖之前已经写入的结果。例如，一个包含有sink操作的应用在sink到一个key-value存储时必须保证它能够确定的计算出将要更新的key值。同时，从Flink程序sink到的key-value存储中读取数据的应用，在Flink从检查点恢复的过程中，可能会看到不想看到的结果。当重播开始时，之前已经发出的计算结果可能会被更早的结果所覆盖（因为在恢复过程中）。所以，一个消费Flink程序输出数据的应用，可能会观察到时间回退，例如读到了比之前小的计数。也就是说，当流处理程序处于恢复过程中时，流处理程序的结果将处于不稳定的状态，因为一些结果被覆盖掉，而另一些结果还没有被覆盖。一旦重播完成，也就是说应用程序已经通过了之前出故障的点，结果将会继续保持一致性。 事务性写入第二种实现端到端的恰好处理一次一致性语义的方法基于事务性写入。其思想是只将最近一次成功保存的检查点之前的计算结果写入到外部系统中去。这样就保证了在任务故障的情况下，端到端恰好处理一次语义。应用将被重置到最近一次的检查点，而在这个检查点之后并没有向外部系统发出任何计算结果。通过只有当检查点保存完成以后再写入数据这种方法，事务性的方法将不会遭受幂等性写入所遭受的重播不一致的问题。尽管如此，事务性写入却带来了延迟，因为只有在检查点完成以后，我们才能看到计算结果。 Flink提供了两种构建模块来实现事务性sink连接器：write-ahead-log（WAL，预写式日志）sink和两阶段提交sink。WAL式sink将会把所有计算结果写入到应用程序的状态中，等接到检查点完成的通知，才会将计算结果发送到sink系统。因为sink操作会把数据都缓存在状态后段，所以WAL可以使用在任何外部sink系统上。尽管如此，WAL还是无法提供刀枪不入的恰好处理一次语义的保证，再加上由于要缓存数据带来的状态后段的状态大小的问题，WAL模型并不十分完美。 与之形成对比的，2PC sink需要sink系统提供事务的支持或者可以模拟出事务特性的模块。对于每一个检查点，sink开始一个事务，然后将所有的接收到的数据都添加到事务中，并将这些数据写入到sink系统，但并没有提交（commit）它们。当事务接收到检查点完成的通知时，事务将被commit，数据将被真正的写入sink系统。这项机制主要依赖于一次sink可以在检查点完成之前开始事务，并在应用程序从一次故障中恢复以后再commit的能力。 2PC协议依赖于Flink的检查点机制。检查点屏障是开始一个新的事务的通知，所有操作符自己的检查点成功的通知是它们可以commit的投票，而JobManager通知一个检查点成功的消息是commit事务的指令。于WAL sink形成对比的是，2PC sinks依赖于sink系统和sink本身的实现可以实现恰好处理一次语义。更多的，2PC sink不断的将数据写入到sink系统中，而WAL写模型就会有之前所述的问题。 不可重置的源 可重置的源 any sink at-most-once at-least-once 幂等性sink at-most-once exactly-once（当从任务失败中恢复时，存在暂时的不一致性） 预写式日志sink at-most-once at-least-once 2PC sink at-most-once exactly-once Flink提供的连接器Flink提供了读写很多存储系统的连接器。消息队列，日志系统，例如Apache Kafka, Kinesis, RabbitMQ等等这些是常用的数据源。在批处理环境中，数据流很可能是监听一个文件系统，而当新的数据落盘的时候，读取这些新数据。 在sink一端，数据流经常写入到消息队列中，以供接下来的流处理程序消费。数据流也可能写入到文件系统中做持久化，或者交给批处理程序来进行分析。数据流还可能被写入到key-value存储或者关系型数据库中，例如Cassandra，ElasticSearch或者MySQL中，这样数据可供查询，还可以在仪表盘中显示出来。 不幸的是，对于大多数存储系统并没有标准接口，除了针对DBMS的JDBC。相反，每一个存储系统都需要有自己的特定的连接器。所以，Flink需要维护针对不同存储系统（消息队列，日志系统，文件系统，k-v数据库，关系型数据库等等）的连接器实现。 Flink提供了针对Apache Kafka, Kinesis, RabbitMQ, Apache Nifi, 各种文件系统，Cassandra, Elasticsearch, 还有JDBC的连接器。除此之外，Apache Bahir项目还提供了额外的针对例如ActiveMQ, Akka, Flume, Netty, 和Redis等的连接器。 Apache Kafka Source连接器Apache Kafka是一个分布式流式平台。它的核心是一个分布式的发布订阅消息系统。 Kafka将事件流组织为所谓的topics。一个主题就是一个事件日志系统，Kafka可以保证主题中的数据在被读取时和这些数据在被写入时相同的顺序。为了扩大读写的规模，主题可以分裂为多个分区，这些分区分布在一个集群上面。这时，读写顺序的保证就限制到了分区这个粒度， Kafka并没有提供从不同分区读取数据时的顺序保证。Kafka分区的读位置称为偏移量（offset）。 Kafka的依赖引入如下： xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka_2.12&lt;/artifactId&gt; &lt;version&gt;1.7.1&lt;/version&gt;&lt;/dependency&gt; Flink Kafka连接器并行的摄入事件流。每一个并行source任务可以从一个或者多个分区中读取数据。任务将会跟踪每一个分区当前的读偏移量，然后将读偏移量写入到检查点数据中。当从任务故障恢复时，读偏移量将被恢复，而source任务将从检查点保存的读偏移量开始重新读取数据。Flink Kafka连接器并不依赖Kafka自己的offset-tracking机制（基于消费者组实现）。下图展示了分区如何分配给source实例。 Kafka source连接器使用如下代码创建 scala123456789val properties = new Properties()properties.setProperty(\"bootstrap.servers\", \"localhost:9092\")properties.setProperty(\"group.id\", \"test\")val stream: DataStream[String] = env.addSource( new FlinkKafkaConsumer[String]( \"topic\", new SimpleStringSchema(), properties)) 构造器接受三个参数。第一个参数定义了从哪些topic中读取数据，可以是一个topic，也可以是topic列表，还可以是匹配所有想要读取的topic的正则表达式。当从多个topic中读取数据时，Kafka连接器将会处理所有topic的分区，将这些分区的数据放到一条流中去。 第二个参数是一个DeserializationSchema或者KeyedDeserializationSchema。Kafka消息被存储为原始的字节数据，所以需要反序列化成Java或者Scala对象。上例中使用的SimpleStringSchema，是一个内置的DeserializationSchema，它仅仅是简单的将字节数组反序列化成字符串。DeserializationSchema和KeyedDeserializationSchema是公共的接口，所以我们可以自定义反序列化逻辑。 第三个参数是一个Properties对象，设置了用来读写的Kafka客户端的一些属性。 为了抽取事件时间的时间戳然后产生水印，我们可以通过调用 scala1FlinkKafkaConsumer.assignTimestampsAndWatermark() 方法为Kafka消费者提供AssignerWithPeriodicWatermark或者AssignerWithPucntuatedWatermark。每一个assigner都将被应用到每个分区，来利用每一个分区的顺序保证特性。source实例将会根据水印的传播协议聚合所有分区的水印。 Apache Kafka Sink连接器添加依赖： xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka_2.12&lt;/artifactId&gt; &lt;version&gt;1.7.1&lt;/version&gt;&lt;/dependency&gt; 下面的例子展示了如何创建一个Kafka sink scala12345678val stream: DataStream[String] = ...val myProducer = new FlinkKafkaProducer[String]( \"localhost:9092\", // broker list \"topic\", // target topic new SimpleStringSchema) // serialization schemastream.addSink(myProducer) Kakfa Sink的at-least-once保证Flink的Kafka sink提供了基于配置的一致性保证。Kafka sink使用下面的条件提供了至少处理一次保证： Flink检查点机制开启，所有的数据源都是可重置的。 当写入失败时，sink连接器将会抛出异常，使得应用程序挂掉然后重启。这是默认行为。应用程序内部的Kafka客户端还可以配置为重试写入，只要提前声明当写入失败时，重试几次这样的属性（retries property）。 sink连接器在完成它的检查点之前会等待Kafka发送已经将数据写入的通知。 Kafka Sink的恰好处理一次语义保证Kafka 0.11版本引入了事务写特性。由于这个新特性，Flink Kafka sink可以为输出结果提供恰好处理一次语义的一致性保证，只要经过合适的配置就行。Flink程序必须开启检查点机制，并从可重置的数据源进行消费。FlinkKafkaProducer还提供了包含Semantic参数的构造器来控制sink提供的一致性保证。可能的取值如下： Semantic.NONE，不提供任何一致性保证。数据可能丢失或者被重写多次。 Semantic.AT_LEAST_ONCE，保证无数据丢失，但可能被处理多次。这个是默认设置。 Semantic.EXACTLY_ONCE，基于Kafka的事务性写入特性实现，保证每条数据恰好处理一次。 文件系统source连接器Apache Flink针对文件系统实现了一个可重置的source连接器，将文件看作流来读取数据。如下面的例子所示： scala12345678val lineReader = new TextInputFormat(null) val lineStream: DataStream[String] = env.readFile[String]( lineReader, // The FileInputFormat \"hdfs:///path/to/my/data\", // The path to read FileProcessingMode .PROCESS_CONTINUOUSLY, // The processing mode 30000L) // The monitoring interval in ms StreamExecutionEnvironment.readFile()接收如下参数： FileInputFormat参数，负责读取文件中的内容。 文件路径。如果文件路径指向单个文件，那么将会读取这个文件。如果路径指向一个文件夹，FileInputFormat将会扫描文件夹中所有的文件。 PROCESS_CONTINUOUSLY将会周期性的扫描文件，以便扫描到文件新的改变。 30000L表示多久扫描一次监听的文件。 FileInputFormat是一个特定的InputFormat，用来从文件系统中读取文件。FileInputFormat分两步读取文件。首先扫描文件系统的路径，然后为所有匹配到的文件创建所谓的input splits。一个input split将会定义文件上的一个范围，一般通过读取的开始偏移量和读取长度来定义。在将一个大的文件分割成一堆小的splits以后，这些splits可以分发到不同的读任务，这样就可以并行的读取文件了。FileInputFormat的第二步会接收一个input split，读取被split定义的文件范围，然后返回对应的数据。 DataStream应用中使用的FileInputFormat需要实现CheckpointableInputFormat接口。这个接口定义了方法来做检查点和重置文件片段的当前的读取位置。 在Flink 1.7中，Flink提供了一些类，这些类继承了FileInputFormat，并实现了CheckpointableInputFormat接口。TextInputFormat一行一行的读取文件，而CsvInputFormat使用逗号分隔符来读取文件。 文件系统sink连接器在将流处理应用配置成exactly-once检查点机制，以及配置成所有源数据都能在故障的情况下可以重置，Flink的StreamingFileSink提供了端到端的恰好处理一次语义保证。下面的例子展示了StreamingFileSink的使用方式。 scala12345678val input: DataStream[String] = …val sink: StreamingFileSink[String] = StreamingFileSink .forRowFormat( new Path(\"/base/path\"), new SimpleStringEncoder[String](\"UTF-8\")) .build()input.addSink(sink) 当StreamingFileSink接到一条数据，这条数据将被分配到一个桶（bucket）中。一个桶是我们配置的“/base/path”的子目录。 Flink使用BucketAssigner来分配桶。BucketAssigner是一个公共的接口，为每一条数据返回一个BucketId，BucketId决定了数据被分配到哪个子目录。如果没有指定BucketAssigner，Flink将使用DateTimeBucketAssigner来将每条数据分配到每个一个小时所产生的桶中去，基于数据写入的处理时间（机器时间，墙上时钟）。 StreamingFileSink提供了exactly-once输出的保证。sink通过一个commit协议来达到恰好处理一次语义的保证。这个commit协议会将文件移动到不同的阶段，有以下状态：in progress，pending，finished。这个协议基于Flink的检查点机制。当Flink决定roll a file时，这个文件将被关闭并移动到pending状态，通过重命名文件来实现。当下一个检查点完成时，pending文件将被移动到finished状态，同样是通过重命名来实现。 一旦任务故障，sink任务需要将处于in progress状态的文件重置到上一次检查点的写偏移量。这个可以通过关闭当前in progress的文件，并将文件结尾无效的部分丢弃掉来实现。 实现自定义源函数DataStream API提供了两个接口来实现source连接器： SourceFunction和RichSourceFunction可以用来定义非并行的source连接器，source跑在单任务上。 ParallelSourceFunction和RichParallelSourceFunction可以用来定义跑在并行实例上的source连接器。 除了并行于非并行的区别，这两种接口完全一样。就像process function的rich版本一样，RichSourceFunction和RichParallelSourceFunction的子类可以override open()和close()方法，也可以访问RuntimeContext，RuntimeContext提供了并行任务实例的数量，当前任务实例的索引，以及一些其他信息。 SourceFunction和ParallelSourceFunction定义了两种方法： void run(SourceContext ctx) cancel() run()方法用来读取或者接收数据然后将数据摄入到Flink应用中。根据接收数据的系统，数据可能是推送的也可能是拉取的。Flink仅仅在特定的线程调用run()方法一次，通常情况下会是一个无限循环来读取或者接收数据并发送数据。任务可以在某个时间点被显式的取消，或者由于流是有限流，当数据被消费完毕时，任务也会停止。 当应用被取消或者关闭时，cancel()方法会被Flink调用。为了优雅的关闭Flink应用，run()方法需要在cancel()被调用以后，立即终止执行。下面的例子显示了一个简单的源函数的例子：从0数到Long.MaxValue。 scala1234567891011121314class CountSource extends SourceFunction[Long] &#123; var isRunning: Boolean = true override def run(ctx: SourceFunction.SourceContext[Long]) = &#123; var cnt: Long = -1 while (isRunning &amp;&amp; cnt &lt; Long.MaxValue) &#123; cnt += 1 ctx.collect(cnt) &#125; &#125; override def cancel() = isRunning = false&#125; 可重置的源函数之前我们讲过，应用程序只有使用可以重播输出数据的数据源时，才能提供令人满意的一致性保证。如果外部系统暴露了获取和重置读偏移量的API，那么source函数就可以重播源数据。这样的例子包括一些能够提供文件流的偏移量的文件系统，或者提供seek方法用来移动到文件的特定位置的文件系统。或者Apache Kafka这种可以为每一个主题的分区提供偏移量并且可以设置分区的读位置的系统。一个反例就是source连接器连接的是socket，socket将会立即丢弃已经发送过的数据。 支持重播输出的源函数需要和Flink的检查点机制集成起来，还需要在检查点被处理时，持久化当前所有的读取位置。当应用从一个保存点（savepoint）恢复或者从故障恢复时，Flink会从最近一次的检查点或者保存点中获取读偏移量。如果程序开始时并不存在状态，那么读偏移量将会被设置到一个默认值。一个可重置的源函数需要实现CheckpointedFunction接口，还需要能够存储读偏移量和相关的元数据，例如文件的路径，分区的ID。这些数据将被保存在list state或者union list state中。 下面的例子将CountSource重写为可重置的数据源。 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445class ResettableCountSource extends SourceFunction[Long] with CheckpointedFunction &#123; var isRunning: Boolean = true var cnt: Long = _ var offsetState: ListState[Long] = _ override def run(ctx: SourceFunction.SourceContext[Long]) = &#123; while (isRunning &amp;&amp; cnt &lt; Long.MaxValue) &#123; // synchronize data emission and checkpoints ctx.getCheckpointLock.synchronized &#123; cnt += 1 ctx.collect(cnt) &#125; &#125; &#125; override def cancel() = isRunning = false override def snapshotState( snapshotCtx: FunctionSnapshotContext ): Unit = &#123; // remove previous cnt offsetState.clear() // add current cnt offsetState.add(cnt) &#125; override def initializeState( initCtx: FunctionInitializationContext): Unit = &#123; val desc = new ListStateDescriptor[Long]( \"offset\", classOf[Long]) offsetState = initCtx .getOperatorStateStore .getListState(desc) // initialize cnt variable val it = offsetState.get() cnt = if (null == it || !it.iterator().hasNext) &#123; -1L &#125; else &#123; it.iterator().next() &#125; &#125;&#125; 实现自定义sink函数DataStream API中，任何运算符或者函数都可以向外部系统发送数据。DataStream不需要最终流向sink运算符。例如，我们可能实现了一个FlatMapFunction，这个函数将每一个接收到的数据通过HTTP POST请求发送出去，而不使用Collector发送到下一个运算符。DataStream API也提供了SinkFunction接口以及对应的rich版本RichSinkFunction抽象类。SinkFunction接口提供了一个方法： scala1void invode(IN value, Context ctx) SinkFunction的Context可以访问当前处理时间，当前水位线，以及数据的时间戳。 下面的例子展示了一个简单的SinkFunction，可以将传感器读数写入到socket中去。需要注意的是，我们需要在启动Flink程序前启动一个监听相关端口的进程。否则将会抛出ConnectException异常。可以运行“nc -l localhost 9191”命令。 scala1234567891011121314151617181920212223242526272829303132333435val readings: DataStream[SensorReading] = ...// write the sensor readings to a socketreadings.addSink(new SimpleSocketSink(\"localhost\", 9191)) // set parallelism to 1 because only one thread can write to a socket .setParallelism(1)// -----class SimpleSocketSink(val host: String, val port: Int) extends RichSinkFunction[SensorReading] &#123; var socket: Socket = _ var writer: PrintStream = _ override def open(config: Configuration): Unit = &#123; // open socket and writer socket = new Socket(InetAddress.getByName(host), port) writer = new PrintStream(socket.getOutputStream) &#125; override def invoke( value: SensorReading, ctx: SinkFunction.Context[_]): Unit = &#123; // write sensor reading to socket writer.println(value.toString) writer.flush() &#125; override def close(): Unit = &#123; // close writer and socket writer.close() socket.close() &#125;&#125; 之前我们讨论过，端到端的一致性保证建立在sink连接器的属性上面。为了达到端到端的恰好处理一次语义的目的，应用程序需要幂等性的sink连接器或者事务性的sink连接器。上面例子中的SinkFunction既不是幂等写入也不是事务性的写入。由于socket具有只能添加（append-only）这样的属性，所以不可能实现幂等性的写入。又因为socket不具备内置的事务支持，所以事务性写入就只能使用Flink的WAL sink特性来实现了。接下来我们将学习如何实现幂等sink连接器和事务sink连接器。 幂等sink连接器对于大多数应用，SinkFunction接口足以实现一个幂等性写入的sink连接器了。需要以下两个条件： 结果数据必须具有确定性的key，在这个key上面幂等性更新才能实现。例如一个计算每分钟每个传感器的平均温度值的程序，确定性的key值可以是传感器的ID和每分钟的时间戳。确定性的key值，对于在故障恢复的场景下，能够正确的覆盖结果非常的重要。 外部系统支持针对每个key的更新，例如关系型数据库或者key-value存储。 下面的例子展示了如何实现一个针对JDBC数据库的幂等写入sink连接器，这里使用的是Apache Derby数据库。 scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546val readings: DataStream[SensorReading] = ...// write the sensor readings to a Derby tablereadings.addSink(new DerbyUpsertSink)// -----class DerbyUpsertSink extends RichSinkFunction[SensorReading] &#123; var conn: Connection = _ var insertStmt: PreparedStatement = _ var updateStmt: PreparedStatement = _ override def open(parameters: Configuration): Unit = &#123; // connect to embedded in-memory Derby conn = DriverManager.getConnection( \"jdbc:derby:memory:flinkExample\", new Properties()) // prepare insert and update statements insertStmt = conn.prepareStatement( \"INSERT INTO Temperatures (sensor, temp) VALUES (?, ?)\") updateStmt = conn.prepareStatement( \"UPDATE Temperatures SET temp = ? WHERE sensor = ?\") &#125; override def invoke(r: SensorReading, context: Context[_]): Unit = &#123; // set parameters for update statement and execute it updateStmt.setDouble(1, r.temperature) updateStmt.setString(2, r.id) updateStmt.execute() // execute insert statement // if update statement did not update any row if (updateStmt.getUpdateCount == 0) &#123; // set parameters for insert statement insertStmt.setString(1, r.id) insertStmt.setDouble(2, r.temperature) // execute insert statement insertStmt.execute() &#125; &#125; override def close(): Unit = &#123; insertStmt.close() updateStmt.close() conn.close() &#125;&#125; 由于Apache Derby并没有提供内置的UPSERT方法，所以这个sink连接器实现了UPSERT写。具体实现方法是首先去尝试更新一行数据，如果这行数据不存在，则插入新的一行数据。 事务性sink连接器事务写入sink连接器需要和Flink的检查点机制集成，因为只有在检查点成功完成以后，事务写入sink连接器才会向外部系统commit数据。 为了简化事务性sink的实现，Flink提供了两个模版用来实现自定义sink运算符。这两个模版都实现了CheckpointListener接口。CheckpointListener接口将会从JobManager接收到检查点完成的通知。 GenericWriteAheadSink模版会收集检查点之前的所有的数据，并将数据存储到sink任务的运算符状态中。状态保存到了检查点中，并在任务故障的情况下恢复。当任务接收到检查点完成的通知时，任务会将所有的数据写入到外部系统中。 TwoPhaseCommitSinkFunction模版利用了外部系统的事务特性。对于每一个检查点，任务首先开始一个新的事务，并将接下来所有的数据都写到外部系统的当前事务上下文中去。当任务接收到检查点完成的通知时，sink连接器将会commit这个事务。 GENERICWRITEAHEADSINK GenericWriteAheadSink使得sink运算符可以很方便的实现。这个运算符和Flink的检查点机制集成使用，目标是将每一条数据恰好一次写入到外部系统中去。需要注意的是，在发生故障的情况下，write-ahead log sink可能会不止一次的发送相同的数据。所以GenericWriteAheadSink无法提供完美无缺的恰好处理一次语义的一致性保证，而是仅能提供at-least-once这样的保证。我们接下来详细的讨论这些场景。 GenericWriteAheadSink的原理是将接收到的所有数据都追加到有检查点分割好的预写式日志中去。每当sink运算符碰到检查点屏障，运算符将会开辟一个新的section，并将接下来的所有数据都追加到新的section中去。WAL（预写式日志）将会保存到运算符状态中。由于log能被恢复，所有不会有数据丢失。 当GenericWriteAheadSink接收到检查点完成的通知时，将会发送对应检查点的WAL中存储的所有数据。当所有数据发送成功，对应的检查点必须在内部提交。 检查点的提交分两步。第一步，sink持久化检查点被提交的信息。第二步，删除WAL中所有的数据。我们不能将commit信息保存在Flink应用程序状态中，因为状态不是持久化的，会在故障恢复时重置状态。相反，GenericWriteAheadSink依赖于可插拔的组件在一个外部持久化存储中存储和查找提交信息。这个组件就是CheckpointCommitter。 继承GenericWriteAheadSink的运算符需要提供三个构造器函数。 CheckpointCommitter TypeSerializer，用来序列化输入数据。 一个job ID，传给CheckpointCommitter，当应用重启时可以识别commit信息。 还有，write-ahead运算符需要实现一个单独的方法： scala1boolean sendValues(Iterable&lt;IN&gt; values, long chkpntId, long timestamp) 当检查点完成时，GenericWriteAheadSink调用sendValues()方法来将数据写入到外部存储系统中。这个方法接收一个检查点对应的所有数据的迭代器，检查点的ID，检查点被处理时的时间戳。当数据写入成功时，方法必须返回true，写入失败返回false。 下面的例子展示了如何实现一个写入到标准输出的write-ahead sink。它使用了FileCheckpointCommitter。 scala123456789101112131415161718192021222324252627282930val readings: DataStream[SensorReading] = ???// write the sensor readings to the standard out via a write-ahead logreadings.transform( \"WriteAheadSink\", new SocketWriteAheadSink)// ```-class StdOutWriteAheadSink extends GenericWriteAheadSink[SensorReading]( // CheckpointCommitter that commits // checkpoints to the local filesystem new FileCheckpointCommitter(System.getProperty(\"java.io.tmpdir\")), // Serializer for records createTypeInformation[SensorReading] .createSerializer(new ExecutionConfig), // Random JobID used by the CheckpointCommitter UUID.randomUUID.toString) &#123; override def sendValues( readings: Iterable[SensorReading], checkpointId: Long, timestamp: Long): Boolean = &#123; for (r &lt;- readings.asScala) &#123; // write record to standard out println(r) &#125; true &#125;&#125; 之前我们讲过，GenericWriteAheadSink无法提供完美的exactly-once保证。有两个故障状况会导致数据可能被发送不止一次。 当任务执行sendValues()方法时，程序挂掉了。如果外部系统无法原子性的写入所有数据（要么都写入要么都不写），一些数据可能会写入，而另一些数据并没有被写入。由于checkpoint还没有commit，所以在任务恢复的过程中一些数据可能会被再次写入。 所有数据都写入成功了，sendValues()方法也返回true了；但在CheckpointCommitter方法被调用之前程序挂了，或者CheckpointCommitter在commit检查点时失败了。那么在恢复的过程中，所有未被提交的检查点将会被重新写入。 TWOPHASECOMMITSINKFUNCTION Flink提供了TwoPhaseCommitSinkFunction接口来简化sink函数的实现。这个接口保证了端到端的exactly-once语义。2PC sink函数是否提供这样的一致性保证取决于我们的实现细节。我们需要讨论一个问题：“2PC协议是否开销太大？” 通常来讲，为了保证分布式系统的一致性，2PC是一个非常昂贵的方法。尽管如此，在Flink的语境下，2PC协议针对每一个检查点只运行一次。TwoPhaseCommitSinkFunction和WAL sink很相似，不同点在于前者不会将数据收集到state中，而是会写入到外部系统事务的上下文中。 TwoPhaseCommitSinkFunction实现了以下协议。在sink任务发送出第一条数据之前，任务将在外部系统中开始一个事务，所有接下来的数据将被写入这个事务的上下文中。当JobManager初始化检查点并将检查点屏障插入到流中的时候，2PC协议的投票阶段开始。当运算符接收到检查点屏障，运算符将保存它的状态，当保存完成时，运算符将发送一个acknowledgement信息给JobManager。当sink任务接收到检查点屏障时，运算符将会持久化它的状态，并准备提交当前的事务，以及acknowledge JobManager中的检查点。发送给JobManager的acknowledgement信息类似于2PC协议中的commit投票。sink任务还不能提交事务，因为它还没有保证所有的任务都已经完成了它们的检查点操作。sink任务也会为下一个检查点屏障之前的所有数据开始一个新的事务。 当JobManager成功接收到所有任务实例发出的检查点操作成功的通知时，JobManager将会把检查点完成的通知发送给所有感兴趣的任务。这里的通知对应于2PC协议的提交命令。当sink任务接收到通知时，它将commit所有处于开启状态的事务。一旦sink任务acknowledge了检查点操作，它必须能够commit对应的事务，即使任务发生故障。如果commit失败，数据将会丢失。 让我们总结一下外部系统需要满足什么样的要求： 外部系统必须提供事务支持，或者sink的实现能在外部系统上模拟事务功能。 在检查点操作期间，事务必须处于open状态，并接收这段时间数据的持续写入。 事务必须等到检查点操作完成的通知到来才可以提交。在恢复周期中，可能需要一段时间等待。如果sink系统关闭了事务（例如超时了），那么未被commit的数据将会丢失。 sink必须在进程挂掉后能够恢复事务。一些sink系统会提供事务ID，用来commit或者abort一个开始的事务。 commit一个事务必须是一个幂等性操作。sink系统或者外部系统能够观察到事务已经被提交，或者重复提交并没有副作用。 下面的例子可能会让上面的一些概念好理解一些。 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TransactionalFileSink(val targetPath: String, val tempPath: String) extends TwoPhaseCommitSinkFunction[(String, Double), String, Void]( createTypeInformation[String].createSerializer(new ExecutionConfig), createTypeInformation[Void].createSerializer(new ExecutionConfig)) &#123; var transactionWriter: BufferedWriter = _ // Creates a temporary file for a transaction into // which the records are written. override def beginTransaction(): String = &#123; // path of transaction file // is built from current time and task index val timeNow = LocalDateTime.now(ZoneId.of(\"UTC\")) .format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) val taskIdx = this.getRuntimeContext.getIndexOfThisSubtask val transactionFile = s\"$timeNow-$taskIdx\" // create transaction file and writer val tFilePath = Paths.get(s\"$tempPath/$transactionFile\") Files.createFile(tFilePath) this.transactionWriter = Files.newBufferedWriter(tFilePath) println(s\"Creating Transaction File: $tFilePath\") // name of transaction file is returned to // later identify the transaction transactionFile &#125; /** Write record into the current transaction file. */ override def invoke( transaction: String, value: (String, Double), context: Context[_]): Unit = &#123; transactionWriter.write(value.toString) transactionWriter.write('\\n') &#125; /** Flush and close the current transaction file. */ override def preCommit(transaction: String): Unit = &#123; transactionWriter.flush() transactionWriter.close() &#125; // Commit a transaction by moving // the precommitted transaction file // to the target directory. override def commit(transaction: String): Unit = &#123; val tFilePath = Paths.get(s\"$tempPath/$transaction\") // check if the file exists to ensure // that the commit is idempotent if (Files.exists(tFilePath)) &#123; val cFilePath = Paths.get(s\"$targetPath/$transaction\") Files.move(tFilePath, cFilePath) &#125; &#125; // Aborts a transaction by deleting the transaction file. override def abort(transaction: String): Unit = &#123; val tFilePath = Paths.get(s\"$tempPath/$transaction\") if (Files.exists(tFilePath)) &#123; Files.delete(tFilePath) &#125; &#125;&#125; TwoPhaseCommitSinkFunction[IN, TXN, CONTEXT]包含如下三个范型参数： IN表示输入数据的类型。 TXN定义了一个事务的标识符，可以用来识别和恢复事务。 CONTEXT定义了自定义的上下文。 TwoPhaseCommitSinkFunction的构造器需要两个TypeSerializer。一个是TXN的类型，另一个是CONTEXT的类型。 最后，TwoPhaseCommitSinkFunction定义了五个需要实现的方法： beginTransaction(): TXN开始一个事务，并返回事务的标识符。 invoke(txn: TXN, value: IN, context: Context[_]): Unit将值写入到当前事务中。 preCommit(txn: TXN): Unit预提交一个事务。一个预提交的事务不会接收新的写入。 commit(txn: TXN): Unit提交一个事务。这个操作必须是幂等的。 abort(txn: TXN): Unit终止一个事务。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列07有状态算子和应用","slug":"flink系列07有状态算子和应用","date":"2020-07-02T03:47:39.000Z","updated":"2020-07-02T03:48:27.490Z","comments":true,"path":"2020/07/02/flink系列07有状态算子和应用/","link":"","permalink":"https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9707%E6%9C%89%E7%8A%B6%E6%80%81%E7%AE%97%E5%AD%90%E5%92%8C%E5%BA%94%E7%94%A8/","excerpt":"","text":"第七章，有状态算子和应用状态操作符和用户自定义函数都是我们在写流处理程序时，常用的工具。事实上，大部分稍微复杂一点的逻辑都需要保存数据或者保存计算结果。很多Flink内置的操作符例如：source操作符，sink操作符等等都是有状态的，也就是说会缓存流数据或者计算结果。例如，窗口操作符将会为ProcessWindowFunction收集输入的数据，或者收集ReduceFunction计算的结果。而ProcessFunction也会保存定时器事件，一些sink方法为了做到exactly-once，会将事务保存下来。除了内置的操作符以及提供的source和sink操作符，Flink的DataStream API还在UDF函数中暴露了可以注册、保存和访问状态的接口。 本章重点讨论有状态的用户自定义函数的实现，以及讨论有状态应用的性能和健壮性。特别的，我们将解释在用户自定义函数中，如何定义不同类型的状态，以及如何与状态进行交互。我们还讨论了性能方面的问题以及如何控制状态大小的问题。 实现有状态的用户自定义函数我们知道函数有两种状态，键控状态(keyed state)和操作符状态(operator state)。 在RuntimeContext中定义键控状态(keyed state)用户自定义函数可以使用keyed state来存储和访问key对应的状态。对于每一个key，Flink将会维护一个状态实例。一个操作符的状态实例将会被分发到操作符的所有并行任务中去。这表明函数的每一个并行任务只为所有key的某一部分key保存key对应的状态实例。所以keyed state和分布式key-value map数据结构非常类似。 keyed state仅可用于KeyedStream。Flink支持以下数据类型的状态变量： ValueState[T]保存单个的值，值的类型为T。 get操作: ValueState.value() set操作: ValueState.update(value: T) ListState[T]保存一个列表，列表里的元素的数据类型为T。基本操作如下： ListState.add(value: T) ListState.addAll(values: java.util.List[T]) ListState.get()返回Iterable[T] ListState.update(values: java.util.List[T]) MapState[K, V]保存Key-Value对。 MapState.get(key: K) MapState.put(key: K, value: V) MapState.contains(key: K) MapState.remove(key: K) ReducingState[T] AggregatingState[I, O] State.clear()是清空操作。 scala1234567891011121314151617181920212223242526272829val sensorData: DataStream[SensorReading] = ...val keyedData: KeyedStream[SensorReading, String] = sensorData.keyBy(_.id)val alerts: DataStream[(String, Double, Double)] = keyedData .flatMap(new TemperatureAlertFunction(1.7))class TemperatureAlertFunction(val threshold: Double) extends RichFlatMapFunction[SensorReading, (String, Double, Double)] &#123; private var lastTempState: ValueState[Double] = _ override def open(parameters: Configuration): Unit = &#123; val lastTempDescriptor = new ValueStateDescriptor[Double]( \"lastTemp\", classOf[Double]) lastTempState = getRuntimeContext.getState[Double](lastTempDescriptor) &#125; override def flatMap( reading: SensorReading, out: Collector[(String, Double, Double)] ): Unit = &#123; val lastTemp = lastTempState.value() val tempDiff = (reading.temperature - lastTemp).abs if (tempDiff &gt; threshold) &#123; out.collect((reading.id, reading.temperature, tempDiff)) &#125; this.lastTempState.update(reading.temperature) &#125;&#125; 上面例子中的FlatMapFunction只能访问当前处理的元素所包含的key所对应的状态变量。 不同key对应的keyed state是相互隔离的。 通过RuntimeContext注册StateDescriptor。StateDescriptor以状态state的名字和存储的数据类型为参数。数据类型必须指定，因为Flink需要选择合适的序列化器。 在open()方法中创建state变量。注意复习之前的RichFunction相关知识。 当一个函数注册了StateDescriptor描述符，Flink会检查状态后端是否已经存在这个状态。这种情况通常出现在应用挂掉要从检查点或者保存点恢复的时候。在这两种情况下，Flink会将注册的状态连接到已经存在的状态。如果不存在状态，则初始化一个空的状态。 使用FlatMap with keyed ValueState的快捷方式flatMapWithState也可以实现以上需求。 scala123456789101112131415161718val alerts: DataStream[(String, Double, Double)] = keyedSensorData .flatMapWithState[(String, Double, Double), Double] &#123; case (in: SensorReading, None) =&gt; // no previous temperature defined. // Just update the last temperature (List.empty, Some(in.temperature)) case (r: SensorReading, lastTemp: Some[Double]) =&gt; // compare temperature difference with threshold val tempDiff = (r.temperature - lastTemp.get).abs if (tempDiff &gt; 1.7) &#123; // threshold exceeded. // Emit an alert and update the last temperature (List((r.id, r.temperature, tempDiff)), Some(r.temperature)) &#125; else &#123; // threshold not exceeded. Just update the last temperature (List.empty, Some(r.temperature)) &#125; &#125; 使用ListCheckpointed接口来实现操作符的列表状态(List State)操作符状态会在操作符的每一个并行实例中去维护。一个操作符并行实例上的所有事件都可以访问同一个状态。Flink支持三种操作符状态：list state, list union state, broadcast state。 一个函数可以实现ListCheckpointed接口来处理操作符的list state。ListCheckpointed接口无法处理ValueState和ListState，因为这些状态是注册在状态后端的。操作符状态类似于成员变量，和状态后端的交互通过ListCheckpointed接口的回调函数实现。接口提供了两个方法： scala1234// 返回函数状态的快照，返回值为列表snapshotState(checkpointId: Long, timestamp: Long): java.util.List[T]// 从列表恢复函数状态restoreState(java.util.List[T] state): Unit 当Flink触发stateful functon的一次checkpoint时，snapshotState()方法会被调用。方法接收两个参数，checkpointId为唯一的单调递增的检查点Id，timestamp为当master机器开始做检查点操作时的墙上时钟（机器时间）。方法必须返回序列化好的状态对象的列表。 当宕机程序从检查点或者保存点恢复时会调用restoreState()方法。restoreState使用snapshotState保存的列表来恢复。 下面的例子展示了如何实现ListCheckpointed接口。业务场景为：一个对每一个并行实例的超过阈值的温度的计数程序。 scala12345678910111213141516171819202122232425262728293031323334353637class HighTempCounter(val threshold: Double) extends RichFlatMapFunction[SensorReading, (Int, Long)] with ListCheckpointed[java.lang.Long] &#123; // index of the subtask private lazy val subtaskIdx = getRuntimeContext .getIndexOfThisSubtask // local count variable private var highTempCnt = 0L override def flatMap( in: SensorReading, out: Collector[(Int, Long)]): Unit = &#123; if (in.temperature &gt; threshold) &#123; // increment counter if threshold is exceeded highTempCnt += 1 // emit update with subtask index and counter out.collect((subtaskIdx, highTempCnt)) &#125; &#125; override def restoreState( state: util.List[java.lang.Long]): Unit = &#123; highTempCnt = 0 // restore state by adding all longs of the list for (cnt &lt;- state.asScala) &#123; highTempCnt += cnt &#125; &#125; override def snapshotState( chkpntId: Long, ts: Long): java.util.List[java.lang.Long] = &#123; // snapshot state as list with a single count java.util.Collections.singletonList(highTempCnt) &#125;&#125; 上面的例子中，每一个并行实例都计数了本实例有多少温度值超过了设定的阈值。例子中使用了操作符状态，并且每一个并行实例都拥有自己的状态变量，这个状态变量将会被检查点操作保存下来，并且可以通过使用ListCheckpointed接口来恢复状态变量。 看了上面的例子，我们可能会有疑问，那就是为什么操作符状态是状态对象的列表。这是因为列表数据结构支持包含操作符状态的函数的并行度改变的操作。为了增加或者减少包含了操作符状态的函数的并行度，操作符状态需要被重新分区到更多或者更少的并行任务实例中去。而这样的操作需要合并或者分割状态对象。而对于每一个有状态的函数，分割和合并状态对象都是很常见的操作，所以这显然不是任何类型的状态都能自动完成的。 通过提供一个状态对象的列表，拥有操作符状态的函数可以使用snapshotState()方法和restoreState()方法来实现以上所说的逻辑。snapshotState()方法将操作符状态分割成多个部分，restoreState()方法从所有的部分中将状态对象收集起来。当函数的操作符状态恢复时，状态变量将被分区到函数的所有不同的并行实例中去，并作为参数传递给restoreState()方法。如果并行任务的数量大于状态对象的数量，那么一些并行任务在开始的时候是没有状态的，所以restoreState()函数的参数为空列表。 再来看一下上面的程序，我们可以看到操作符的每一个并行实例都暴露了一个状态对象的列表。如果我们增加操作符的并行度，那么一些并行任务将会从0开始计数。为了获得更好的状态分区的行为，当HighTempCounter函数扩容时，我们可以按照下面的程序来实现snapshotState()方法，这样就可以把计数值分配到不同的并行计数中去了。 scala12345678910override def snapshotState( chkpntId: Long, ts: Long): java.util.List[java.lang.Long] = &#123; // split count into ten partial counts val div = highTempCnt / 10 val mod = (highTempCnt % 10).toInt // return count as ten parts (List.fill(mod)(new java.lang.Long(div + 1)) ++ List.fill(10 - mod)(new java.lang.Long(div))).asJava&#125; 使用连接的广播状态(using connected broadcast state)一个常见的需求就是流应用需要将同样的事件分发到操作符的所有的并行实例中，而这样的分发操作还得是可恢复的。 我们举个例子：一条流是一个规则(比如5秒钟内连续两个超过阈值的温度)，另一条流是待匹配的流。也就是说，规则流和事件流。所以每一个操作符的并行实例都需要把规则流保存在操作符状态中。也就是说，规则流需要被广播到所有的并行实例中去。 在Flink中，这样的状态叫做广播状态(broadcast state)。广播状态和DataStream或者KeyedStream都可以做连接操作。 下面的例子实现了一个温度报警应用，应用有可以动态设定的阈值，动态设定通过广播流来实现。 scala1234567891011121314151617val sensorData: DataStream[SensorReading] = ...val thresholds: DataStream[ThresholdUpdate] = ...val keyedSensorData: KeyedStream[SensorReading, String] = sensorData .keyBy(_.id)// the descriptor of the broadcast stateval broadcastStateDescriptor = new MapStateDescriptor[String, Double]( \"thresholds\", classOf[String], classOf[Double])val broadcastThresholds: BroadcastStream[ThresholdUpdate] = thresholds .broadcast(broadcastStateDescriptor)// connect keyed sensor stream and broadcasted rules streamval alerts: DataStream[(String, Double, Double)] = keyedSensorData .connect(broadcastThresholds) .process(new UpdatableTemperatureAlertFunction()) 带有广播状态的函数在应用到两条流上时分三个步骤： 调用DataStream.broadcast()来创建BroadcastStream，定义一个或者多个MapStateDescriptor对象。 将BroadcastStream和DataStream/KeyedStream做connect操作。 在connected streams上调用KeyedBroadcastProcessFunction/BroadcastProcessFunction。 下面的例子实现了动态设定温度阈值的功能。 scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class UpdatableTemperatureAlertFunction() extends KeyedBroadcastProcessFunction[String, SensorReading, ThresholdUpdate, (String, Double, Double)] &#123; // the descriptor of the broadcast state private lazy val thresholdStateDescriptor = new MapStateDescriptor[String, Double]( \"thresholds\", classOf[String], classOf[Double]) // the keyed state handle private var lastTempState: ValueState[Double] = _ override def open(parameters: Configuration): Unit = &#123; // create keyed state descriptor val lastTempDescriptor = new ValueStateDescriptor[Double]( \"lastTemp\", classOf[Double]) // obtain the keyed state handle lastTempState = getRuntimeContext .getState[Double](lastTempDescriptor) &#125; override def processBroadcastElement( update: ThresholdUpdate, ctx: KeyedBroadcastProcessFunction[String, SensorReading, ThresholdUpdate, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = &#123; // get broadcasted state handle val thresholds = ctx .getBroadcastState(thresholdStateDescriptor) if (update.threshold != 0.0d) &#123; // configure a new threshold for the sensor thresholds.put(update.id, update.threshold) &#125; else &#123; // remove threshold for the sensor thresholds.remove(update.id) &#125; &#125; override def processElement( reading: SensorReading, readOnlyCtx: KeyedBroadcastProcessFunction [String, SensorReading, ThresholdUpdate, (String, Double, Double)]#ReadOnlyContext, out: Collector[(String, Double, Double)]): Unit = &#123; // get read-only broadcast state val thresholds = readOnlyCtx .getBroadcastState(thresholdStateDescriptor) // check if we have a threshold if (thresholds.contains(reading.id)) &#123; // get threshold for sensor val sensorThreshold: Double = thresholds.get(reading.id) // fetch the last temperature from state val lastTemp = lastTempState.value() // check if we need to emit an alert val tempDiff = (reading.temperature - lastTemp).abs if (tempDiff &gt; sensorThreshold) &#123; // temperature increased by more than the threshold out.collect((reading.id, reading.temperature, tempDiff)) &#125; &#125; // update lastTemp state this.lastTempState.update(reading.temperature) &#125;&#125; 配置检查点10秒钟保存一次检查点。 scala1234val env = StreamExecutionEnvironment.getExecutionEnvironment// set checkpointing interval to 10 seconds (10000 milliseconds)env.enableCheckpointing(10000L) 将hdfs配置为状态后端首先在IDEA的pom文件中添加依赖： xml123456 &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.8.3&lt;/version&gt;&lt;!-- &lt;scope&gt;provided&lt;/scope&gt;--&gt; &lt;/dependency&gt; 在hdfs-site.xml添加: xml1234&lt;property&gt; &lt;name&gt;dfs.permissions&lt;/name&gt; &lt;value&gt;false&lt;/value&gt;&lt;/property&gt; 别忘了重启hdfs文件系统！ 然后添加本地文件夹和hdfs文件的映射： Code12hdfs getconf -confKey fs.default.namehdfs dfs -put &#x2F;home&#x2F;parallels&#x2F;flink&#x2F;checkpoint hdfs:&#x2F;&#x2F;localhost:9000&#x2F;flink 然后在代码中添加： Code12env.enableCheckpointing(5000)env.setStateBackend(new FsStateBackend(&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;flink&quot;)) 检查一下检查点正确保存了没有： Code1hdfs dfs -ls hdfs:&#x2F;&#x2F;localhost:9000&#x2F;flink 保证有状态应用的可维护性指定唯一的操作符标识符(operator identifiers)每一个操作符都可以指定唯一的标识符。标识符将会作为操作符的元数据和状态数据一起保存到savepoint中去。当应用从保存点恢复时，标识符可以用来在savepoint中查找标识符对应的操作符的状态数据。标识符必须是唯一的，否则应用不知道从哪一个标识符恢复。 强烈建议为应用的每一个操作符定义唯一标识符。例子： scala123val alerts: DataStream[(String, Double, Double)] = keyedSensorData .flatMap(new TemperatureAlertFunction(1.1)) .uid(\"TempAlert\") 指定操作符的最大并行度操作符的最大并行度定义了操作符的keyed state可以被分到多少个key groups中。 scala12345678910val env = StreamExecutionEnvironment.getExecutionEnvironment// set the maximum parallelism for this applicationenv.setMaxParallelism(512)val alerts: DataStream[(String, Double, Double)] = keyedSensorData .flatMap(new TemperatureAlertFunction(1.1)) // set the maximum parallelism for this operator and // override the application-wide value .setMaxParallelism(1024) 有状态应用的性能和健壮性选择一个状态后端 MemoryStateBackend将状态当作Java的对象(没有序列化操作)存储在TaskManager JVM进程的堆上。 FsStateBackend将状态存储在本地的文件系统或者远程的文件系统如HDFS。 RocksDBStateBackend将状态存储在RocksDB 中。 scala123456789val env = StreamExecutionEnvironment.getExecutionEnvironmentval checkpointPath: String = ???// configure path for checkpoints on the remote filesystem// env.setStateBackend(new FsStateBackend(\"file:///tmp/checkpoints\"))val backend = new RocksDBStateBackend(checkpointPath)// configure the state backendenv.setStateBackend(backend) 防止状态泄露流应用通常需要运行几个月或者几年。如果state数据不断增长的话，会爆炸。所以控制state数据的大小十分重要。而Flink并不会清理state和gc。所以所有的stateful operator都需要控制他们各自的状态数据大小，保证不爆炸。 例如我们之前讲过增量聚合函数ReduceFunction/AggregateFunction，就可以提前聚合而不给state太多压力。 我们来看一个例子，我们实现了一个KeyedProcessFunction，用来计算连续两次的温度的差值，如果差值超过阈值，报警。 我们之前实现过这个需求，但没有清理掉状态数据。比如一小时内不再产生温度数据的传感器对应的状态数据就可以清理掉了。 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class SelfCleaningTemperatureAlertFunction(val threshold: Double) extends KeyedProcessFunction[String, SensorReading, (String, Double, Double)] &#123; // the keyed state handle for the last temperature private var lastTempState: ValueState[Double] = _ // the keyed state handle for the last registered timer private var lastTimerState: ValueState[Long] = _ override def open(parameters: Configuration): Unit = &#123; // register state for last temperature val lastTempDesc = new ValueStateDescriptor[Double]( \"lastTemp\", classOf[Double]) lastTempState = getRuntimeContext .getState[Double](lastTempDescriptor) // register state for last timer val lastTimerDesc = new ValueStateDescriptor[Long]( \"lastTimer\", classOf[Long]) lastTimerState = getRuntimeContext .getState(timestampDescriptor) &#125; override def processElement( reading: SensorReading, ctx: KeyedProcessFunction [String, SensorReading, (String, Double, Double)]#Context, out: Collector[(String, Double, Double)]): Unit = &#123; // compute timestamp of new clean up timer // as record timestamp + one hour val newTimer = ctx.timestamp() + (3600 * 1000) // get timestamp of current timer val curTimer = lastTimerState.value() // delete previous timer and register new timer ctx.timerService().deleteEventTimeTimer(curTimer) ctx.timerService().registerEventTimeTimer(newTimer) // update timer timestamp state lastTimerState.update(newTimer) // fetch the last temperature from state val lastTemp = lastTempState.value() // check if we need to emit an alert val tempDiff = (reading.temperature - lastTemp).abs if (tempDiff &gt; threshold) &#123; // temperature increased by more than the threshold out.collect((reading.id, reading.temperature, tempDiff)) &#125; // update lastTemp state this.lastTempState.update(reading.temperature) &#125; override def onTimer( timestamp: Long, ctx: KeyedProcessFunction[String, SensorReading, (String, Double, Double)]#OnTimerContext, out: Collector[(String, Double, Double)]): Unit = &#123; // clear all state for the key lastTempState.clear() lastTimerState.clear() &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列06基于时间和窗口的操作符","slug":"flink系列06基于时间和窗口的操作符","date":"2020-07-02T03:45:19.000Z","updated":"2020-07-02T03:47:24.167Z","comments":true,"path":"2020/07/02/flink系列06基于时间和窗口的操作符/","link":"","permalink":"https://masteryang4.github.io/2020/07/02/flink%E7%B3%BB%E5%88%9706%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"第六章，基于时间和窗口的操作符在本章，我们将要学习DataStream API中处理时间和基于时间的操作符，例如窗口操作符。 首先，我们会学习如何定义时间属性，时间戳和水位线。然后我们将会学习底层操作process function，它可以让我们访问时间戳和水位线，以及注册定时器事件。接下来，我们将会使用Flink的window API，它提供了通常使用的各种窗口类型的内置实现。我们将会学到如何进行用户自定义窗口操作符，以及窗口的核心功能：assigners（分配器）、triggers（触发器）和evictors（清理器）。最后，我们将讨论如何基于时间来做流的联结查询，以及处理迟到事件的策略。 设置时间属性如果我们想要在分布式流处理应用程序中定义有关时间的操作，彻底理解时间的语义是非常重要的。当我们指定了一个窗口去收集某1分钟内的数据时，这个长度为1分钟的桶中，到底应该包含哪些数据？在DataStream API中，我们将使用时间属性来告诉Flink：当我们创建窗口时，我们如何定义时间。时间属性是StreamExecutionEnvironment的一个属性，有以下值： ProcessingTime 机器时间在分布式系统中又叫做“墙上时钟”。 当操作符执行时，此操作符看到的时间是操作符所在机器的机器时间。Processing-time window的触发取决于机器时间，窗口包含的元素也是那个机器时间段内到达的元素。通常情况下，窗口操作符使用processing time会导致不确定的结果，因为基于机器时间的窗口中收集的元素取决于元素到达的速度快慢。使用processing time会为程序提供极低的延迟，因为无需等待水位线的到达。 如果要追求极限的低延迟，请使用processing time。 EventTime 当操作符执行时，操作符看的当前时间是由流中元素所携带的信息决定的。流中的每一个元素都必须包含时间戳信息。而系统的逻辑时钟由水位线(Watermark)定义。我们之前学习过，时间戳要么在事件进入流处理程序之前已经存在，要么就需要在程序的数据源（source）处进行分配。当水位线宣布特定时间段的数据都已经到达，事件时间窗口将会被触发计算。即使数据到达的顺序是乱序的，事件时间窗口的计算结果也将是确定性的。窗口的计算结果并不取决于元素到达的快与慢。 当水位线超过事件时间窗口的结束时间时，窗口将会闭合，不再接收数据，并触发计算。 IngestionTime 当事件进入source操作符时，source操作符所在机器的机器时间，就是此事件的“摄入时间”（IngestionTime），并同时产生水位线。IngestionTime相当于EventTime和ProcessingTime的混合体。一个事件的IngestionTime其实就是它进入流处理器中的时间。 IngestionTime没什么价值，既有EventTime的执行效率（比较低），有没有EventTime计算结果的准确性。 下面的例子展示了如何设置事件时间。 scala1234567object AverageSensorReadings &#123; def main(args: Array[String]) &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val sensorData: DataStream[SensorReading] = env.addSource(...) &#125;&#125; 如果要使用processing time，将TimeCharacteristic.EventTime替换为TimeCharacteristic.ProcessingTIme就可以了。 指定时间戳和产生水位线如果使用事件时间，那么流中的事件必须包含这个事件真正发生的时间。使用了事件时间的流必须携带水位线。 时间戳和水位线的单位是毫秒，记时从1970-01-01T00:00:00Z开始。到达某个操作符的水位线就会告知这个操作符：小于等于水位线中携带的时间戳的事件都已经到达这个操作符了。时间戳和水位线可以由SourceFunction产生，或者由用户自定义的时间戳分配器和水位线产生器来生成。 Flink暴露了TimestampAssigner接口供我们实现，使我们可以自定义如何从事件数据中抽取时间戳。一般来说，时间戳分配器需要在source操作符后马上进行调用。 因为时间戳分配器看到的元素的顺序应该和source操作符产生数据的顺序是一样的，否则就乱了。这就是为什么我们经常将source操作符的并行度设置为1的原因。 也就是说，任何分区操作都会将元素的顺序打乱，例如：并行度改变，keyBy()操作等等。 所以最佳实践是：在尽量接近数据源source操作符的地方分配时间戳和产生水位线，甚至最好在SourceFunction中分配时间戳和产生水位线。当然在分配时间戳和产生水位线之前可以对流进行map和filter操作是没问题的，也就是说必须是窄依赖。 以下这种写法是可以的。 scala12345val stream = env .addSource(...) .map(...) .filter(...) .assignTimestampsAndWatermarks(...) 下面的例子展示了首先filter流，然后再分配时间戳和水位线。 scala123456789val env = StreamExecutionEnvironment.getExecutionEnvironment // 从调用时刻开始给env创建的每一个stream追加时间特征env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)val readings: DataStream[SensorReading] = env .addSource(new SensorSource) .filter(r =&gt; r.temperature &gt; 25) .assignTimestampsAndWatermarks(new MyAssigner()) MyAssigner有两种类型 AssignerWithPeriodicWatermarks AssignerWithPunctuatedWatermarks 以上两个接口都继承自TimestampAssigner。 周期性的生成水位线周期性的生成水位线：系统会周期性的将水位线插入到流中（水位线也是一种特殊的事件!）。默认周期是200毫秒，也就是说，系统会每隔200毫秒就往流中插入一次水位线。 这里的200毫秒是机器时间！ 可以使用ExecutionConfig.setAutoWatermarkInterval()方法进行设置。 scala1234val env = StreamExecutionEnvironment.getExecutionEnvironmentenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)// 每隔5秒产生一个水位线env.getConfig.setAutoWatermarkInterval(5000) 上面的例子产生水位线的逻辑：每隔5秒钟，Flink会调用AssignerWithPeriodicWatermarks中的getCurrentWatermark()方法。如果方法返回的时间戳大于之前水位线的时间戳，新的水位线会被插入到流中。这个检查保证了水位线是单调递增的。如果方法返回的时间戳小于等于之前水位线的时间戳，则不会产生新的水位线。 例子，自定义一个周期性的时间戳抽取 scala1234567891011121314class PeriodicAssigner extends AssignerWithPeriodicWatermarks[SensorReading] &#123; val bound: Long = 60 * 1000 // 延时为1分钟 var maxTs: Long = Long.MinValue + bound // 观察到的最大时间戳 override def getCurrentWatermark: Watermark = &#123; new Watermark(maxTs - bound) &#125; override def extractTimestamp(r: SensorReading, previousTS: Long) = &#123; maxTs = maxTs.max(r.timestamp) r.timestamp &#125;&#125; 如果我们事先得知数据流的时间戳是单调递增的，也就是说没有乱序。我们可以使用assignAscendingTimestamps，方法会直接使用数据的时间戳生成水位线。 Code123val stream: DataStream[SensorReading] &#x3D; ...val withTimestampsAndWatermarks &#x3D; stream .assignAscendingTimestamps(e &#x3D;&gt; e.timestamp) 如果我们能大致估算出数据流中的事件的最大延迟时间，可以使用如下代码： 最大延迟时间就是当前到达的事件的事件时间和之前所有到达的事件中最大时间戳的差。 scala123456789101112val stream: DataStream[SensorReading] = ...val withTimestampsAndWatermarks = stream.assignTimestampsAndWatermarks( new SensorTimeAssigner )class SensorTimeAssigner extends BoundedOutOfOrdernessTimestampExtractor[SensorReading]( Time.seconds(5) ) &#123; // 抽取时间戳 override def extractTimestamp(r: SensorReading): Long = r.timestamp&#125; 以上代码设置了最大延迟时间为5秒。 如何产生不规则的水位线有时候输入流中会包含一些用于指示系统进度的特殊元组或标记。Flink为此类情形以及可根据输入元素生成水位线的情形提供了AssignerWithPunctuatedWatermarks接口。该接口中的checkAndGetNextWatermark()方法会在针对每个事件的extractTimestamp()方法后立即调用。它可以决定是否生成一个新的水位线。如果该方法返回一个非空、且大于之前值的水位线，算子就会将这个新水位线发出。 scala123456789101112131415161718192021class PunctuatedAssigner extends AssignerWithPunctuatedWatermarks[SensorReading] &#123; val bound: Long = 60 * 1000 // 每来一条数据就调用一次 override def checkAndGetNextWatermark(r: SensorReading, extractedTS: Long): Watermark = &#123; if (r.id == \"sensor_1\") &#123; // 抽取的时间戳 - 最大延迟时间 new Watermark(extractedTS - bound) &#125; else &#123; null &#125; &#125; // 每来一条数据就调用一次 override def extractTimestamp(r: SensorReading, previousTS: Long): Long = &#123; r.timestamp &#125;&#125; 现在我们已经知道如何使用 TimestampAssigner 来产生水位线了。现在我们要讨论一下水位线会对我们的程序产生什么样的影响。 水位线用来平衡延迟和计算结果的正确性。水位线告诉我们，在触发计算（例如关闭窗口并触发窗口计算）之前，我们需要等待事件多长时间。基于事件时间的操作符根据水位线来衡量系统的逻辑时间的进度。 完美的水位线永远不会错：时间戳小于水位线的事件不会再出现。在特殊情况下(例如非乱序事件流)，最近一次事件的时间戳就可能是完美的水位线。启发式水位线则相反，它只估计时间，因此有可能出错，即迟到的事件(其时间戳小于水位线标记时间)晚于水位线出现。针对启发式水位线，Flink提供了处理迟到元素的机制。 设定水位线通常需要用到领域知识。举例来说，如果知道事件的迟到时间不会超过5秒，就可以将水位线标记时间设为收到的最大时间戳减去5秒。另一种做法是，采用一个Flink作业监控事件流，学习事件的迟到规律，并以此构建水位线生成模型。 如果最大延迟时间设置的很大，计算出的结果会更精确，但收到计算结果的速度会很慢，同时系统会缓存大量的数据，并对系统造成比较大的压力。如果最大延迟时间设置的很小，那么收到计算结果的速度会很快，但可能收到错误的计算结果。不过Flink处理迟到数据的机制可以解决这个问题。上述问题看起来很复杂，但是恰恰符合现实世界的规律：大部分真实的事件流都是乱序的，并且通常无法了解它们的乱序程度(因为理论上不能预见未来)。水位线是唯一让我们直面乱序事件流并保证正确性的机制; 否则只能选择忽视事实，假装错误的结果是正确的。 思考题一：实时程序，要求实时性非常高，并且结果并不一定要求非常准确，那么应该怎么办？ 直接使用处理时间。 思考题二：如果要进行时间旅行，也就是要还原以前的数据集当时的流的状态，应该怎么办？ 使用事件时间。使用Hive将数据集先按照时间戳升序排列，再将最大延迟时间设置为0。 Process Function(Low-Level API)我们之前学习的转换算子是无法访问事件的时间戳信息和水位线信息的。而这在一些应用场景下，极为重要。例如MapFunction这样的map转换算子就无法访问时间戳或者当前事件的事件时间。 基于此，DataStream API提供了一系列的Low-Level转换算子。可以访问时间戳、水位线以及注册定时事件。还可以输出特定的一些事件，例如超时事件等。Process Function用来构建事件驱动的应用以及实现自定义的业务逻辑(使用之前的window函数和转换算子无法实现)。例如，Flink-SQL就是使用Process Function实现的。 Flink提供了8个Process Function： ProcessFunction KeyedProcessFunction CoProcessFunction ProcessJoinFunction BroadcastProcessFunction KeyedBroadcastProcessFunction ProcessWindowFunction ProcessAllWindowFunction 我们这里详细介绍一下KeyedProcessFunction。 KeyedProcessFunction用来操作KeyedStream。KeyedProcessFunction会处理流的每一个元素，输出为0个、1个或者多个元素。所有的Process Function都继承自RichFunction接口，所以都有open()、close()和getRuntimeContext()等方法。而KeyedProcessFunction[KEY, IN, OUT]还额外提供了两个方法: processElement(v: IN, ctx: Context, out: Collector[OUT]), 流中的每一个元素都会调用这个方法，调用结果将会放在Collector数据类型中输出。Context可以访问元素的时间戳，元素的key，以及TimerService时间服务。Context还可以将结果输出到别的流(side outputs)。 onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])是一个回调函数。当之前注册的定时器触发时调用。参数timestamp为定时器所设定的触发的时间戳。Collector为输出结果的集合。OnTimerContext和processElement的Context参数一样，提供了上下文的一些信息，例如firing trigger的时间信息(事件时间或者处理时间)。 TimerService and TimersContext和OnTimerContext所持有的TimerService对象拥有以下方法: currentProcessingTime(): Long 返回当前处理时间 currentWatermark(): Long 返回当前水位线的时间戳 registerProcessingTimeTimer(timestamp: Long): Unit 会注册当前key的processing time的timer。当processing time到达定时时间时，触发timer。 registerEventTimeTimer(timestamp: Long): Unit 会注册当前key的event time timer。当水位线大于等于定时器注册的时间时，触发定时器执行回调函数。 deleteProcessingTimeTimer(timestamp: Long): Unit 删除之前注册处理时间定时器。如果没有这个时间戳的定时器，则不执行。 deleteEventTimeTimer(timestamp: Long): Unit 删除之前注册的事件时间定时器，如果没有此时间戳的定时器，则不执行。 当定时器timer触发时，执行回调函数onTimer()。processElement()方法和onTimer()方法是同步（不是异步）方法，这样可以避免并发访问和操作状态。 定时器timer只能在KeyedStream上面使用。 针对每一个key和timestamp，只能注册一个定期器。也就是说，每一个key可以注册多个定时器，但在每一个时间戳只能注册一个定时器。KeyedProcessFunction默认将所有定时器的时间戳放在一个优先队列中。在Flink做检查点操作时，定时器也会被保存到状态后端中。 举个例子说明KeyedProcessFunction如何操作KeyedStream。 下面的程序展示了如何监控温度传感器的温度值，如果温度值在一秒钟之内(processing time)连续上升，报警。 scala12345val warnings = readings // key by sensor id .keyBy(_.id) // apply ProcessFunction to monitor temperatures .process(new TempIncreaseAlertFunction) 看一下TempIncreaseAlertFunction如何实现, 程序中使用了ValueState这样一个状态变量, 后面会详细讲解。 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class TempIncreaseAlertFunction extends KeyedProcessFunction[String, SensorReading, String] &#123; // 保存上一个传感器温度值 lazy val lastTemp: ValueState[Double] = getRuntimeContext.getState( new ValueStateDescriptor[Double](\"lastTemp\", Types.of[Double]) ) // 保存注册的定时器的时间戳 lazy val currentTimer: ValueState[Long] = getRuntimeContext.getState( new ValueStateDescriptor[Long](\"timer\", Types.of[Long]) ) override def processElement(r: SensorReading, ctx: KeyedProcessFunction[String, SensorReading, String]#Context, out: Collector[String]): Unit = &#123; // get previous temperature // 取出上一次的温度 val prevTemp = lastTemp.value() // update last temperature // 将当前温度更新到上一次的温度这个变量中 lastTemp.update(r.temperature) val curTimerTimestamp = currentTimer.value() if (prevTemp == 0.0 || r.temperature &lt; prevTemp) &#123; // temperature decreased; delete current timer // 温度下降或者是第一个温度值，删除定时器 ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp) // 清空状态变量 currentTimer.clear() &#125; else if (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == 0) &#123; // temperature increased and we have not set a timer yet // set processing time timer for now + 1 second // 温度上升且我们并没有设置定时器 val timerTs = ctx.timerService().currentProcessingTime() + 1000 ctx.timerService().registerProcessingTimeTimer(timerTs) // remember current timer currentTimer.update(timerTs) &#125; &#125; override def onTimer(ts: Long, ctx: KeyedProcessFunction[String, SensorReading, String]#OnTimerContext, out: Collector[String]): Unit = &#123; out.collect(\"传感器id为: \" + ctx.getCurrentKey + \"的传感器温度值已经连续1s上升了。\") currentTimer.clear() &#125;&#125; 将事件发送到侧输出(Emitting to Side Outputs)大部分的DataStream API的算子的输出是单一输出，也就是某种数据类型的流。除了split算子，可以将一条流分成多条流，这些流的数据类型也都相同。process function的side outputs功能可以产生多条流，并且这些流的数据类型可以不一样。一个side output可以定义为OutputTag[X]对象，X是输出流的数据类型。process function可以通过Context对象发射一个事件到一个或者多个side outputs。 例子 scala12345678val monitoredReadings: DataStream[SensorReading] = readings .process(new FreezingMonitor)monitoredReadings .getSideOutput(new OutputTag[String](\"freezing-alarms\")) .print()readings.print() 接下来我们实现FreezingMonitor函数，用来监控传感器温度值，将温度值低于32F的温度输出到side output。 scala123456789101112131415161718class FreezingMonitor extends ProcessFunction[SensorReading, SensorReading] &#123; // define a side output tag // 定义一个侧输出标签 lazy val freezingAlarmOutput: OutputTag[String] = new OutputTag[String](\"freezing-alarms\") override def processElement(r: SensorReading, ctx: ProcessFunction[SensorReading, SensorReading]#Context, out: Collector[SensorReading]): Unit = &#123; // emit freezing alarm if temperature is below 32F if (r.temperature &lt; 32.0) &#123; ctx.output(freezingAlarmOutput, s\"Freezing Alarm for $&#123;r.id&#125;\") &#125; // forward all readings to the regular output out.collect(r) &#125;&#125; CoProcessFunction对于两条输入流，DataStream API提供了CoProcessFunction这样的low-level操作。CoProcessFunction提供了操作每一个输入流的方法: processElement1()和processElement2()。类似于ProcessFunction，这两种方法都通过Context对象来调用。这个Context对象可以访问事件数据，定时器时间戳，TimerService，以及side outputs。CoProcessFunction也提供了onTimer()回调函数。下面的例子展示了如何使用CoProcessFunction来合并两条流。 scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// ingest sensor streamval readings: DataStream[SensorReading] = ...// filter switches enable forwarding of readingsval filterSwitches: DataStream[(String, Long)] = env .fromCollection(Seq( (\"sensor_2\", 10 * 1000L), (\"sensor_7\", 60 * 1000L) ))val forwardedReadings = readings // connect readings and switches .connect(filterSwitches) // key by sensor ids .keyBy(_.id, _._1) // apply filtering CoProcessFunction .process(new ReadingFilter)class ReadingFilter extends CoProcessFunction[SensorReading, (String, Long), SensorReading] &#123; // switch to enable forwarding // 传送数据的开关 lazy val forwardingEnabled: ValueState[Boolean] = getRuntimeContext .getState( new ValueStateDescriptor[Boolean](\"filterSwitch\", Types.of[Boolean]) ) // hold timestamp of currently active disable timer lazy val disableTimer: ValueState[Long] = getRuntimeContext .getState( new ValueStateDescriptor[Long](\"timer\", Types.of[Long]) ) override def processElement1(reading: SensorReading, ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]#Context, out: Collector[SensorReading]): Unit = &#123; // check if we may forward the reading // 决定我们是否要将数据继续传下去 if (forwardingEnabled.value()) &#123; out.collect(reading) &#125; &#125; override def processElement2(switch: (String, Long), ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]#Context, out: Collector[SensorReading]): Unit = &#123; // enable reading forwarding // 允许继续传输数据 forwardingEnabled.update(true) // set disable forward timer val timerTimestamp = ctx.timerService().currentProcessingTime() + switch._2 val curTimerTimestamp = disableTimer.value() if (timerTimestamp &gt; curTimerTimestamp) &#123; // remove current timer and register new timer ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp) ctx.timerService().registerProcessingTimeTimer(timerTimestamp) disableTimer.update(timerTimestamp) &#125; &#125; override def onTimer(ts: Long, ctx: CoProcessFunction[SensorReading, (String, Long), SensorReading]#OnTimerContext, out: Collector[SensorReading]): Unit = &#123; // remove all state; forward switch will be false by default forwardingEnabled.clear() disableTimer.clear() &#125;&#125; 窗口操作符(Window Operators)窗口操作是流处理程序中很常见的操作。窗口操作允许我们在无限流上的一段有界区间上面做聚合之类的操作。而我们使用基于时间的逻辑来定义区间。窗口操作符提供了一种将数据放进一个桶，并根据桶中的数据做计算的方法。例如，我们可以将事件放进5分钟的滚动窗口中，然后计数。 无限流转化成有限数据的方法：使用窗口。 定义窗口操作符Window算子可以在keyed stream或者nokeyed stream上面使用。 创建一个Window算子，需要指定两个部分： window assigner定义了流的元素如何分配到window中。window assigner将会产生一条WindowedStream(或者AllWindowedStream，如果是nonkeyed DataStream的话) window function用来处理WindowedStream(AllWindowedStream)中的元素。 下面的代码说明了如何使用窗口操作符。 scala12345678stream .keyBy(...) .window(...) // 指定window assigner .reduce/aggregate/process(...) // 指定window functionstream .windowAll(...) // 指定window assigner .reduce/aggregate/process(...) // 指定window function 我们的学习重点是Keyed WindowedStream。 内置的窗口分配器(built-in window assigner)窗口分配器将会根据事件的事件时间或者处理时间来将事件分配到对应的窗口中去。窗口包含开始时间和结束时间这两个时间戳。 所有的窗口分配器都包含一个默认的触发器： 对于事件时间：当水位线超过窗口结束时间，触发窗口的求值操作。 对于处理时间：当机器时间超过窗口结束时间，触发窗口的求值操作。 需要注意的是：当处于某个窗口的第一个事件到达的时候，这个窗口才会被创建。Flink不会对空窗口求值。 Flink创建的窗口类型是TimeWindow，包含开始时间和结束时间，区间是左闭右开的，也就是说包含开始时间戳，不包含结束时间戳。 滚动窗口(tumbling windows) scala1234567891011121314151617181920val sensorData: DataStream[SensorReading] = ...val avgTemp = sensorData .keyBy(_.id) // group readings in 1s event-time windows .window(TumblingEventTimeWindows.of(Time.seconds(1))) .process(new TemperatureAverager)val avgTemp = sensorData .keyBy(_.id) // group readings in 1s processing-time windows .window(TumblingProcessingTimeWindows.of(Time.seconds(1))) .process(new TemperatureAverager)// 其实就是之前的// shortcut for window.(TumblingEventTimeWindows.of(size))val avgTemp = sensorData .keyBy(_.id) .timeWindow(Time.seconds(1)) .process(new TemperatureAverager) 默认情况下，滚动窗口会和1970-01-01-00:00:00.000对齐，例如一个1小时的滚动窗口将会定义以下开始时间的窗口：00:00:00，01:00:00，02:00:00，等等。 滑动窗口(sliding window) 对于滑动窗口，我们需要指定窗口的大小和滑动的步长。当滑动步长小于窗口大小时，窗口将会出现重叠，而元素会被分配到不止一个窗口中去。当滑动步长大于窗口大小时，一些元素可能不会被分配到任何窗口中去，会被直接丢弃。 下面的代码定义了窗口大小为1小时，滑动步长为15分钟的窗口。每一个元素将被分配到4个窗口中去。 scala123456789101112131415161718val slidingAvgTemp = sensorData .keyBy(_.id) .window( SlidingEventTimeWindows.of(Time.hours(1), Time.minutes(15)) ) .process(new TemperatureAverager)val slidingAvgTemp = sensorData .keyBy(_.id) .window( SlidingProcessingTimeWindows.of(Time.hours(1), Time.minutes(15)) ) .process(new TemperatureAverager)val slidingAvgTemp = sensorData .keyBy(_.id) .timeWindow(Time.hours(1), Time.minutes(15)) .process(new TemperatureAverager) 会话窗口(session windows) 会话窗口不可能重叠，并且会话窗口的大小也不是固定的。不活跃的时间长度定义了会话窗口的界限。不活跃的时间是指这段时间没有元素到达。下图展示了元素如何被分配到会话窗口。 scala123456789val sessionWindows = sensorData .keyBy(_.id) .window(EventTimeSessionWindows.withGap(Time.minutes(15))) .process(...)val sessionWindows = sensorData .keyBy(_.id) .window(ProcessingTimeSessionWindows.withGap(Time.minutes(15))) .process(...) 由于会话窗口的开始时间和结束时间取决于接收到的元素，所以窗口分配器无法立即将所有的元素分配到正确的窗口中去。相反，会话窗口分配器最开始时先将每一个元素分配到它自己独有的窗口中去，窗口开始时间是这个元素的时间戳，窗口大小是session gap的大小。接下来，会话窗口分配器会将出现重叠的窗口合并成一个窗口。 调用窗口计算函数window functions定义了窗口中数据的计算逻辑。有两种计算逻辑： 增量聚合函数(Incremental aggregation functions)：当一个事件被添加到窗口时，触发函数计算，并且更新window的状态(单个值)。最终聚合的结果将作为输出。ReduceFunction和AggregateFunction是增量聚合函数。 全窗口函数(Full window functions)：这个函数将会收集窗口中所有的元素，可以做一些复杂计算。ProcessWindowFunction是window function。 ReduceFunction 例子: 计算每个传感器15s窗口中的温度最小值 scala12345val minTempPerWindow: DataStream[(String, Double)] = sensorData .map(r =&gt; (r.id, r.temperature)) .keyBy(_._1) .timeWindow(Time.seconds(15)) .reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2))) AggregateFunction 先来看接口定义 scala123456789101112131415public interface AggregateFunction&lt;IN, ACC, OUT&gt; extends Function, Serializable &#123; // create a new accumulator to start a new aggregate ACC createAccumulator(); // add an input element to the accumulator and return the accumulator ACC add(IN value, ACC accumulator); // compute the result from the accumulator and return it. OUT getResult(ACC accumulator); // merge two accumulators and return the result. ACC merge(ACC a, ACC b);&#125; IN是输入元素的类型，ACC是累加器的类型，OUT是输出元素的类型。 例子 scala1234567891011121314151617181920212223242526272829val avgTempPerWindow: DataStream[(String, Double)] = sensorData .map(r =&gt; (r.id, r.temperature)) .keyBy(_._1) .timeWindow(Time.seconds(15)) .aggregate(new AvgTempFunction)// An AggregateFunction to compute the average temperature per sensor.// The accumulator holds the sum of temperatures and an event count.class AvgTempFunction extends AggregateFunction[(String, Double), (String, Double, Int), (String, Double)] &#123; override def createAccumulator() = &#123; (\"\", 0.0, 0) &#125; override def add(in: (String, Double), acc: (String, Double, Int)) = &#123; (in._1, in._2 + acc._2, 1 + acc._3) &#125; override def getResult(acc: (String, Double, Int)) = &#123; (acc._1, acc._2 / acc._3) &#125; override def merge(acc1: (String, Double, Int), acc2: (String, Double, Int)) = &#123; (acc1._1, acc1._2 + acc2._2, acc1._3 + acc2._3) &#125;&#125; ProcessWindowFunction 一些业务场景，我们需要收集窗口内所有的数据进行计算，例如计算窗口数据的中位数，或者计算窗口数据中出现频率最高的值。这样的需求，使用ReduceFunction和AggregateFunction就无法实现了。这个时候就需要ProcessWindowFunction了。 先来看接口定义 scala12345678910111213141516171819202122232425262728293031public abstract class ProcessWindowFunction&lt;IN, OUT, KEY, W extends Window&gt; extends AbstractRichFunction &#123; // Evaluates the window void process(KEY key, Context ctx, Iterable&lt;IN&gt; vals, Collector&lt;OUT&gt; out) throws Exception; // Deletes any custom per-window state when the window is purged public void clear(Context ctx) throws Exception &#123;&#125; // The context holding window metadata public abstract class Context implements Serializable &#123; // Returns the metadata of the window public abstract W window(); // Returns the current processing time public abstract long currentProcessingTime(); // Returns the current event-time watermark public abstract long currentWatermark(); // State accessor for per-window state public abstract KeyedStateStore windowState(); // State accessor for per-key global state public abstract KeyedStateStore globalState(); // Emits a record to the side output identified by the OutputTag. public abstract &lt;X&gt; void output(OutputTag&lt;X&gt; outputTag, X value); &#125;&#125; process()方法接受的参数为：window的key，Iterable迭代器包含窗口的所有元素，Collector用于输出结果流。Context参数和别的process方法一样。而ProcessWindowFunction的Context对象还可以访问window的元数据(窗口开始和结束时间)，当前处理时间和水位线，per-window state和per-key global state，side outputs。 per-window state: 用于保存一些信息，这些信息可以被process()访问，只要process所处理的元素属于这个窗口。 per-key global state: 同一个key，也就是在一条KeyedStream上，不同的window可以访问per-key global state保存的值。 例子：计算5s滚动窗口中的最低和最高的温度。输出的元素包含了(流的Key, 最低温度, 最高温度, 窗口结束时间)。 scala1234567891011121314151617181920val minMaxTempPerWindow: DataStream[MinMaxTemp] = sensorData .keyBy(_.id) .timeWindow(Time.seconds(5)) .process(new HighAndLowTempProcessFunction)case class MinMaxTemp(id: String, min: Double, max: Double, endTs: Long)class HighAndLowTempProcessFunction extends ProcessWindowFunction[SensorReading, MinMaxTemp, String, TimeWindow] &#123; override def process(key: String, ctx: Context, vals: Iterable[SensorReading], out: Collector[MinMaxTemp]): Unit = &#123; val temps = vals.map(_.temperature) val windowEnd = ctx.window.getEnd out.collect(MinMaxTemp(key, temps.min, temps.max, windowEnd)) &#125;&#125; 我们还可以将ReduceFunction/AggregateFunction和ProcessWindowFunction结合起来使用。ReduceFunction/AggregateFunction做增量聚合，ProcessWindowFunction提供更多的对数据流的访问权限。如果只使用ProcessWindowFunction(底层的实现为将事件都保存在ListState中)，将会非常占用空间。分配到某个窗口的元素将被提前聚合，而当窗口的trigger触发时，也就是窗口收集完数据关闭时，将会把聚合结果发送到ProcessWindowFunction中，这时Iterable参数将会只有一个值，就是前面聚合的值。 例子 scala12345678910111213input .keyBy(...) .timeWindow(...) .reduce( incrAggregator: ReduceFunction[IN], function: ProcessWindowFunction[IN, OUT, K, W])input .keyBy(...) .timeWindow(...) .aggregate( incrAggregator: AggregateFunction[IN, ACC, V], windowFunction: ProcessWindowFunction[V, OUT, K, W]) 我们把之前的需求重新使用以上两种方法实现一下。 scala12345678910111213141516171819202122232425case class MinMaxTemp(id: String, min: Double, max: Double, endTs: Long)val minMaxTempPerWindow2: DataStream[MinMaxTemp] = sensorData .map(r =&gt; (r.id, r.temperature, r.temperature)) .keyBy(_._1) .timeWindow(Time.seconds(5)) .reduce( (r1: (String, Double, Double), r2: (String, Double, Double)) =&gt; &#123; (r1._1, r1._2.min(r2._2), r1._3.max(r2._3)) &#125;, new AssignWindowEndProcessFunction() )class AssignWindowEndProcessFunction extends ProcessWindowFunction[(String, Double, Double), MinMaxTemp, String, TimeWindow] &#123; override def process(key: String, ctx: Context, minMaxIt: Iterable[(String, Double, Double)], out: Collector[MinMaxTemp]): Unit = &#123; val minMax = minMaxIt.head val windowEnd = ctx.window.getEnd out.collect(MinMaxTemp(key, minMax._2, minMax._3, windowEnd)) &#125;&#125; 自定义窗口操作符(windows operators)Flink内置的window operators分配器已经已经足够应付大多数应用场景。尽管如此，如果我们需要实现一些复杂的窗口逻辑，例如：可以发射早到的事件或者碰到迟到的事件就更新窗口的结果，或者窗口的开始和结束决定于特定事件的接收。 DataStream API暴露了接口和方法来自定义窗口操作符。 自定义窗口分配器 自定义窗口计算触发器(trigger) 自定义窗口数据清理功能(evictor) 当一个事件来到窗口操作符，首先将会传给WindowAssigner来处理。WindowAssigner决定了事件将被分配到哪些窗口。如果窗口不存在，WindowAssigner将会创建一个新的窗口。 如果一个window operator接受了一个增量聚合函数作为参数，例如ReduceFunction或者AggregateFunction，新到的元素将会立即被聚合，而聚合结果result将存储在window中。如果window operator没有使用增量聚合函数，那么新元素将被添加到ListState中，ListState中保存了所有分配给窗口的元素。 新元素被添加到窗口时，这个新元素同时也被传给了window的trigger。trigger定义了window何时准备好求值，何时window被清空。trigger可以基于window被分配的元素和注册的定时器来对窗口的所有元素求值或者在特定事件清空window中所有的元素。 当window operator只接收一个增量聚合函数作为参数时： 当window operator只接收一个全窗口函数作为参数时： 当window operator接收一个增量聚合函数和一个全窗口函数作为参数时： evictor是一个可选的组件，可以被注入到ProcessWindowFunction之前或者之后调用。evictor可以清除掉window中收集的元素。由于evictor需要迭代所有的元素，所以evictor只能使用在没有增量聚合函数作为参数的情况下。 下面的代码说明了如果使用自定义的trigger和evictor定义一个window operator： scala123456stream .keyBy(...) .window(...) [.trigger(...)] [.evictor(...)] .reduce/aggregate/process(...) 注意：每个WindowAssigner都有一个默认的trigger。 窗口生命周期 当WindowAssigner分配某个窗口的第一个元素时，这个窗口才会被创建。所以不存在没有元素的窗口。 一个窗口包含了如下状态： Window content 分配到这个窗口的元素 增量聚合的结果(如果window operator接收了ReduceFunction或者AggregateFunction作为参数)。 Window object WindowAssigner返回0个，1个或者多个window object。 window operator根据返回的window object来聚合元素。 每一个window object包含一个windowEnd时间戳，来区别于其他窗口。 触发器的定时器：一个触发器可以注册定时事件，到了定时的时间可以执行相应的回调函数，例如：对窗口进行求值或者清空窗口。 触发器中的自定义状态：触发器可以定义和使用自定义的、per-window或者per-key状态。这个状态完全被触发器所控制。而不是被window operator控制。 当窗口结束时间来到，window operator将删掉这个窗口。窗口结束时间是由window object的end timestamp所定义的。无论是使用processing time还是event time，窗口结束时间是什么类型可以调用WindowAssigner.isEventTime()方法获得。 窗口分配器(window assigners) WindowAssigner将会把元素分配到0个，1个或者多个窗口中去。我们看一下WindowAssigner接口： scala1234567891011121314151617181920public abstract class WindowAssigner&lt;T, W extends Window&gt; implements Serializable &#123; public abstract Collection&lt;W&gt; assignWindows( T element, long timestamp, WindowAssignerContext context); public abstract Trigger&lt;T, W&gt; getDefaultTriger( StreamExecutionEnvironment env); public abstract TypeSerializer&lt;W&gt; getWindowSerializer( ExecutionConfig executionConfig); public abstract boolean isEventTime(); public abstract static class WindowAssignerContext &#123; public abstract long getCurrentProcessingTime(); &#125;&#125; WindowAssigner有两个泛型参数： T: 事件的数据类型 W: 窗口的类型 下面的代码创建了一个自定义窗口分配器，是一个30秒的滚动事件时间窗口。 scala123456789101112131415161718192021222324252627282930class ThirtySecondsWindows extends WindowAssigner[Object, TimeWindow] &#123; val windowSize: Long = 30 * 1000L override def assignWindows( o: Object, ts: Long, ctx: WindowAssigner.WindowAssignerContext ): java.util.List[TimeWindow] = &#123; val startTime = ts - (ts % windowSize) val endTime = startTime + windowSize Collections.singletonList(new TimeWindow(startTime, endTime)) &#125; override def getDefaultTrigger( env: environment.StreamExecutionEnvironment ): Trigger[Object, TimeWindow] = &#123; EventTimeTrigger.create() &#125; override def getWindowSerializer( executionConfig: ExecutionConfig ): TypeSerializer[TimeWindow] = &#123; new TimeWindow.Serializer &#125; override def isEventTime = true&#125; 增量聚合示意图 全窗口聚合示意图 增量聚合和全窗口聚合结合使用的示意图 触发器(Triggers) 触发器定义了window何时会被求值以及何时发送求值结果。触发器可以到了特定的时间触发也可以碰到特定的事件触发。例如：观察到事件数量符合一定条件或者观察到了特定的事件。 默认的触发器将会在两种情况下触发 处理时间：机器时间到达处理时间 事件时间：水位线超过了窗口的结束时间 触发器可以访问流的时间属性以及定时器，还可以对state状态编程。所以触发器和process function一样强大。例如我们可以实现一个触发逻辑：当窗口接收到一定数量的元素时，触发器触发。再比如当窗口接收到一个特定元素时，触发器触发。还有就是当窗口接收到的元素里面包含特定模式(5秒钟内接收到了两个同样类型的事件)，触发器也可以触发。在一个事件时间的窗口中，一个自定义的触发器可以提前(在水位线没过窗口结束时间之前)计算和发射计算结果。这是一个常见的低延迟计算策略，尽管计算不完全，但不像默认的那样需要等待水位线没过窗口结束时间。 每次调用触发器都会产生一个TriggerResult来决定窗口接下来发生什么。TriggerResult可以取以下结果： CONTINUE：什么都不做 FIRE：如果window operator有ProcessWindowFunction这个参数，将会调用这个ProcessWindowFunction。如果窗口仅有增量聚合函数(ReduceFunction或者AggregateFunction)作为参数，那么当前的聚合结果将会被发送。窗口的state不变。 PURGE：窗口所有内容包括窗口的元数据都将被丢弃。 FIRE_AND_PURGE：先对窗口进行求值，再将窗口中的内容丢弃。 TriggerResult可能的取值使得我们可以实现很复杂的窗口逻辑。一个自定义触发器可以触发多次，可以计算或者更新结果，可以在发送结果之前清空窗口。 接下来我们看一下Trigger API： scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class Trigger&lt;T, W extends Window&gt; implements Serializable &#123; TriggerResult onElement( long timestamp, W window, TriggerContext ctx); public abstract TriggerResult onProcessingTime( long timestamp, W window, TriggerContext ctx); public abstract TriggerResult onEventTime( long timestamp, W window, TriggerContext ctx); public boolean canMerge(); public void onMerge(W window, OnMergeContext ctx); public abstract void clear(W window, TriggerContext ctx);&#125;public interface TriggerContext &#123; long getCurrentProcessingTime(); long getCurrentWatermark(); void registerProcessingTimeTimer(long time); void registerEventTimeTimer(long time); void deleteProcessingTimeTimer(long time); void deleteEventTimeTimer(long time); &lt;S extends State&gt; S getPartitionedState( StateDescriptor&lt;S, ?&gt; stateDescriptor);&#125;public interface OnMergeContext extends TriggerContext &#123; void mergePartitionedState( StateDescriptor&lt;S, ?&gt; stateDescriptor );&#125; 这里要注意两个地方：清空state和merging合并触发器。 当在触发器中使用per-window state时，这里我们需要保证当窗口被删除时state也要被删除，否则随着时间的推移，window operator将会积累越来越多的数据，最终可能使应用崩溃。 当窗口被删除时，为了清空所有状态，触发器的clear()方法需要需要删掉所有的自定义per-window state，以及使用TriggerContext对象将处理时间和事件时间的定时器都删除。 下面的例子展示了一个触发器在窗口结束时间之前触发。当第一个事件被分配到窗口时，这个触发器注册了一个定时器，定时时间为水位线之前一秒钟。当定时事件执行，将会注册一个新的定时事件，这样，这个触发器每秒钟最多触发一次。 scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class OneSecondIntervalTrigger extends Trigger[SensorReading, TimeWindow] &#123; override def onElement( r: SensorReading, timestamp: Long, window: TimeWindow, ctx: Trigger.TriggerContext ): TriggerResult = &#123; val firstSeen: ValueState[Boolean] = ctx .getPartitionedState( new ValueStateDescriptor[Boolean]( \"firstSeen\", classOf[Boolean] ) ) if (!firstSeen.value()) &#123; val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000)) ctx.registerEventTimeTimer(t) ctx.registerEventTimeTimer(window.getEnd) firstSeen.update(true) &#125; TriggerResult.CONTINUE &#125; override def onEventTime( timestamp: Long, window: TimeWindow, ctx: Trigger.TriggerContext ): TriggerResult = &#123; if (timestamp == window.getEnd) &#123; TriggerResult.FIRE_AND_PURGE &#125; else &#123; val t = ctx.getCurrentWatermark + (1000 - (ctx.getCurrentWatermark % 1000)) if (t &lt; window.getEnd) &#123; ctx.registerEventTimeTimer(t) &#125; TriggerResult.FIRE &#125; &#125; override def onProcessingTime( timestamp: Long, window: TimeWindow, ctx: Trigger.TriggerContext ): TriggerResult = &#123; TriggerResult.CONTINUE &#125; override def clear( window: TimeWindow, ctx: Trigger.TriggerContext ): Unit = &#123; val firstSeen: ValueState[Boolean] = ctx .getPartitionedState( new ValueStateDescriptor[Boolean]( \"firstSeen\", classOf[Boolean] ) ) firstSeen.clear() &#125;&#125; 清理器(EVICTORS) evictor可以在window function求值之前或者之后移除窗口中的元素。 我们看一下Evictor的接口定义： scala123456789101112131415161718192021public interface Evictor&lt;T, W extends Window&gt; extends Serializable &#123; void evictBefore( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext); void evictAfter( Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, int size, W window, EvictorContext evictorContext); interface EvictorContext &#123; long getCurrentProcessingTime(); long getCurrentWatermark(); &#125;&#125; evictBefore()和evictAfter()分别在window function计算之前或者之后调用。Iterable迭代器包含了窗口所有的元素，size为窗口中元素的数量，window object和EvictorContext可以访问当前处理时间和水位线。可以对Iterator调用remove()方法来移除窗口中的元素。 evictor也经常被用在GlobalWindow上，用来清除部分元素，而不是将窗口中的元素全部清空。 基于时间的双流Join数据流操作的另一个常见需求是对两条数据流中的事件进行联结（connect）或Join。Flink DataStream API中内置有两个可以根据时间条件对数据流进行Join的算子：基于间隔的Join和基于窗口的Join。本节我们会对它们进行介绍。 如果Flink内置的Join算子无法表达所需的Join语义，那么你可以通过CoProcessFunction、BroadcastProcessFunction或KeyedBroadcastProcessFunction实现自定义的Join逻辑。 注意，你要设计的Join算子需要具备高效的状态访问模式及有效的状态清理策略。 基于间隔的Join基于间隔的Join会对两条流中拥有相同键值以及彼此之间时间戳不超过某一指定间隔的事件进行Join。 下图展示了两条流（A和B）上基于间隔的Join，如果B中事件的时间戳相较于A中事件的时间戳不早于1小时且不晚于15分钟，则会将两个事件Join起来。Join间隔具有对称性，因此上面的条件也可以表示为A中事件的时间戳相较B中事件的时间戳不早于15分钟且不晚于1小时。 基于间隔的Join目前只支持事件时间以及INNER JOIN语义（无法发出未匹配成功的事件）。下面的例子定义了一个基于间隔的Join。 scala1234input1 .keyBy(...) .between(&lt;lower-bound&gt;, &lt;upper-bound&gt;) // 相对于input1的上下界 .process(ProcessJoinFunction) // 处理匹配的事件对 Join成功的事件对会发送给ProcessJoinFunction。下界和上界分别由负时间间隔和正时间间隔来定义，例如between(Time.hour(-1), Time.minute(15))。在满足下界值小于上界值的前提下，你可以任意对它们赋值。例如，允许出现B中事件的时间戳相较A中事件的时间戳早1～2小时这样的条件。 基于间隔的Join需要同时对双流的记录进行缓冲。对第一个输入而言，所有时间戳大于当前水位线减去间隔上界的数据都会被缓冲起来；对第二个输入而言，所有时间戳大于当前水位线加上间隔下界的数据都会被缓冲起来。注意，两侧边界值都有可能为负。上图中的Join需要存储数据流A中所有时间戳大于当前水位线减去15分钟的记录，以及数据流B中所有时间戳大于当前水位线减去1小时的记录。不难想象，如果两条流的事件时间不同步，那么Join所需的存储就会显著增加，因为水位线总是由“较慢”的那条流来决定。 例子：每个用户的点击Join这个用户最近10分钟内的浏览 scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import org.apache.flink.streaming.api.TimeCharacteristicimport org.apache.flink.streaming.api.functions.co.ProcessJoinFunctionimport org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractorimport org.apache.flink.streaming.api.scala._import org.apache.flink.streaming.api.windowing.time.Timeimport org.apache.flink.util.Collectorimport org.joda.time.DateTimeimport org.joda.time.format.DateTimeFormat// 需求：每个用户的点击Join这个用户最近10分钟内的浏览// 数据流clickStream// 某个用户在某个时刻点击了某个页面// &#123;\"userID\": \"user_2\", \"eventTime\": \"2019-11-16 17:30:02\", \"eventType\": \"click\", \"pageID\": \"page_1\"&#125;// 数据流browseStream// 某个用户在某个时刻浏览了某个商品，以及商品的价值// &#123;\"userID\": \"user_2\", \"eventTime\": \"2019-11-16 17:30:01\", \"eventType\": \"browse\", \"productID\": \"product_1\", \"productPrice\": 10&#125;object IntervalJoinExample &#123; case class UserClickLog(userID: String, eventTime: String, eventType: String, pageID: String) case class UserBrowseLog(userID: String, eventTime: String, eventType: String, productID: String, productPrice: String) def main(args: Array[String]): Unit = &#123; val env = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) val clickStream = env .fromElements( UserClickLog(\"user_2\", \"2019-11-16 17:30:00\", \"click\", \"page_1\") ) .assignTimestampsAndWatermarks( new BoundedOutOfOrdernessTimestampExtractor[UserClickLog](Time.seconds(0)) &#123; override def extractTimestamp(t: UserClickLog): Long = &#123; val dateTimeFormatter = DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\") val dateTime = DateTime.parse(t.eventTime, dateTimeFormatter) dateTime.getMillis &#125; &#125; ) val browseStream = env .fromElements( UserBrowseLog(\"user_2\", \"2019-11-16 17:19:00\", \"browse\", \"product_1\", \"10\"), UserBrowseLog(\"user_2\", \"2019-11-16 17:20:00\", \"browse\", \"product_1\", \"10\"), UserBrowseLog(\"user_2\", \"2019-11-16 17:22:00\", \"browse\", \"product_1\", \"10\"), UserBrowseLog(\"user_2\", \"2019-11-16 17:26:00\", \"browse\", \"product_1\", \"10\"), UserBrowseLog(\"user_2\", \"2019-11-16 17:30:00\", \"browse\", \"product_1\", \"10\"), UserBrowseLog(\"user_2\", \"2019-11-16 17:31:00\", \"browse\", \"product_1\", \"10\") ) .assignTimestampsAndWatermarks( new BoundedOutOfOrdernessTimestampExtractor[UserBrowseLog](Time.seconds(0)) &#123; override def extractTimestamp(t: UserBrowseLog): Long = &#123; val dateTimeFormatter = DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\") val dateTime = DateTime.parse(t.eventTime, dateTimeFormatter) dateTime.getMillis &#125; &#125; ) clickStream .keyBy(\"userID\") .intervalJoin(browseStream.keyBy(\"userID\")) .between(Time.minutes(-10),Time.seconds(0)) .process(new MyIntervalJoin) .print() env.execute() &#125; class MyIntervalJoin extends ProcessJoinFunction[UserClickLog, UserBrowseLog, String] &#123; override def processElement( left: UserClickLog, right: UserBrowseLog, context: ProcessJoinFunction[UserClickLog, UserBrowseLog, String]#Context, out: Collector[String] ): Unit = &#123; out.collect(left +\" =Interval Join=&gt; \"+right) &#125; &#125;&#125; 基于窗口的Join顾名思义，基于窗口的Join需要用到Flink中的窗口机制。其原理是将两条输入流中的元素分配到公共窗口中并在窗口完成时进行Join（或Cogroup）。 下面的例子展示了如何定义基于窗口的Join。 scala1234567input1.join(input2) .where(...) // 为input1指定键值属性 .equalTo(...) // 为input2指定键值属性 .window(...) // 指定WindowAssigner [.trigger(...)] // 选择性的指定Trigger [.evictor(...)] // 选择性的指定Evictor .apply(...) // 指定JoinFunction 下图展示了DataStream API中基于窗口的Join是如何工作的。 两条输入流都会根据各自的键值属性进行分区，公共窗口分配器会将二者的事件映射到公共窗口内（其中同时存储了两条流中的数据）。当窗口的计时器触发时，算子会遍历两个输入中元素的每个组合（叉乘积）去调用JoinFunction。同时你也可以自定义触发器或移除器。由于两条流中的事件会被映射到同一个窗口中，因此该过程中的触发器和移除器与常规窗口算子中的完全相同。 除了对窗口中的两条流进行Join，你还可以对它们进行Cogroup，只需将算子定义开始位置的join改为coGroup()即可。Join和Cogroup的总体逻辑相同，二者的唯一区别是：Join会为两侧输入中的每个事件对调用JoinFunction；而Cogroup中用到的CoGroupFunction会以两个输入的元素遍历器为参数，只在每个窗口中被调用一次。 注意，对划分窗口后的数据流进行Join可能会产生意想不到的语义。例如，假设你为执行Join操作的算子配置了1小时的滚动窗口，那么一旦来自两个输入的元素没有被划分到同一窗口，它们就无法Join在一起，即使二者彼此仅相差1秒钟。 处理迟到的元素(Handling Late Data)水位线可以用来平衡计算的完整性和延迟两方面。除非我们选择一种非常保守的水位线策略(最大延时设置的非常大，以至于包含了所有的元素，但结果是非常大的延迟)，否则我们总需要处理迟到的元素。 迟到的元素是指当这个元素来到时，这个元素所对应的窗口已经计算完毕了(也就是说水位线已经没过窗口结束时间了)。这说明迟到这个特性只针对事件时间。 DataStream API提供了三种策略来处理迟到元素 直接抛弃迟到的元素 将迟到的元素发送到另一条流中去 可以更新窗口已经计算完的结果，并发出计算结果。 抛弃迟到元素抛弃迟到的元素是event time window operator的默认行为。也就是说一个迟到的元素不会创建一个新的窗口。 process function可以通过比较迟到元素的时间戳和当前水位线的大小来很轻易的过滤掉迟到元素。 重定向迟到元素迟到的元素也可以使用侧输出(side output)特性被重定向到另外的一条流中去。迟到元素所组成的侧输出流可以继续处理或者sink到持久化设施中去。 例子 scala12345678910111213141516171819202122val readings = env .socketTextStream(\"localhost\", 9999, '\\n') .map(line =&gt; &#123; val arr = line.split(\" \") (arr(0), arr(1).toLong * 1000) &#125;) .assignAscendingTimestamps(_._2)val countPer10Secs = readings .keyBy(_._1) .timeWindow(Time.seconds(10)) .sideOutputLateData( new OutputTag[(String, Long)](\"late-readings\") ) .process(new CountFunction())val lateStream = countPer10Secs .getSideOutput( new OutputTag[(String, Long)](\"late-readings\") )lateStream.print() 实现CountFunction: scala123456789class CountFunction extends ProcessWindowFunction[(String, Long), String, String, TimeWindow] &#123; override def process(key: String, context: Context, elements: Iterable[(String, Long)], out: Collector[String]): Unit = &#123; out.collect(\"窗口共有\" + elements.size + \"条数据\") &#125;&#125; 下面这个例子展示了ProcessFunction如何过滤掉迟到的元素然后将迟到的元素发送到侧输出流中去。 scala123456789101112131415161718192021222324252627282930val readings: DataStream[SensorReading] = ???val filteredReadings: DataStream[SensorReading] = readings .process(new LateReadingsFilter)// retrieve late readingsval lateReadings: DataStream[SensorReading] = filteredReadings .getSideOutput(new OutputTag[SensorReading](\"late-readings\"))/** A ProcessFunction that filters out late sensor readings and * re-directs them to a side output */class LateReadingsFilter extends ProcessFunction[SensorReading, SensorReading] &#123; val lateReadingsOut = new OutputTag[SensorReading](\"late-readings\") override def processElement( r: SensorReading, ctx: ProcessFunction[SensorReading, SensorReading]#Context, out: Collector[SensorReading]): Unit = &#123; // compare record timestamp with current watermark if (r.timestamp &lt; ctx.timerService().currentWatermark()) &#123; // this is a late reading =&gt; redirect it to the side output ctx.output(lateReadingsOut, r) &#125; else &#123; out.collect(r) &#125; &#125;&#125; 使用迟到元素更新窗口计算结果(Updating Results by Including Late Events)由于存在迟到的元素，所以已经计算出的窗口结果是不准确和不完全的。我们可以使用迟到元素更新已经计算完的窗口结果。 如果我们要求一个operator支持重新计算和更新已经发出的结果，就需要在第一次发出结果以后也要保存之前所有的状态。但显然我们不能一直保存所有的状态，肯定会在某一个时间点将状态清空，而一旦状态被清空，结果就再也不能重新计算或者更新了。而迟到的元素只能被抛弃或者发送到侧输出流。 window operator API提供了方法来明确声明我们要等待迟到元素。当使用event-time window，我们可以指定一个时间段叫做allowed lateness。window operator如果设置了allowed lateness，这个window operator在水位线没过窗口结束时间时也将不会删除窗口和窗口中的状态。窗口会在一段时间内(allowed lateness设置的)保留所有的元素。 当迟到元素在allowed lateness时间内到达时，这个迟到元素会被实时处理并发送到触发器(trigger)。当水位线没过了窗口结束时间+allowed lateness时间时，窗口会被删除，并且所有后来的迟到的元素都会被丢弃。 Allowed lateness可以使用allowedLateness()方法来指定，如下所示： scala123456789101112131415161718192021222324252627282930313233343536373839404142val readings: DataStream[SensorReading] = ...val countPer10Secs: DataStream[(String, Long, Int, String)] = readings .keyBy(_.id) .timeWindow(Time.seconds(10)) // process late readings for 5 additional seconds .allowedLateness(Time.seconds(5)) // count readings and update results if late readings arrive .process(new UpdatingWindowCountFunction) /** A counting WindowProcessFunction that distinguishes between * first results and updates. */class UpdatingWindowCountFunction extends ProcessWindowFunction[SensorReading, (String, Long, Int, String), String, TimeWindow] &#123; override def process( id: String, ctx: Context, elements: Iterable[SensorReading], out: Collector[(String, Long, Int, String)]): Unit = &#123; // count the number of readings val cnt = elements.count(_ =&gt; true) // state to check if this is // the first evaluation of the window or not val isUpdate = ctx.windowState.getState( new ValueStateDescriptor[Boolean]( \"isUpdate\", Types.of[Boolean])) if (!isUpdate.value()) &#123; // first evaluation, emit first result out.collect((id, ctx.window.getEnd, cnt, \"first\")) isUpdate.update(true) &#125; else &#123; // not the first evaluation, emit an update out.collect((id, ctx.window.getEnd, cnt, \"update\")) &#125; &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flume源码修改之flumeTailDirSource兼容log4j","slug":"flume源码修改之flumeTailDirSource兼容log4j","date":"2020-06-30T13:41:57.000Z","updated":"2020-06-30T14:49:36.440Z","comments":true,"path":"2020/06/30/flume源码修改之flumeTailDirSource兼容log4j/","link":"","permalink":"https://masteryang4.github.io/2020/06/30/flume%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9%E4%B9%8BflumeTailDirSource%E5%85%BC%E5%AE%B9log4j/","excerpt":"","text":"tailDir Source优点1）断点续传 2）同时监控多目录 存在的问题1）说明：使用正则表达式监控文件名时，当修改文件名称之后，会重复读取数据。 2）示例： 配置信息 test.conf Code12345678910111213141516171819202122# Name the components on this agenta1.sources &#x3D; r1a1.sinks &#x3D; k1a1.channels &#x3D; c1# Describe&#x2F;configure the sourcea1.sources.r1.type &#x3D; TAILDIRa1.sources.r1.filegroups &#x3D; f1a1.sources.r1.filegroups.f1 &#x3D; &#x2F;opt&#x2F;module&#x2F;data&#x2F;flume.*a1.sources.r1.positionFile &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;taildir&#x2F;taildir_flume.json# Describe the sinka1.sinks.k1.type &#x3D; logger# Use a channel which buffers events in memorya1.channels.c1.type &#x3D; memorya1.channels.c1.capacity &#x3D; 1000a1.channels.c1.transactionCapacity &#x3D; 100# Bind the source and sink to the channela1.sources.r1.channels &#x3D; c1a1.sinks.k1.channel &#x3D; c1 3）启动任务 shell1[ysss@hadoop102 flume]$ bin/flume-ng agent -n a1 -c conf -f conf/test.conf -Dflume.root.logger=INFO,console 4）测试 （1）在/opt/module/data目录下创建flume.log shell123[ysss@hadoop102 data]$ pwd/opt/module/data[ysss@hadoop102 data]$ touch flume.log （2）向flume.log文件中添加数据 shell12[ysss@hadoop102 data]$ echo hello &gt;&gt; flume.log [ysss@hadoop102 data]$ echo ysss &gt;&gt; flume.log （3）查看监控Flume控制台 （4）修改flume.log为flume.2020-06-09.log （5）再次查看监控Flume控制台 解决方案1）方案一 跟公司后台人员协商； 让他们使用类似logback不更名打印日志框架，不要使用log4j会更名的打印日志框架。对于不想协商、项目经理或组长偏向JAVA组的，只能使用方案二了。 2）方案二 修改TailDirSource源码: 1、flume-taildir-source\\src\\main\\java\\org\\apache\\flume\\source\\taildir\\TailFile.java java1234567891011public boolean updatePos(String path, long inode, long pos) throws IOException &#123; // if (this.inode == inode &amp;&amp; this.path.equals(path)) &#123; // ysss if (this.inode == inode) &#123; setPos(pos); updateFilePos(pos); logger.info(\"Updated position, file: \" + path + \", inode: \" + inode + \", pos: \" + pos); return true; &#125; return false; &#125; 2、\\src\\main\\java\\org\\apache\\flume\\source\\taildir\\ReliableTaildirEventReader.java java123456789101112131415161718192021222324252627282930313233343536373839404142434445** * Update tailFiles mapping if a new file is created or appends are detected * to the existing file. */ public List&lt;Long&gt; updateTailFiles(boolean skipToEnd) throws IOException &#123; updateTime = System.currentTimeMillis(); List&lt;Long&gt; updatedInodes = Lists.newArrayList(); for (TaildirMatcher taildir : taildirCache) &#123; Map&lt;String, String&gt; headers = headerTable.row(taildir.getFileGroup()); for (File f : taildir.getMatchingFiles()) &#123; long inode; try &#123; inode = getInode(f); &#125; catch (NoSuchFileException e) &#123; logger.info(\"File has been deleted in the meantime: \" + e.getMessage()); continue; &#125; TailFile tf = tailFiles.get(inode); //if (tf == null || !tf.getPath().equals(f.getAbsolutePath())) &#123; //ysss if (tf == null) &#123; long startPos = skipToEnd ? f.length() : 0; tf = openFile(f, headers, inode, startPos); &#125; else &#123; boolean updated = tf.getLastUpdated() &lt; f.lastModified() || tf.getPos() != f.length(); if (updated) &#123; if (tf.getRaf() == null) &#123; tf = openFile(f, headers, inode, tf.getPos()); &#125; if (f.length() &lt; tf.getPos()) &#123; logger.info(\"Pos \" + tf.getPos() + \" is larger than file size! \" + \"Restarting from pos 0, file: \" + tf.getPath() + \", inode: \" + inode); tf.updatePos(tf.getPath(), inode, 0); &#125; &#125; tf.setNeedTail(updated); &#125; tailFiles.put(inode, tf); updatedInodes.add(inode); &#125; &#125; return updatedInodes; &#125; 总结 taildir和logback配合使用，为什么不是log4j？ logback的日志：ysss.2020-05-18.log，ysss.2020-05-19.log Log4j的日志：ysss.log -&gt; ysss.2020-05-18.log，在一天过去之后，改名为后者存盘 Linux对于文件而言 ​ (1) 全路径 ​ (2) Inode(Linux文件的唯一标识,修改名称不会改动INode值) 但是tailDirSource的工作机制：文件更名或者INode改变都会被识别为一个新文件！也就是说，如果使用log4j，日志会更名，被tailDirSource识别为一个新文件，重复读取。 如果非要使用log4j怎么办呢？ 改flume源码！只有INode改变才会是被为一个新文件！ source\\taildir\\TailFile.java 的 updatePos 方法 source\\taildir\\ReliableTaildirEventReader.java 的 updateTailFiles 方法","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flume","slug":"大数据/flume","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flume/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://masteryang4.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flume","slug":"flume","permalink":"https://masteryang4.github.io/tags/flume/"}]},{"title":"flume拦截器之flumeHDFS_Sink时间问题","slug":"flume拦截器之flumeHDFS-Sink时间问题","date":"2020-06-30T13:38:37.000Z","updated":"2020-06-30T13:43:23.484Z","comments":true,"path":"2020/06/30/flume拦截器之flumeHDFS-Sink时间问题/","link":"","permalink":"https://masteryang4.github.io/2020/06/30/flume%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B9%8BflumeHDFS-Sink%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/","excerpt":"","text":"HDFS Sink存在的问题hdfs.useLocalTimeStamp设置为true，也会在Event头信息中添加”timestamp”的key 我们一般设置为false，因为我们目前使用的是KafkaSource，会根据当前系统时间添加该头信息。 说明：HDFS Sink要想根据时间滚动文件夹，必须在Event头信息中添加”timestamp”的key用于提供给HDFS Sink使用。 我们目前使用的是KafkaSource，会根据当前系统时间添加该头信息。 问题：我们使用的是按照每天的具体时间来创建新的目录，假如我们Flume任务在夜间11点多挂了，零点以后任务才被重新启动，那么昨天的挂掉之后的数据就会被算作第二天的数据了。 解决方案我们需要根据事件内部时间来控制HDFS目录时间的创建， 思路为自定义拦截器来修改KafkaSource自动添加的时间戳。 使用事件内部时间【替换】KafkaSource自动添加的时间戳 1）创建Maven工程flume-interceptor 2）创建包名：com.ysss.flume.interceptor 3）在pom.xml文件中添加如下配置 xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.flume&lt;/groupId&gt; &lt;artifactId&gt;flume-ng-core&lt;/artifactId&gt; &lt;version&gt;1.9.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 4）在com.ysss.flume.interceptor包下创建TimeStampInterceptor类 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.ysss.interceptor;import com.alibaba.fastjson.JSONObject;import org.apache.flume.Context;import org.apache.flume.Event;import org.apache.flume.interceptor.Interceptor;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Map;public class TimeStampInterceptor implements Interceptor &#123; private ArrayList&lt;Event&gt; events = new ArrayList&lt;&gt;(); @Override public void initialize() &#123; &#125; @Override public Event intercept(Event event) &#123; Map&lt;String, String&gt; headers = event.getHeaders(); String log = new String(event.getBody(), StandardCharsets.UTF_8); JSONObject jsonObject = JSONObject.parseObject(log); String ts = jsonObject.getString(\"ts\"); headers.put(\"timestamp\", ts); return event; &#125; @Override public List&lt;Event&gt; intercept(List&lt;Event&gt; list) &#123; events.clear(); for (Event event : list) &#123; events.add(intercept(event)); &#125; return events; &#125; @Override public void close() &#123; &#125; public static class Builder implements Interceptor.Builder &#123; @Override public Interceptor build() &#123; return new TimeStampInterceptor(); &#125; @Override public void configure(Context context) &#123; &#125; &#125;&#125; 5）打包 flume-interceptor-1.0-SNAPSHOT-jar-with-dependencies.jar 6）需要先将打好的包放入到hadoop102的/opt/module/flume/lib文件夹下面。 shell12[ysss@hadoop102 lib]$ ls | grep interceptorflume-interceptor-1.0-SNAPSHOT-jar-with-dependencies.jar 7）分发Flume到hadoop103、hadoop104 shell1[ysss@hadoop102 module]$ xsync flume/ 调整消费Flume配置文件shell12[ysss@hadoop104 conf]$ pwd/opt/module/flume/conf 修改配置文件kafka-flume-hdfs.conf Code123456789101112131415161718192021222324252627282930313233343536373839#组件a1.sources&#x3D;r1a1.channels&#x3D;c1a1.sinks&#x3D;k1#sourcea1.sources.r1.type &#x3D; org.apache.flume.source.kafka.KafkaSourcea1.sources.r1.batchSize &#x3D; 5000a1.sources.r1.batchDurationMillis &#x3D; 2000a1.sources.r1.kafka.bootstrap.servers &#x3D; hadoop102:9092,hadoop103:9092,hadoop104:9092a1.sources.r1.kafka.topics&#x3D;topic_loga1.sources.r1.interceptors &#x3D; i1a1.sources.r1.interceptors.i1.type &#x3D; com.ysss.interceptor.TimeStampInterceptor$Builder #【注意】#channela1.channels.c1.type &#x3D; filea1.channels.c1.checkpointDir &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;checkpoint&#x2F;behavior1a1.channels.c1.dataDirs &#x3D; &#x2F;opt&#x2F;module&#x2F;flume&#x2F;data&#x2F;behavior1&#x2F;a1.channels.c1.maxFileSize &#x3D; 2146435071a1.channels.c1.capacity &#x3D; 1000000a1.channels.c1.keep-alive &#x3D; 6#sinka1.sinks.k1.type &#x3D; hdfsa1.sinks.k1.hdfs.path &#x3D; &#x2F;origin_data&#x2F;gmall&#x2F;log&#x2F;topic_log&#x2F;%Y-%m-%da1.sinks.k1.hdfs.filePrefix &#x3D; log-a1.sinks.k1.hdfs.round &#x3D; falsea1.sinks.k1.hdfs.rollInterval &#x3D; 10a1.sinks.k1.hdfs.rollSize &#x3D; 134217728a1.sinks.k1.hdfs.rollCount &#x3D; 0#控制输出文件是原生文件。a1.sinks.k1.hdfs.fileType &#x3D; CompressedStreama1.sinks.k1.hdfs.codeC &#x3D; lzop#拼装a1.sources.r1.channels &#x3D; c1a1.sinks.k1.channel&#x3D; c1","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flume","slug":"大数据/flume","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flume/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://masteryang4.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flume","slug":"flume","permalink":"https://masteryang4.github.io/tags/flume/"}]},{"title":"OLAP和OLTP的区别","slug":"OLAP和OLTP的区别","date":"2020-06-28T17:12:12.000Z","updated":"2020-06-28T17:14:10.668Z","comments":true,"path":"2020/06/29/OLAP和OLTP的区别/","link":"","permalink":"https://masteryang4.github.io/2020/06/29/OLAP%E5%92%8COLTP%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"OLAP和OLTP的区别OLAP（On-Line Analytical Processing）联机分析处理，也称为面向交易的处理过程，其基本特征是前台接收的用户数据可以立即传送到计算中心进行处理，并在很短的时间内给出处理结果，是对用户操作快速响应的方式之一。应用在数据仓库，使用对象是决策者。OLAP系统强调的是数据分析，响应速度要求没那么高。 OLTP（On-Line Transaction Processing）联机事务处理，它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的。它具有FASMI(Fast Analysis of Shared Multidimensional Information)，即共享多维信息的快速分析的特征。主要应用是传统关系型数据库。OLTP系统强调的是内存效率，实时性比较高。 以下是OLAP和OLTP的比较图1： 图2：","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"数据库","slug":"数据库","permalink":"https://masteryang4.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"flink系列05Flink DataStream API","slug":"flink系列05Flink-DataStream-API","date":"2020-06-27T15:28:18.000Z","updated":"2020-06-27T15:29:00.972Z","comments":true,"path":"2020/06/27/flink系列05Flink-DataStream-API/","link":"","permalink":"https://masteryang4.github.io/2020/06/27/flink%E7%B3%BB%E5%88%9705Flink-DataStream-API/","excerpt":"","text":"第五章，Flink DataStream API本章介绍了Flink DataStream API的基本知识。我们展示了典型的Flink流处理程序的结构和组成部分，还讨论了Flink的类型系统以及支持的数据类型，还展示了数据和分区转换操作。窗口操作符，基于时间语义的转换操作，有状态的操作符，以及和外部系统的连接器将在接下来的章节进行介绍。阅读完这一章后，我们将会知道如何去实现一个具有基本功能的流处理程序。我们的示例程序采用Scala语言，因为Scala语言相对比较简洁。但Java API也是十分类似的（特殊情况，我们将会指出）。在我们的Github仓库里，我们所写的应用程序具有Scala和Java两种版本。 你好，Flink！让我们写一个简单的例子来获得使用DataStream API编写流处理应用程序的粗浅印象。我们将使用这个简单的示例来展示一个Flink程序的基本结构，以及介绍一些DataStream API的重要特性。我们的示例程序摄取了一条（来自多个传感器的）温度测量数据流。 首先让我们看一下表示传感器读数的数据结构： scala1234case class SensorReading( id: String, timestamp: Long, temperature: Double) 示例程序5-1将温度从华氏温度读数转换成摄氏温度读数，然后针对每一个传感器，每5秒钟计算一次平均温度纸。 scala1234567891011121314151617181920212223242526272829303132// Scala object that defines// the DataStream program in the main() method.object AverageSensorReadings &#123; // main() defines and executes the DataStream program def main(args: Array[String]) &#123; // set up the streaming execution environment val env = StreamExecutionEnvironment.getExecutionEnvironment // use event time for the application env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime) // create a DataStream[SensorReading] from a stream source val sensorData: DataStream[SensorReading] = env // ingest sensor readings with a SensorSource SourceFunction .addSource(new SensorSource) // assign timestamps and watermarks (required for event time) val avgTemp: DataStream[SensorReading] = sensorData // convert Fahrenheit to Celsius with an inline lambda function .map( r =&gt; &#123; val celsius = (r.temperature - 32) * (5.0 / 9.0) SensorReading(r.id, r.timestamp, celsius) &#125;) // organize readings by sensor id .keyBy(_.id) // group readings in 5 second tumbling windows .timeWindow(Time.seconds(5)) // compute average temperature using a user-defined function .apply(new TemperatureAverager) // print result stream to standard out avgTemp.print() // execute application env.execute(\"Compute average sensor temperature\") &#125;&#125; 你可能已经注意到Flink程序的定义和提交执行使用的就是正常的Scala或者Java的方法。大多数情况下，这些代码都写在一个静态main方法中。在我们的例子中，我们定义了AverageSensorReadings对象，然后将大多数的应用程序逻辑放在了main()中。 Flink流处理程序的结构如下： 创建Flink程序执行环境。 从数据源读取一条或者多条流数据 使用流转换算子实现业务逻辑 将计算结果输出到一个或者多个外部设备（可选） 执行程序 接下来我们详细的学习一下这些部分。 搭建执行环境编写Flink程序的第一件事情就是搭建执行环境。执行环境决定了程序是运行在单机上还是集群上。在DataStream API中，程序的执行环境是由StreamExecutionEnvironment设置的。在我们的例子中，我们通过调用静态getExecutionEnvironment()方法来获取执行环境。这个方法根据调用方法的上下文，返回一个本地的或者远程的环境。如果这个方法是一个客户端提交到远程集群的代码调用的，那么这个方法将会返回一个远程的执行环境。否则，将返回本地执行环境。 也可以用下面的方法来显式的创建本地或者远程执行环境： scala12345678910// create a local stream execution environmentval localEnv = StreamExecutionEnvironment .createLocalEnvironment()// create a remote stream execution environmentval remoteEnv = StreamExecutionEnvironment .createRemoteEnvironment( \"host\", // hostname of JobManager 1234, // port of JobManager process \"path/to/jarFile.jar\" ) // JAR file to ship to the JobManager 接下来，我们使用env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)来将我们程序的时间语义设置为事件时间。执行环境提供了很多配置选项，例如：设置程序的并行度和程序是否开启容错机制。 读取输入流一旦执行环境设置好，就该写业务逻辑了。StreamExecutionEnvironment提供了创建数据源的方法，这些方法可以从数据流中将数据摄取到程序中。数据流可以来自消息队列或者文件系统，也可能是实时产生的（例如socket）。 在我们的例子里面，我们这样写： scala12val sensorData: DataStream[SensorReading] = env .addSource(new SensorSource) 这样就可以连接到传感器测量数据的数据源并创建一个类型为SensorReading的DataStream了。Flink支持很多数据类型，我们将在接下来的章节里面讲解。在我们的例子里面，我们的数据类型是一个定义好的Scala样例类。SensorReading样例类包含了传感器ID，数据的测量时间戳，以及测量温度值。assignTimestampsAndWatermarks(new SensorTimeAssigner)方法指定了如何设置事件时间语义的时间戳和水位线。有关SensorTimeAssigner我们后面再讲。 转换算子的使用一旦我们有一条DataStream，我们就可以在这条数据流上面使用转换算子了。转换算子有很多种。一些转换算子可以产生一条新的DataStream，当然这个DataStream的类型可能是新类型。还有一些转换算子不会改变原有DataStream的数据，但会将数据流分区或者分组。业务逻辑就是由转换算子串起来组合而成的。 在我们的例子中，我们首先使用map()转换算子将传感器的温度值转换成了摄氏温度单位。然后，我们使用keyBy()转换算子将传感器读数流按照传感器ID进行分区。接下来，我们定义了一个timeWindow()转换算子，这个算子将每个传感器ID所对应的分区的传感器读数分配到了5秒钟的滚动窗口中。 scala12345678val avgTemp: DataStream[SensorReading] = sensorData .map(r =&gt; &#123; val celsius = (r.temperature - 32) * (5.0 / 9.0) SensorReading(r.id, r.timestamp, celsius) &#125;) .keyBy(_.id) .timeWindow(Time.seconds(5)) .apply(new TemperatureAverager) 窗口转换算子将在“窗口操作符”一章中讲解。最后，我们使用了一个UDF函数来计算每个窗口的温度的平均值。我们稍后将会讨论UDF函数的实现。 输出结果流处理程序经常将它们的计算结果发送到一些外部系统中去，例如：Apache Kafka，文件系统，或者数据库中。Flink提供了一个维护的很好的sink算子的集合，这些sink算子可以用来将数据写入到不同的系统中去。我们也可以实现自己的sink算子。也有一些Flink程序并不会向第三方外部系统发送数据，而是将数据存储到Flink系统内部，然后可以使用Flink的可查询状态的特性来查询数据。 在我们的例子中，计算结果是一个DataStream[SensorReading]数据记录。每一条数据记录包含了一个传感器在5秒钟的周期里面的平均温度。计算结果组成的数据流将会调用print()将计算结果写到标准输出。 scala1avgTemp.print() 要注意一点，流的Sink算子的选择将会影响应用程序端到端(end-to-end)的一致性，具体就是应用程序的计算提供的到底是at-least-once还是exactly-once的一致性语义。应用程序端到端的一致性依赖于所选择的流的Sink算子和Flink的检查点算法的集成使用。 执行当应用程序完全写好时，我们可以调用StreamExecutionEnvironment.execute()来执行应用程序。在我们的例子中就是我们的最后一行调用： scala1env.execute(\"Compute average sensor temperature\") Flink程序是惰性执行的。也就是说创建数据源和转换算子的API调用并不会立刻触发任何数据处理逻辑。API调用仅仅是在执行环境中构建了一个执行计划，这个执行计划包含了执行环境创建的数据源和所有的将要用在数据源上的转换算子。只有当execute()被调用时，系统才会触发程序的执行。 构建好的执行计划将被翻译成一个JobGraph并提交到JobManager上面去执行。根据执行环境的种类，一个JobManager将会运行在一个本地线程中（如果是本地执行环境的化）或者JobGraph将会被发送到一个远程的JobManager上面去。如果JobManager远程运行，那么JobGraph必须和一个包含有所有类和应用程序的依赖的JAR包一起发送到远程JobManager。 产生传感器读数代码编写从批读取数据scala1234567val stream = env .fromCollection(List( SensorReading(\"sensor_1\", 1547718199, 35.80018327300259), SensorReading(\"sensor_6\", 1547718199, 15.402984393403084), SensorReading(\"sensor_7\", 1547718199, 6.720945201171228), SensorReading(\"sensor_10\", 1547718199, 38.101067604893444) )) 从文件读取数据scala1val stream = env.readTextFile(filePath) 以Kafka消息队列的数据为数据来源scala123456789101112131415161718192021222324val properties = new Properties()properties.setProperty(\"bootstrap.servers\", \"localhost:9092\")properties.setProperty(\"group.id\", \"consumer-group\")properties.setProperty( \"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\")properties.setProperty( \"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\")properties.setProperty(\"auto.offset.reset\", \"latest\")val env = StreamExecutionEnvironment.getExecutionEnvironmentenv.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)env.setParallelism(1)val stream = env // source为来自Kafka的数据，这里我们实例化一个消费者，topic为hotitems .addSource( new FlinkKafkaConsumer[String]( \"hotitems\", new SimpleStringSchema(), properties ) ) 注意，Kafka的版本为2.2。 自定义数据源scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Calendarimport org.apache.flink.streaming.api.functions.source.RichParallelSourceFunctionimport org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContextimport scala.util.Random// 传感器id，时间戳，温度case class SensorReading(id: String, timestamp: Long, temperature: Double)// 需要extends RichParallelSourceFunction, 泛型为SensorReadingclass SensorSource extends RichParallelSourceFunction[SensorReading] &#123; // flag indicating whether source is still running. // flag: 表示数据源是否还在正常运行 var running: Boolean = true // run()函数连续的发送SensorReading数据，使用SourceContext // 需要override override def run(srcCtx: SourceContext[SensorReading]): Unit = &#123; // initialize random number generator // 初始化随机数发生器 val rand = new Random() // look up index of this parallel task // 查找当前运行时上下文的任务的索引 val taskIdx = this.getRuntimeContext.getIndexOfThisSubtask // initialize sensor ids and temperatures // 初始化10个(温度传感器的id, 温度值)元组 var curFTemp = (1 to 10).map &#123; // nextGaussian产生高斯随机数 i =&gt; (\"sensor_\" + (taskIdx * 10 + i), 65 + (rand.nextGaussian() * 20)) &#125; // emit data until being canceled // 无限循环，产生数据流 while (running) &#123; // update temperature // 更新温度 curFTemp = curFTemp.map(t =&gt; (t._1, t._2 + (rand.nextGaussian() * 0.5)) ) // get current time // 获取当前时间戳 val curTime = Calendar.getInstance.getTimeInMillis // emit new SensorReading // 发射新的传感器数据, 注意这里srcCtx.collect curFTemp.foreach(t =&gt; srcCtx.collect(SensorReading(t._1, curTime, t._2))) // wait for 100 ms Thread.sleep(100) &#125; &#125; // override cancel函数 override def cancel(): Unit = &#123; running = false &#125;&#125; 使用方法 scala1234// ingest sensor streamval sensorData: DataStream[SensorReading] = env // SensorSource generates random temperature readings .addSource(new SensorSource) 注意，在我们本教程中，我们一直会使用这个自定义的数据源。 转换算子在这一小节我们将大概看一下DataStream API的基本转换算子。与时间有关的操作符（例如窗口操作符和其他特殊的转换算子）将会在后面的章节叙述。一个流的转换操作将会应用在一个或者多个流上面，这些转换操作将流转换成一个或者多个输出流。编写一个DataStream API简单来说就是将这些转换算子组合在一起来构建一个数据流图，这个数据流图就实现了我们的业务逻辑。 大部分的流转换操作都基于用户自定义函数UDF。UDF函数打包了一些业务逻辑并定义了输入流的元素如何转换成输出流的元素。像MapFunction这样的函数，将会被定义为类，这个类实现了Flink针对特定的转换操作暴露出来的接口。 scala123class MyMapFunction extends MapFunction[Int, Int] &#123; override def map(value: Int): Int = value + 1&#125; 函数接口定义了需要由用户实现的转换方法，例如上面例子中的map()方法。 大部分函数接口被设计为Single Abstract Method（单独抽象方法）接口，并且接口可以使用Java 8匿名函数来实现。Scala DataStream API也内置了对匿名函数的支持。当讲解DataStream API的转换算子时，我们展示了针对所有函数类的接口，但为了简洁，大部分接口的实现使用匿名函数而不是函数类的方式。 DataStream API针对大多数数据转换操作提供了转换算子。如果你很熟悉批处理API、函数式编程语言或者SQL，那么你将会发现这些API很容易学习。我们会将DataStream API的转换算子分成四类： 基本转换算子：将会作用在数据流中的每一条单独的数据上。 KeyedStream转换算子：在数据有key的情况下，对数据应用转换算子。 多流转换算子：合并多条流为一条流或者将一条流分割为多条流。 分布式转换算子：将重新组织流里面的事件。 基本转换算子基本转换算子会针对流中的每一个单独的事件做处理，也就是说每一个输入数据会产生一个输出数据。单值转换，数据的分割，数据的过滤，都是基本转换操作的典型例子。我们将解释这些算子的语义并提供示例代码。 MAP map算子通过调用DataStream.map()来指定。map算子的使用将会产生一条新的数据流。它会将每一个输入的事件传送到一个用户自定义的mapper，这个mapper只返回一个输出事件，这个输出事件和输入事件的类型可能不一样。图5-1展示了一个map算子，这个map将每一个正方形转化成了圆形。 MapFunction的类型与输入事件和输出事件的类型相关，可以通过实现MapFunction接口来定义。接口包含map()函数，这个函数将一个输入事件恰好转换为一个输出事件。 scala1234// T: the type of input elements// O: the type of output elementsMapFunction[T, O] &gt; map(T): O 下面的代码实现了将SensorReading中的id字段抽取出来的功能。 scala123456val readings: DataStream[SensorReading] = ...val sensorIds: DataStream[String] = readings.map(new MyMapFunction)class MyMapFunction extends MapFunction[SensorReading, String] &#123; override def map(r: SensorReading): String = r.id&#125; 当然我们更推荐匿名函数的写法。 scala12val readings: DataStream[SensorReading] = ...val sensorIds: DataStream[String] = readings.map(r =&gt; r.id) FILTER filter转换算子通过在每个输入事件上对一个布尔条件进行求值来过滤掉一些元素，然后将剩下的元素继续发送。一个true的求值结果将会把输入事件保留下来并发送到输出，而如果求值结果为false，则输入事件会被抛弃掉。我们通过调用DataStream.filter()来指定流的filter算子，filter操作将产生一条新的流，其类型和输入流中的事件类型是一样的。图5-2展示了只产生白色方框的filter操作。 布尔条件可以使用函数、FilterFunction接口或者匿名函数来实现。FilterFunction中的泛型是输入事件的类型。定义的filter()方法会作用在每一个输入元素上面，并返回一个布尔值。 scala123// T: the type of elementsFilterFunction[T] &gt; filter(T): Boolean 下面的例子展示了如何使用filter来从传感器数据中过滤掉温度值小于25华氏温度的读数。 scala12val readings: DataStream[SensorReading] = ...val filteredSensors = readings.filter(r =&gt; r.temperature &gt;= 25) FLATMAP flatMap算子和map算子很类似，不同之处在于针对每一个输入事件flatMap可以生成0个、1个或者多个输出元素。事实上，flatMap转换算子是filter和map的泛化。所以flatMap可以实现map和filter算子的功能。图5-3展示了flatMap如何根据输入事件的颜色来做不同的处理。如果输入事件是白色方框，则直接输出。输入元素是黑框，则复制输入。灰色方框会被过滤掉。 flatMap算子将会应用在每一个输入事件上面。对应的FlatMapFunction定义了flatMap()方法，这个方法返回0个、1个或者多个事件到一个Collector集合中，作为输出结果。 scala1234// T: the type of input elements// O: the type of output elementsFlatMapFunction[T, O] &gt; flatMap(T, Collector[O]): Unit 下面的例子展示了在数据分析教程中经常用到的例子，我们用flatMap来实现。这个函数应用在一个语句流上面，将每个句子用空格切分，然后把切分出来的单词作为单独的事件发送出去。 scala123val sentences: DataStream[String] = ...val words: DataStream[String] = sentences .flatMap(id =&gt; id.split(\" \")) 键控流转换算子很多流处理程序的一个基本要求就是要能对数据进行分组，分组后的数据共享某一个相同的属性。DataStream API提供了一个叫做KeyedStream的抽象，此抽象会从逻辑上对DataStream进行分区，分区后的数据拥有同样的Key值，分区后的流互不相关。 针对KeyedStream的状态转换操作可以读取数据或者写入数据到当前事件Key所对应的状态中。这表明拥有同样Key的所有事件都可以访问同样的状态，也就是说所以这些事件可以一起处理。 要小心使用状态转换操作和基于Key的聚合操作。如果Key的值越来越多，例如：Key是订单ID，我们必须及时清空Key所对应的状态，以免引起内存方面的问题。稍后我们会详细讲解。 KeyedStream可以使用map，flatMap和filter算子来处理。接下来我们会使用keyBy算子来将DataStream转换成KeyedStream，并讲解基于key的转换操作：滚动聚合和reduce算子。 KEYBY keyBy通过指定key来将DataStream转换成KeyedStream。基于不同的key，流中的事件将被分配到不同的分区中去。所有具有相同key的事件将会在接下来的操作符的同一个子任务槽中进行处理。拥有不同key的事件可以在同一个任务中处理。但是算子只能访问当前事件的key所对应的状态。 如图5-4所示，把输入事件的颜色作为key，黑色的事件输出到了一个分区，其他颜色输出到了另一个分区。 keyBy()方法接收一个参数，这个参数指定了key或者keys，有很多不同的方法来指定key。我们将在后面讲解。下面的代码声明了id这个字段为SensorReading流的key。 scala123val readings: DataStream[SensorReading] = ...val keyed: KeyedStream[SensorReading, String] = readings .keyBy(r =&gt; r.id) 匿名函数r =&gt; r.id抽取了传感器读数SensorReading的id值。 滚动聚合 滚动聚合算子由KeyedStream调用，并生成一个聚合以后的DataStream，例如：sum，minimum，maximum。一个滚动聚合算子会为每一个观察到的key保存一个聚合的值。针对每一个输入事件，算子将会更新保存的聚合结果，并发送一个带有更新后的值的事件到下游算子。滚动聚合不需要用户自定义函数，但需要接受一个参数，这个参数指定了在哪一个字段上面做聚合操作。DataStream API提供了以下滚动聚合方法。 滚动聚合算子只能用在滚动窗口，不能用在滑动窗口。 sum()：在输入流上对指定的字段做滚动相加操作。 min()：在输入流上对指定的字段求最小值。 max()：在输入流上对指定的字段求最大值。 minBy()：在输入流上针对指定字段求最小值，并返回包含当前观察到的最小值的事件。 maxBy()：在输入流上针对指定字段求最大值，并返回包含当前观察到的最大值的事件。 滚动聚合算子无法组合起来使用，每次计算只能使用一个单独的滚动聚合算子。 下面的例子根据第一个字段来对类型为Tuple3[Int, Int, Int]的流做分流操作，然后针对第二个字段做滚动求和操作。 scala123456val inputStream: DataStream[(Int, Int, Int)] = env.fromElements( (1, 2, 2), (2, 3, 1), (2, 2, 4), (1, 5, 3))val resultStream: DataStream[(Int, Int, Int)] = inputStream .keyBy(0) // key on first field of the tuple .sum(1) // sum the second field of the tuple in place 在这个例子里面，输入流根据第一个字段来分流，然后在第二个字段上做计算。对于key 1，输出结果是(1,2,2),(1,7,2)。对于key 2，输出结果是(2,3,1),(2,5,1)。第一个字段是key，第二个字段是求和的数值，第三个字段未定义。 滚动聚合操作会对每一个key都保存一个状态。因为状态从来不会被清空，所以我们在使用滚动聚合算子时只能使用在含有有限个key的流上面。 REDUCE reduce算子是滚动聚合的泛化实现。它将一个ReduceFunction应用到了一个KeyedStream上面去。reduce算子将会把每一个输入事件和当前已经reduce出来的值做聚合计算。reduce操作不会改变流的事件类型。输出流数据类型和输入流数据类型是一样的。 reduce函数可以通过实现接口ReduceFunction来创建一个类。ReduceFunction接口定义了reduce()方法，此方法接收两个输入事件，输入一个相同类型的事件。 scala123// T: the element typeReduceFunction[T] &gt; reduce(T, T): T 下面的例子，流根据语言这个key来分区，输出结果为针对每一种语言都实时更新的单词列表。 scala123456val inputStream: DataStream[(String, List[String])] = env.fromElements( (\"en\", List(\"tea\")), (\"fr\", List(\"vin\")), (\"en\", List(\"cake\")))val resultStream: DataStream[(String, List[String])] = inputStream .keyBy(0) .reduce((x, y) =&gt; (x._1, x._2 ::: y._2)) reduce匿名函数将连续两个tuple的第一个字段(key字段)继续发送出去，然后将两个tuple的第二个字段List[String]连接。 reduce作为滚动聚合的泛化实现，同样也要针对每一个key保存状态。因为状态从来不会清空，所以我们需要将reduce算子应用在一个有限key的流上。 多流转换算子许多应用需要摄入多个流并将流合并处理，还可能需要将一条流分割成多条流然后针对每一条流应用不同的业务逻辑。接下来，我们将讨论DataStream API中提供的能够处理多条输入流或者发送多条输出流的操作算子。 UNION DataStream.union()方法将两条或者多条DataStream合并成一条具有与输入流相同类型的输出DataStream。接下来的转换算子将会处理输入流中的所有元素。图5-5展示了union操作符如何将黑色和白色的事件流合并成一个单一输出流。 事件合流的方式为FIFO方式。操作符并不会产生一个特定顺序的事件流。union操作符也不会进行去重。每一个输入事件都被发送到了下一个操作符。 下面的例子展示了如何将三条类型为SensorReading的数据流合并成一条流。 scala12345val parisStream: DataStream[SensorReading] = ...val tokyoStream: DataStream[SensorReading] = ...val rioStream: DataStream[SensorReading] = ...val allCities: DataStream[SensorReading] = parisStream .union(tokyoStream, rioStream) CONNECT, COMAP和COFLATMAP 联合两条流的事件是非常常见的流处理需求。例如监控一片森林然后发出高危的火警警报。报警的Application接收两条流，一条是温度传感器传回来的数据，一条是烟雾传感器传回来的数据。当两条流都超过各自的阈值时，报警。 DataStream API提供了connect操作来支持以上的应用场景。DataStream.connect()方法接收一条DataStream，然后返回一个ConnectedStreams类型的对象，这个对象表示了两条连接的流。 scala1234567// first streamval first: DataStream[Int] = ...// second streamval second: DataStream[String] = ...// connect streamsval connected: ConnectedStreams[Int, String] = first.connect(second) ConnectedStreams提供了map()和flatMap()方法，分别需要接收类型为CoMapFunction和CoFlatMapFunction的参数。 以上两个函数里面的泛型是第一条流的事件类型和第二条流的事件类型，以及输出流的事件类型。还定义了两个方法，每一个方法针对一条流来调用。map1()和flatMap1()会调用在第一条流的元素上面，map2()和flatMap2()会调用在第二条流的元素上面。 scala12345678910// IN1: 第一条流的事件类型// IN2: 第二条流的事件类型// OUT: 输出流的事件类型CoMapFunction[IN1, IN2, OUT] &gt; map1(IN1): OUT &gt; map2(IN2): OUTCoFlatMapFunction[IN1, IN2, OUT] &gt; flatMap1(IN1, Collector[OUT]): Unit &gt; flatMap2(IN2, Collector[OUT]): Unit 函数无法选择读某一条流。我们是无法控制函数中的两个方法的调用顺序的。当一条流中的元素到来时，将会调用相对应的方法。 对两条流做连接查询通常需要这两条流基于某些条件被确定性的路由到操作符中相同的并行实例里面去。在默认情况下，connect()操作将不会对两条流的事件建立任何关系，所以两条流的事件将会随机的被发送到下游的算子实例里面去。这样的行为会产生不确定性的计算结果，显然不是我们想要的。为了针对ConnectedStreams进行确定性的转换操作，connect()方法可以和keyBy()或者broadcast()组合起来使用。我们首先看一下keyBy()的示例。 scala123456789101112val one: DataStream[(Int, Long)] = ...val two: DataStream[(Int, String)] = ...// keyBy two connected streamsval keyedConnect1: ConnectedStreams[(Int, Long), (Int, String)] = one .connect(two) .keyBy(0, 0) // key both input streams on first attribute// alternative: connect two keyed streamsval keyedConnect2: ConnectedStreams[(Int, Long), (Int, String)] = one .keyBy(0) .connect(two.keyBy(0)) 无论使用keyBy()算子操作ConnectedStreams还是使用connect()算子连接两条KeyedStreams，connect()算子会将两条流的含有相同Key的所有事件都发送到相同的算子实例。两条流的key必须是一样的类型和值，就像SQL中的JOIN。在connected和keyed stream上面执行的算子有访问keyed state的权限。 下面的例子展示了如何连接一条DataStream和广播过的流。 scala1234567val first: DataStream[(Int, Long)] = ...val second: DataStream[(Int, String)] = ...// connect streams with broadcastval keyedConnect: ConnectedStreams[(Int, Long), (Int, String)] = first // broadcast second input stream .connect(second.broadcast()) 一条被广播过的流中的所有元素将会被复制然后发送到下游算子的所有并行实例中去。未被广播过的流仅仅向前发送。所以两条流的元素显然会被连接处理。 SPLIT和SELECT Split是Union的反函数。Split将输入的流分成两条或者多条流。每一个输入的元素都可以被路由到0、1或者多条流中去。所以，split可以用来过滤或者复制元素。图5-6展示了split操作符将所有的白色事件都路由到同一条流中去了，剩下的元素去往另一条流。 DataStream.split()方法接受OutputSelector类型，此类型定义了输入流中的元素被分配到哪个名字的流中去。OutputSelector定义了select()方法，此方法将被每一个元素调用，并返回java.lang.Iterable[String]类型的数据。返回的String类型的值将指定元素将被路由到哪一条流。 Code123&#x2F;&#x2F; IN: the type of the split elementsOutputSelector[IN] &gt; select(IN): Iterable[String] DataStream.split()方法返回SplitStream类型，此类型提供select()方法，可以根据分流后不同流的名字，将某个名字对应的流提取出来。 例5-2将一条整数流分成了不同的流，大的整数一条流，小的整数一条流。 scala12345678val inputStream: DataStream[(Int, String)] = ...val splitted: SplitStream[(Int, String)] = inputStream .split(t =&gt; if (t._1 &gt; 1000) Seq(\"large\") else Seq(\"small\"))val large: DataStream[(Int, String)] = splitted.select(\"large\")val small: DataStream[(Int, String)] = splitted.select(\"small\")val all: DataStream[(Int, String)] = splitted.select(\"small\", \"large\") 不推荐使用split方法，推荐使用Flink的侧输出（side-output）特性。 分布式转换算子分区操作对应于我们之前讲过的“数据交换策略”这一节。这些操作定义了事件如何分配到不同的任务中去。当我们使用DataStream API来编写程序时，系统将自动的选择数据分区策略，然后根据操作符的语义和设置的并行度将数据路由到正确的地方去。有些时候，我们需要在应用程序的层面控制分区策略，或者自定义分区策略。例如，如果我们知道会发生数据倾斜，那么我们想要针对数据流做负载均衡，将数据流平均发送到接下来的操作符中去。又或者，应用程序的业务逻辑可能需要一个算子所有的并行任务都需要接收同样的数据。再或者，我们需要自定义分区策略的时候。在这一小节，我们将展示DataStream的一些方法，可以使我们来控制或者自定义数据分区策略。 keyBy()方法不同于分布式转换算子。所有的分布式转换算子将产生DataStream数据类型。而keyBy()产生的类型是KeyedStream，它拥有自己的keyed state。 Random 随机数据交换由DataStream.shuffle()方法实现。shuffle方法将数据随机的分配到下游算子的并行任务中去。 Round-Robin rebalance()方法使用Round-Robin负载均衡算法将输入流平均分配到随后的并行运行的任务中去。图5-7为round-robin分布式转换算子的示意图。 Rescale rescale()方法使用的也是round-robin算法，但只会将数据发送到接下来的并行运行的任务中的一部分任务中。本质上，当发送者任务数量和接收者任务数量不一样时，rescale分区策略提供了一种轻量级的负载均衡策略。如果接收者任务的数量是发送者任务的数量的倍数时，rescale操作将会效率更高。 rebalance()和rescale()的根本区别在于任务之间连接的机制不同。 rebalance()将会针对所有发送者任务和所有接收者任务之间建立通信通道，而rescale()仅仅针对每一个任务和下游算子的一部分子并行任务之间建立通信通道。rescale的示意图为图5-7。 Broadcast broadcast()方法将输入流的所有数据复制并发送到下游算子的所有并行任务中去。 Global global()方法将所有的输入流数据都发送到下游算子的第一个并行任务中去。这个操作需要很谨慎，因为将所有数据发送到同一个task，将会对应用程序造成很大的压力。 Custom 当Flink提供的分区策略都不适用时，我们可以使用partitionCustom()方法来自定义分区策略。这个方法接收一个Partitioner对象，这个对象需要实现分区逻辑以及定义针对流的哪一个字段或者key来进行分区。下面的例子将一条整数流做partition，使得所有的负整数都发送到第一个任务中，剩下的数随机分配。 scala12345678910val numbers: DataStream[(Int)] = ...numbers.partitionCustom(myPartitioner, 0)object myPartitioner extends Partitioner[Int] &#123; val r = scala.util.Random override def partition(key: Int, numPartitions: Int): Int = &#123; if (key &lt; 0) 0 else r.nextInt(numPartitions) &#125;&#125; 设置并行度Flink应用程序在一个像集群这样的分布式环境中并行执行。当一个数据流程序提交到JobManager执行时，系统将会创建一个数据流图，然后准备执行需要的操作符。每一个操作符将会并行化到一个或者多个任务中去。每个算子的并行任务都会处理这个算子的输入流中的一份子集。一个算子并行任务的个数叫做算子的并行度。它决定了算子执行的并行化程度，以及这个算子能处理多少数据量。 算子的并行度可以在执行环境这个层级来控制，也可以针对每个不同的算子设置不同的并行度。默认情况下，应用程序中所有算子的并行度都将设置为执行环境的并行度。执行环境的并行度（也就是所有算子的默认并行度）将在程序开始运行时自动初始化。如果应用程序在本地执行环境中运行，并行度将被设置为CPU的核数。当我们把应用程序提交到一个处于运行中的Flink集群时，执行环境的并行度将被设置为集群默认的并行度，除非我们在客户端提交应用程序时显式的设置好并行度。 通常情况下，将算子的并行度定义为和执行环境并行度相关的数值会是个好主意。这允许我们通过在客户端调整应用程序的并行度就可以将程序水平扩展了。我们可以使用以下代码来访问执行环境的默认并行度。 我们还可以重写执行环境的默认并行度，但这样的话我们将再也不能通过客户端来控制应用程序的并行度了。 算子默认的并行度也可以通过重写来明确指定。在下面的例子里面，数据源的操作符将会按照环境默认的并行度来并行执行，map操作符的并行度将会是默认并行度的2倍，sink操作符的并行度为2。 scala12345val env = StreamExecutionEnvironment.getExecutionEnvironmentval defaultP = env.getParallelismval result = env.addSource(new CustomSource) .map(new MyMapper).setParallelism(defaultP * 2) .print().setParallelism(2) 当我们通过客户端将应用程序的并行度设置为16并提交执行时，source操作符的并行度为16，mapper并行度为32，sink并行度为2。如果我们在本地环境运行应用程序的话，例如在IDE中运行，机器是8核，那么source任务将会并行执行在8个任务上面，mapper运行在16个任务上面，sink运行在2个任务上面。 并行度是动态概念，任务槽数量是静态概念。并行度&lt;=任务槽数量。一个任务槽最多运行一个并行度。 类型Flink程序所处理的流中的事件一般是对象类型。操作符接收对象输出对象。所以Flink的内部机制需要能够处理事件的类型。在网络中传输数据，或者将数据写入到状态后端、检查点和保存点中，都需要我们对数据进行序列化和反序列化。为了高效的进行此类操作，Flink需要流中事件类型的详细信息。Flink使用了Type Information的概念来表达数据类型，这样就能针对不同的数据类型产生特定的序列化器，反序列化器和比较操作符。 有点像泛型。 Flink也能够通过分析输入数据和输出数据来自动获取数据的类型信息以及序列化器和反序列化器。尽管如此，在一些特定的情况下，例如匿名函数或者使用泛型的情况下，我们需要明确的提供数据的类型信息，来提高我们程序的性能。 在这一节中，我们将讨论Flink支持的类型，以及如何为数据类型创建相应的类型信息，还有就是在Flink无法推断函数返回类型的情况下，如何帮助Flink的类型系统去做类型推断。 支持的数据类型Flink支持Java和Scala提供的所有普通数据类型。最常用的数据类型可以做以下分类： Primitives（原始数据类型） Java和Scala的Tuples（元组） Scala的样例类 POJO类型 一些特殊的类型 接下来让我们一探究竟。 Primitives Java和Scala提供的所有原始数据类型都支持，例如Int(Java的Integer)，String，Double等等。下面举一个例子： scala12val numbers: DataStream[Long] = env.fromElements(1L, 2L, 3L, 4L)numbers.map(n =&gt; n + 1) Tuples 元组是一种组合数据类型，由固定数量的元素组成。 DataStream的Scala API直接使用Scala内置的Tuple。举个例子： scala1234567val persons: DataStream[(String, Integer)] =env.fromElements( (\"Adam\", 17), (\"Sarah\", 23))persons.filter(p =&gt; p._2 &gt; 18) Flink为Java的Tuple同样提供了高效的实现。Flink实现的Java Tuple最多可以有25个元素，根据元素数量的不同，Tuple都被实现成了不同的类：Tuple1，Tuple2，一直到Tuple25。Tuple类是强类型。 我们可以将上面的例子用Java的DataStream API重写： scala1234567DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; persons = env .fromElements( Tuple2.of(\"Adam\", 17), Tuple2.of(\"Sarah\", 23) );persons.filter(p -&gt; p.f1 &gt; 18); Tuple的元素可以通过它们的public属性访问–f0，f1，f2等等。或者使用getField(int pos)方法来访问，元素下标从0开始： scala1234import org.apache.flink.api.java.tuple.Tuple2Tuple2&lt;String, Integer&gt; personTuple = Tuple2.of(\"Alex\", 42);Integer age = personTuple.getField(1); // age = 42 不同于Scala的Tuple，Java的Tuple是可变数据结构，所以Tuple中的元素可以重新进行赋值。重复利用Java的Tuple可以减轻垃圾收集的压力。举个例子： scala12personTuple.f1 = 42; // set the 2nd field to 42personTuple.setField(43, 1); // set the 2nd field to 43 Scala case classes scala12345678case class Person(name: String, age: Int)val persons: DataStream[Person] = env.fromElements( Person(\"Adam\", 17), Person(\"Sarah\", 23))persons.filter(p =&gt; p.age &gt; 18) POJO POJO类的定义： 公有类 无参数的公有构造器 所有的字段都是公有的，可以通过getters和setters访问。 所有字段的数据类型都必须是Flink支持的数据类型。 举个例子： scala12345678910111213141516public class Person &#123; public String name; public int age; public Person() &#123;&#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;DataStream&lt;Person&gt; persons = env.fromElements( new Person(\"Alex\", 42), new Person(\"Wendy\", 23)); 其他数据类型 Array, ArrayList, HashMap, Enum Hadoop Writable types Either, Option, Try 为数据类型创建类型信息Flink类型系统的核心类是TypeInformation。它为系统在产生序列化器和比较操作符时，提供了必要的类型信息。例如，如果我们想使用某个key来做联结查询或者分组操作，TypeInformation可以让Flink做更严格的类型检查。 Flink针对Java和Scala分别提供了类来产生类型信息。在Java中，类是 scala1org.apache.flink.api.common.typeinfo.Types 举个例子： scala1234567TypeInformation&lt;Integer&gt; intType = Types.INT;TypeInformation&lt;Tuple2&lt;Long, String&gt;&gt; tupleType = Types .TUPLE(Types.LONG, Types.STRING);TypeInformation&lt;Person&gt; personType = Types .POJO(Person.class); 在Scala中，类是 org.apache.flink.api.scala.typeutils.Types ，举个例子： scala123456// TypeInformation for primitive typesval stringType: TypeInformation[String] = Types.STRING// TypeInformation for Scala Tuplesval tupleType: TypeInformation[(Int, Long)] = Types.TUPLE[(Int, Long)]// TypeInformation for case classesval caseClassType: TypeInformation[Person] = Types.CASE_CLASS[Person] 别忘了导入import org.apache.flink.streaming.api.scala._ 定义Key以及引用字段在Flink中，我们必须明确指定输入流中的元素中的哪一个字段是key。 使用字段位置进行keyByscala12val input: DataStream[(Int, String, Long)] = ...val keyed = input.keyBy(1) 注意，要么明确写清楚类型注释，要么让Scala去做类型推断，不要用IDEA的类型推断功能。 如果我们想要用元组的第2个字段和第3个字段做keyBy，可以看下面的例子。 scala1val keyed2 = input.keyBy(1, 2) 使用字段表达式来进行keyBy对于样例类： scala12345678case class SensorReading( id: String, timestamp: Long, temperature: Double)val sensorStream: DataStream[SensorReading] = ...val keyedSensors = sensorStream.keyBy(\"id\") 对于元组： scala123456val input: DataStream[(Int, String, Long)] = ...val keyed1 = input.keyBy(\"2\") // key by 3rd fieldval keyed2 = input.keyBy(\"_1\") // key by 1st fieldDataStream&lt;Tuple3&lt;Integer, String, Long&gt;&gt; javaInput = ...javaInput.keyBy(\"f2\") // key Java tuple by 3rd field 对于存在嵌套的样例类： scala12345678910111213141516case class Address ( address: String, zip: String, country: String)case class Person ( name: String, birthday: (Int, Int, Int), // year, month, day address: Address)val persons: DataStream[Person] = ...persons.keyBy(\"address.zip\") // key by nested POJO fieldpersons.keyBy(\"birthday._1\") // key by field of nested tuplepersons.keyBy(\"birthday._\") // key by all fields of nested tuple Key选择器方法类型 Code12KeySelector[IN, KEY] &gt; getKey(IN): KEY 两个例子 scala1234val sensorData: DataStream[SensorReading] = ...val byId: KeyedStream[SensorReading, String] = sensorData.keyBy(r =&gt; r.id)val input: DataStream[(Int, Int)] = ...val keyedStream = input.keyBy(value =&gt; math.max(value._1, value._2)) 实现UDF函数，更细粒度的控制流函数类(Function Classes)Flink暴露了所有udf函数的接口(实现方式为接口或者抽象类)。例如MapFunction, FilterFunction, ProcessFunction等等。 例子实现了FilterFunction接口 scala1234567class FilterFilter extends FilterFunction[String] &#123; override def filter(value: String): Boolean = &#123; value.contains(\"flink\") &#125;&#125;val flinkTweets = tweets.filter(new FlinkFilter) 还可以将函数实现成匿名类 scala1234567val flinkTweets = tweets.filter( new RichFilterFunction[String] &#123; override def filter(value: String): Boolean = &#123; value.contains(\"flink\") &#125; &#125;) 我们filter的字符串“flink”还可以当作参数传进去。 scala12345678val tweets: DataStream[String] = ...val flinkTweets = tweets.filter(new KeywordFilter(\"flink\"))class KeywordFilter(keyWord: String) extends FilterFunction[String] &#123; override def filter(value: String): Boolean = &#123; value.contains(keyWord) &#125;&#125; 匿名函数(Lambda Functions)匿名函数可以实现一些简单的逻辑，但无法实现一些高级功能，例如访问状态等等。 scala12val tweets: DataStream[String] = ...val flinkTweets = tweets.filter(_.contains(\"flink\")) 富函数(Rich Functions)我们经常会有这样的需求：在函数处理数据之前，需要做一些初始化的工作；或者需要在处理数据时可以获得函数执行上下文的一些信息；以及在处理完数据时做一些清理工作。而DataStream API就提供了这样的机制。 DataStream API提供的所有转换操作函数，都拥有它们的“富”版本，并且我们在使用常规函数或者匿名函数的地方来使用富函数。例如下面就是富函数的一些例子，可以看出，只需要在常规函数的前面加上Rich前缀就是富函数了。 RichMapFunction RichFlatMapFunction RichFilterFunction … 当我们使用富函数时，我们可以实现两个额外的方法： open()方法是rich function的初始化方法，当一个算子例如map或者filter被调用之前open()会被调用。open()函数通常用来做一些只需要做一次即可的初始化工作。 close()方法是生命周期中的最后一个调用的方法，通常用来做一些清理工作。 另外，getRuntimeContext()方法提供了函数的RuntimeContext的一些信息，例如函数执行的并行度，当前子任务的索引，当前子任务的名字。同时还它还包含了访问分区状态的方法。下面看一个例子： scala12345678910111213141516171819class MyFlatMap extends RichFlatMapFunction[Int, (Int, Int)] &#123; var subTaskIndex = 0 override def open(configuration: Configuration): Unit = &#123; subTaskIndex = getRuntimeContext.getIndexOfThisSubtask // 做一些初始化工作 // 例如建立一个和HDFS的连接 &#125; override def flatMap(in: Int, out: Collector[(Int, Int)]): Unit = &#123; if (in % 2 == subTaskIndex) &#123; out.collect((subTaskIndex, in)) &#125; &#125; override def close(): Unit = &#123; // 清理工作，断开和HDFS的连接。 &#125;&#125; SinkFlink没有类似于spark中foreach方法，让用户进行迭代的操作。所有对外的输出操作都要利用Sink完成。最后通过类似如下方式完成整个任务最终输出操作。 scala1stream.addSink(new MySink(xxxx)) 官方提供了一部分的框架的sink。除此以外，需要用户自定义实现sink。 KafkaKafka版本为0.11 xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka-0.11_2.11&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt;&lt;/dependency&gt; Kafka版本为2.0以上 xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-kafka_2.11&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt;&lt;/dependency&gt; 主函数中添加sink： scala1234567891011val union = high .union(low) .map(_.temperature.toString)union.addSink( new FlinkKafkaProducer011[String]( \"localhost:9092\", \"test\", new SimpleStringSchema() )) Redisxml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.bahir&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-redis_2.11&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 定义一个redis的mapper类，用于定义保存到redis时调用的命令： scala12345678910111213class MyRedisMapper extends RedisMapper[SensorReading] &#123; override def getCommandDescription: RedisCommandDescription = &#123; new RedisCommandDescription(RedisCommand.HSET, \"sensor_temperature\") &#125; override def getValueFromData(t: SensorReading): String = &#123; t.temperature.toString &#125; override def getKeyFromData(t: SensorReading): String = t.id&#125; ElasticSearch在主函数中调用： xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.flink&lt;/groupId&gt; &lt;artifactId&gt;flink-connector-elasticsearch6_2.11&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt;&lt;/dependency&gt; 在主函数中调用： scala123456789101112131415161718192021val httpHosts = new util.ArrayList[HttpHost]()httpHosts.add(new HttpHost(\"localhost\", 9200))val esSinkBuilder = new ElasticsearchSink.Builder[SensorReading]( httpHosts, new ElasticsearchSinkFunction[SensorReading] &#123; override def process(t: SensorReading, runtimeContext: RuntimeContext, requestIndexer: RequestIndexer): Unit = &#123; println(\"saving data: \" + t) val json = new util.HashMap[String, String]() json.put(\"data\", t.toString) val indexRequest = Requests .indexRequest() .index(\"sensor\") .`type`(\"readingData\") .source(json) requestIndexer.add(indexRequest) println(\"saved successfully\") &#125; &#125;)dataStream.addSink(esSinkBuilder.build()) JDBC自定义sinkxml12345&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.44&lt;/version&gt;&lt;/dependency&gt; 添加MyJdbcSink scala1234567891011121314151617181920212223242526272829303132333435363738class MyJdbcSink() extends RichSinkFunction[SensorReading]&#123; var conn: Connection = _ var insertStmt: PreparedStatement = _ var updateStmt: PreparedStatement = _ // open 主要是创建连接 override def open(parameters: Configuration): Unit = &#123; super.open(parameters) conn = DriverManager.getConnection( \"jdbc:mysql://localhost:3306/test\", \"root\", \"123456\") insertStmt = conn.prepareStatement( \"INSERT INTO temperatures (sensor, temp) VALUES (?, ?)\" ) updateStmt = conn.prepareStatement( \"UPDATE temperatures SET temp = ? WHERE sensor = ?\" ) &#125; // 调用连接，执行sql override def invoke(value: SensorReading, context: SinkFunction.Context[_]): Unit = &#123; updateStmt.setDouble(1, value.temperature) updateStmt.setString(2, value.id) updateStmt.execute() if (updateStmt.getUpdateCount == 0) &#123; insertStmt.setString(1, value.id) insertStmt.setDouble(2, value.temperature) insertStmt.execute() &#125; &#125; override def close(): Unit = &#123; insertStmt.close() updateStmt.close() conn.close() &#125;&#125; 在main方法中增加，把明细保存到mysql中 scala1dataStream.addSink(new MyJdbcSink())","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列04第一个Flink程序","slug":"flink系列04第一个Flink程序","date":"2020-06-27T15:27:31.000Z","updated":"2020-06-27T15:28:02.624Z","comments":true,"path":"2020/06/27/flink系列04第一个Flink程序/","link":"","permalink":"https://masteryang4.github.io/2020/06/27/flink%E7%B3%BB%E5%88%9704%E7%AC%AC%E4%B8%80%E4%B8%AAFlink%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"第四章，编写第一个Flink程序在IDEA中编写Flink程序本项目使用的Flink版本为最新版本，也就是1.10.0。现在提供maven项目的配置文件。 使用Intellij IDEA创建一个Maven新项目 勾选Create from archetype，然后点击Add Archetype按钮 GroupId中输入org.apache.flink，ArtifactId中输入flink-quickstart-scala，Version中输入1.10.0，然后点击OK 点击向右箭头，出现下拉列表，选中flink-quickstart-scala:1.10.0，点击Next Name中输入FlinkTutorial，GroupId中输入com.atguigu，ArtifactId中输入FlinkTutorial，点击Next 最好使用IDEA默认的Maven工具：Bundled（Maven 3），点击Finish，等待一会儿，项目就创建好了 编写WordCount.scala程序 scala12345678910111213141516171819202122232425262728293031323334353637package com.atguiguimport org.apache.flink.streaming.api.scala._import org.apache.flink.streaming.api.windowing.time.Timeobject StreamingJob &#123; /** Main program method */ def main(args: Array[String]) : Unit = &#123; // get the execution environment val env: StreamExecutionEnvironment = StreamExecutionEnvironment .getExecutionEnvironment // get input data by connecting to the socket val text: DataStream[String] = env .socketTextStream(\"localhost\", 9999, '\\n') // parse the data, group it, window it, and aggregate the counts val windowCounts = text .flatMap &#123; w =&gt; w.split(\"\\\\s\") &#125; .map &#123; w =&gt; WordWithCount(w, 1) &#125; .keyBy(\"word\") .timeWindow(Time.seconds(5)) .sum(\"count\") // print the results with a single thread, rather than in parallel windowCounts .print() .setParallelism(1) env.execute(\"Socket Window WordCount\") &#125; /** Data type for words with count */ case class WordWithCount(word: String, count: Long)&#125; 打开一个终端（Terminal），运行以下命令 Code1$ nc -lk 9999 接下来使用IDEA运行就可以了。 下载Flink运行时环境，提交Jar包的运行方式下载链接：http://mirror.bit.edu.cn/apache/flink/flink-1.10.1/flink-1.10.1-bin-scala_2.11.tgz 然后解压 Code1$ tar xvfz flink-1.10.0-bin-scala_2.11.tgz 启动Flink集群 Code12$ cd flink-1.10.0$ .&#x2F;bin&#x2F;start-cluster.sh 可以打开Flink WebUI查看集群状态：http://localhost:8081 在IDEA中使用maven package打包。 提交打包好的JAR包 Code12$ cd flink-1.10.0$ .&#x2F;bin&#x2F;flink run 打包好的JAR包的绝对路径 停止Flink集群 Code1$ .&#x2F;bin&#x2F;stop-cluster.sh 查看标准输出日志的位置，在log文件夹中。 Code1$ cd flink-1.10.0&#x2F;log","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列03Flink运行架构","slug":"flink系列03Flink运行架构","date":"2020-06-27T15:26:18.000Z","updated":"2020-06-27T15:27:16.346Z","comments":true,"path":"2020/06/27/flink系列03Flink运行架构/","link":"","permalink":"https://masteryang4.github.io/2020/06/27/flink%E7%B3%BB%E5%88%9703Flink%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84/","excerpt":"","text":"第三章，Flink运行架构系统架构Flink是一个用于有状态的并行数据流处理的分布式系统。它由多个进程构成，这些进程一般会分布运行在不同的机器上。对于分布式系统来说，面对的常见问题有：集群中资源的分配和管理、进程协调调度、持久化和高可用的数据存储，以及故障恢复。 对于这些分布式系统的经典问题，业内已有比较成熟的解决方案和服务。所以Flink并不会自己去处理所有的问题，而是利用了现有的集群架构和服务，这样它就可以把精力集中在核心工作——分布式数据流处理上了。Flink与一些集群资源管理工具有很好的集成，比如Apache Mesos、YARN和Kubernetes；同时，也可以配置为独立（stand-alone）集群运行。Flink自己并不提供持久化的分布式存储，而是直接利用了已有的分布式文件系统（比如HDFS）或者对象存储（比如S3）。对于高可用的配置，Flink需要依靠Apache ZooKeeper来完成。 在本节中，我们将介绍Flink的不同组件，以及在运行程序时它们如何相互作用。我们会讨论部署Flink应用程序的两种模式，并且了解每种模式下分发和执行任务的方式。最后，我们还会解释一下Flink的高可用性模式是如何工作的。 Flink运行时组件Flink运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作：作业管理器（JobManager）、资源管理器（ResourceManager）、任务管理器（TaskManager），以及分发器（Dispatcher）。因为Flink是用Java和Scala实现的，所以所有组件都会运行在Java虚拟机（JVMs）上。每个组件的职责如下： 作业管理器（JobManager）是控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager所控制执行。JobManager会先接收到要执行的应用程序。这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的JAR包。JobManager会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。JobManager会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。 ResourceManager主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger插槽是Flink中定义的处理资源单元。Flink为不同的环境和资源管理工具提供了不同资源管理器（ResourceManager），比如YARN、Mesos、K8s，以及standalone部署。当JobManager申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给JobManager。如果ResourceManager没有足够的插槽来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器。另外，ResourceManager还负责终止空闲的TaskManager，释放计算资源。 任务管理器（TaskManager）是Flink中的工作进程。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量。启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用。JobManager就可以向插槽分配任务（tasks）来执行了。在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据。任务的执行和插槽的概念会在“任务执行”一节做具体讨论。 分发器（Dispatcher）可以跨作业运行，它为应用提交提供了REST接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager。由于是REST接口，所以Dispatcher可以作为集群的一个HTTP接入点，这样就能够不受防火墙阻挡。Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息。Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式。 上图是从一个较为高层级的视角，来看应用中各组件的交互协作。如果部署的集群环境不同（例如YARN，Mesos，Kubernetes，standalone等），其中一些步骤可以被省略，或是有些组件会运行在同一个JVM进程中。 应用部署Flink应用程序可以用以下两种不同的方式部署： 框架（Framework）方式 在这个模式下，Flink应用被打包成一个Jar文件，并由客户端提交给一个运行服务（running service）。这个服务可以是一个Flink的Dispatcher，也可以是一个Flink的JobManager，或是Yarn的ResourceManager。如果application被提交给一个JobManager，则它会立即开始执行这个application。如果application被提交给了一个Dispatcher，或是Yarn ResourceManager，则它会启动一个JobManager，然后将application交给它，再由JobManager开始执行此应用。 库（Library）方式 在这个模式下，Flink Application 会被打包在一个容器（container） 镜像里，例如一个Docker 镜像。此镜像包含了运行JobManager和ResourceManager的代码。当一个容器从镜像启动后，它会自动启动ResourceManager和JobManager，并提交打包好的应用。另一种方法是：将应用打包到镜像后，只用于部署TaskManager容器。从镜像启动的容器会自动启动一个TaskManager，然后连接ResourceManager并注册它的slots。这些镜像的启动以及失败重启，通常都会由一个外部的资源管理器管理（比如Kubernetes）。 框架模式遵循了传统的任务提交方式，从客户端提交到Flink运行服务。而在库模式下，没有运行的Flink服务。它是将Flink作为一个库，与应用程序一同打包到了一个容器镜像。这种部署方式在微服务架构中较为常见。我们会在“运行管理流式应用程序”一节对这个话题做详细讨论。 任务执行一个TaskManager可以同时执行多个任务（tasks）。这些任务可以是同一个算子（operator）的子任务（数据并行），也可以是来自不同算子的（任务并行），甚至可以是另一个不同应用程序的（作业并行）。TaskManager提供了一定数量的处理插槽（processing slots），用于控制可以并行执行的任务数。一个slot可以执行应用的一个分片，也就是应用中每一个算子的一个并行任务。图3-2展示了TaskManagers，slots，tasks以及operators之间的关系： 最左边是一个“作业图”（JobGraph），包含了5个算子——它是应用程序的非并行表示。其中算子A和C是数据源（source），E是输出端（sink）。C和E并行度为2，而其他的算子并行度为4。因为最高的并行度是4，所以应用需要至少四个slot来执行任务。现在有两个TaskManager，每个又各有两个slot，所以我们的需求是满足的。JobManager将JobGraph转化为“执行图”（ExecutionGraph），并将任务分配到四个可用的slot上。对于有4个并行任务的算子，它的task会分配到每个slot上。而对于并行度为2的operator C和E，它们的任务被分配到slot 1.1、2.1 以及 slot 1.2、2.2。将tasks调度到slots上，可以让多个tasks跑在同一个TaskManager内，也就可以是的tasks之间的数据交换更高效。然而将太多任务调度到同一个TaskManager上会导致TaskManager过载，继而影响效率。之后我们会在“控制任务调度”一节继续讨论如何控制任务的调度。 TaskManager在同一个JVM中以多线程的方式执行任务。线程较进程会更轻量级，但是线程之间并没有对任务进行严格隔离。所以，单个任务的异常行为有可能会导致整个TaskManager进程挂掉，当然也同时包括运行在此进程上的所有任务。通过为每个TaskManager配置单独的slot，就可以将应用在TaskManager上相互隔离开来。TaskManager内部有多线程并行的机制，而且在一台主机上可以部署多个TaskManager，所以Flink在资源配置上非常灵活，在部署应用时可以充分权衡性能和资源的隔离。我们将会在第九章对Flink集群的配置和搭建继续做详细讨论。 高可用配置流式应用程序一般被设计为7 x 24小时运行。所以很重要的一点是：即使出现了进程挂掉的情况，应用仍需要继续保持运行。为了从故障恢复，系统首先需要重启进程、然后重启应用并恢复它的状态。接下来，我们就来了解Flink如何重启失败的进程。 TaskManager故障 如前所述，Flink需要足够数目的slot，来执行一个应用的所有任务。假设一个Flink环境有4个TaskManager，每个提供2个插槽，那么流应用程序执行的最高并行度为8。如果其中一个TaskManager挂掉了，那么可用的slots会降到6。在这种情况下，JobManager会请求ResourceManager提供更多的slots。如果此请求无法满足——例如应用跑在一个standalone集群——那么JobManager在有足够的slots之前，无法重启应用。应用的重启策略决定了JobManager的重启频率，以及两次重启尝试之间的时间间隔。 JobManager故障 比TaskManager故障更严重的问题是JobManager故障。JobManager控制整个流应用程序的执行，并维护执行中的元数据——例如指向已完成检查点的指针。若是对应的JobManager挂掉，则流程序无法继续运行。所以这就导致在Flink应用中，JobManager是单点故障。为了解决这个问题，Flink提供了高可用模式。在原先的JobManager挂掉后，可以将一个作业的状态和元数据迁移到另一个JobManager，并继续执行。 Flink的高可用模式基于Apache ZooKeeper，我们知道，ZooKeeper是用来管理需要协调和共识的分布式服务的系统。Flink主要利用ZooKeeper来进行领导者（leader）的选举，并把它作为一个高可用和持久化的数据存储。当在高可用模式下运行时，JobManager会将JobGraph以及所有需要的元数据（例如应用程序的jar文件），写入到一个远程的持久化存储系统中。而且，JobManager会将指向存储位置的指针，写入到ZooKeeper的数据存储中。在执行一个应用的过程中，JobManager会接收每个独立任务检查点的状态句柄（也就是存储位置）。当一个检查点完成时（所有任务已经成功地将它们的状态写入到远程存储）， JobManager把状态句柄写入远程存储，并将指向这个远程存储的指针写入ZooKeeper。这样，一个JobManager挂掉之后再恢复，所需要的所有数据信息已经都保存在了远程存储，而ZooKeeper里存有指向此存储位置的指针。图3-3描述了这个设计： 当一个JobManager失败，所有属于这个应用的任务都会自动取消。一个新的JobManager接管工作，会执行以下操作： 从ZooKeeper请求存储位置（storage location），从远端存储获取JobGraph，Jar文件，以及应用最近一次检查点（checkpoint）的状态句柄（state handles） 从ResourceManager请求slots，用来继续运行应用 重启应用，并将所有任务的状态，重设为最近一次已完成的检查点 如果我们是在容器环境里运行应用（如Kubernetes），故障的JobManager或TaskManager 容器通常会由容器服务自动重启。当运行在YARN或Mesos之上时，JobManager或TaskManager进程会由Flink的保留进程自动触发重启。而在standalone模式下，Flink并未提供重启故障进程的工具。所以，此模式下我们可以增加备用（standby）的 JobManager和TaskManager，用于接管故障的进程。我们将会在“高可用配置”一节中做进一步讨论。 Flink中的数据传输运行中的应用任务，会持续不断地交换数据。TaskManager负责将数据从“发送任务”（sending tasks）传递到“接收任务”（receiving tasks）。TaskManager的网络组件会在缓冲区中收集数据，然后再将其发送，也就是说，数据不是逐条发送的，而是在缓冲区中“攒”成了一批。这种技术是有效利用网络资源和实现高吞吐量的基础，机制类似于网络或磁盘I/O协议中使用的缓冲技术。 通过缓冲区来传递数据，意味着Flink的处理模型是基于微批的。 每个TaskManager都有一个网络缓冲池（默认大小为32KB），用于发送和接收数据。如果发送任务和接收任务运行在不同的TaskManager进程中，那么它们会通过操作系统的网络栈来进行通信。流应用程序需要以管道方式传递数据，所以每对TaskManager之间都需要维护一个永久TCP连接，用来交换数据。在无序连接模式下，每个发送任务都需要能向任何接收任务传递数据。所以我们发现，TaskManager需要为每一个接收任务设置一个专用的网络缓冲区，因为其中的每一个任务都需要接收数据。图3-4展示了这种架构。 如图3-4所示，四个发送任务中的每一个都需要至少四个网络缓冲区，用来向每个接收任务发送数据，而每个接收任务也需要至少四个缓冲区来接收数据。需要发送到另一个TaskManager的缓冲数据，会复用同一网络连接。为了实现平滑的管道数据传输，TaskManager必须能够提供足够的缓冲，来同时为所有传出和传入连接提供服务。对于无序或广播连接，每个发送任务都需要为每个接收任务提供一个缓冲；所以，所需缓冲区的数量是相关算子任务数量的平方。Flink网络缓冲区的默认配置足以满足中小型应用；对于更大的应用场景，就需要按照“主内存和网络缓冲区”一节中的叙述调整配置了。 当发送任务和接收任务在同一个TaskManager进程中运行时，发送任务会将传出的数据序列化，放入字节缓冲区，并在缓冲区填满后将其放入队列。接收任务从队列中提取缓冲数据并对其进行反序列化。因此，在同一个TaskManager上运行的任务，它们之间的数据传输不会导致网络通信。 Flink采用不同的技术来降低任务之间的通信成本。在下面的部分中，我们会简要讨论基于信任度（Credit）的流控制和任务链。 基于信任度（credit）的流控制通过网络连接来发送每条数据的效率很低，会导致很大的开销。为了充分利用网络连接的带宽，就需要进行缓冲了。在流处理的上下文中，缓冲的一个缺点是会增加延迟，因为数据需要在缓冲区中进行收集，而不是立即发送。 Flink实现了一个基于信任度的流量控制机制，其工作原理如下。接收任务授予发送任务一些“信任度”（credit），也就是为了接收其数据而保留的网络缓冲区数。当发送者收到一个信任度通知，它就会按照被授予的信任度，发送尽可能多的缓冲数据，并且同时发送目前积压数据的大小——也就是已填满并准备发送的网络缓冲的数量。接收者用保留的缓冲区处理发来的数据，并对发送者传来的积压量进行综合考量，为其所有连接的发送者确定下一个信用度授权的优先级。 基于信用度的流控制可以减少延迟，因为发送者可以在接收者有足够的资源接受数据时立即发送数据。此外，在数据倾斜的情况下，这样分配网络资源是一种很有效的机制，因为信用度是根据发送者积压数据量的规模授予的。因此，基于信用的流量控制是Flink实现高吞吐量和低延迟的重要组成部分。 任务链（Task Chaining）Flink采用了一种称为任务链的优化技术，可以在特定条件下减少本地通信的开销。为了满足任务链的要求，必须将两个或多个算子设为相同的并行度，并通过本地转发（local forward）的方式进行连接。图3-5所示的算子管道满足这些要求。它由三个算子组成，这些算子的任务并行度都被设为2，并且通过本地转发方式相连接。 图3-6展示了管道以任务链方式运行的过程。算子的函数被融合成了一个单一的任务，由一个线程执行。由函数生成的数据通过一个简单的方法调用移交给下一个函数；这样在函数之间直接传递数据，基本上没有序列化和通信成本。 任务链可以显著降低本地任务之间的通信成本，但也有一些场景，在没有链接的情况下运行管道操作是有意义的。例如，如果任务链中某个函数执行的开销巨大，那就可以将一条长的任务链管道断开，或者将一条链断开为两个任务，从而可以将这个开销大的函数调度到不同的槽（slots）中。图3-7显示了在没有任务链的情况下相同管道操作的执行情况。所有函数都由独立的单个任务来评估，每个任务都在专有的线程中运行。 任务链在Flink中默认会启用。在“控制任务链”一节中，我们展示了如何禁用应用程序的任务链，以及如何控制各个算子的链接行为。 事件时间（Event-Time）处理在“时间语义”一节，我们重点强调了时间语义在流处理应用中的重要性，并且解释了处理时间（processing time）和事件时间（event time）的不同。处理时间比较好理解，因为它是基于处理器本地时间的；但同时，它会带来比较混乱、不一致、并且不可重现的结果。相比之下，事件时间语义能够产生可重现且一致的结果，这也是许多流处理场景希望解决的一大难题。但是，与处理时间应用程序相比，事件时间应用程序会更复杂，需要额外的配置。另外，支持事件时间的流处理器，也比纯粹在处理时间中运行的系统内部更为复杂。 Flink为常见的事件时间处理操作提供了直观且易于使用的原语，同时暴露了表达性很强的API，用户可以使用自定义算子实现更高级的事件时间应用程序。很好地理解Flink的内部时间处理，对于实现这样的高级应用程序会有很大帮助，有时也是必需的。上一章介绍了Flink利用两个概念来支持事件时间语义：记录时间戳（timestamps）和水位线（watermarks）。接下来，我们将描述Flink如何在内部实现并处理时间戳和水位线，进而支持具有事件时间语义的流式应用程序。 时间戳（Timestamps）由Flink事件时间流应用程序处理的所有记录都必须伴有时间戳。时间戳将数据与特定时间点相关联，通常就是数据所表示的事件发生的时间点。而只要时间戳大致跟数据流保持一致，基本上随着数据流的前进而增大，应用程序就可以自由选择时间戳的含义。不过正如“时间语义”一节中所讨论的，在现实场景中，时间戳基本上都是乱序的，所以采用“事件时间”而非“处理事件”往往会显得更为重要。 当Flink以事件时间模式处理数据流时，它会根据数据记录的时间戳来处理基于时间的算子。例如，时间窗口算子根据相关时间戳将数据分配给不同的时间窗口。Flink将时间戳编码为16字节的长整型值，并将其作为元数据附加到数据记录中。它的内置运算符会将这个长整型值解释为一个具有毫秒精度的Unix时间戳，也就是1970-01-01-00:00:00.000以来的毫秒数。当然，如果用户进行了自定义，那么运算符可以有自己的解释，例如，可以将精度调整到微秒。 水位线(Watermarks)除了时间戳，基于事件时间的Flink应用程序还必须支持水位线（watermark）。在基于事件时间的应用中，水位线用于生成每个任务的当前事件时间。基于时间的算子使用这个“当前事件时间”来触发计算和处理操作。例如，一个时间窗口任务（time-window task）会在任务的事件时间超出窗口的关闭边界时，完成窗口计算，并输出计算结果。 在Flink中，水位线被实现为一条特殊的数据记录，它里面以长整型值保存了一个时间戳。水位线在带有时间戳的数据流中，跟随着其它数据一起流动，如图3-8所示。 水位线有两个基本属性： 必须单调递增，以确保任务的事件时间时钟在向前推进，而不是在后退。 它们与数据的时间戳相关。带有时间戳T的水位线表示，所有后续数据的时间戳都应该大于T。 上面的第二个属性用于处理带有乱序时间戳的数据流，比如图3-8中时间戳3和5的数据。基于时间的算子任务会收集和处理数据（这些数据可能具有乱序的时间戳），并在事件时间时钟到达某个时刻时完成计算。这个时刻就表示数据收集的截止，具有之前时间戳的数据应该都已经到达、不再需要了；而其中的事件时间时钟，正是由当前接收到的水位线来指示的。如果任务再接收到的数据违反了watermark的这一属性，也就是时间戳小于以前接收到的水位线时，它所属的那部分计算可能已经完成了。这种数据被称为延迟数据（late records）。Flink提供了处理延迟数据的不同方式，我们会在“处理延迟数据”一节中讨论。 水位线还有一个很有趣的特性，它允许应用程序自己来平衡结果的完整性和延迟。如果水位线与数据的时间戳非常接近，那么我们可以得到较低的处理延迟，因为任务在完成计算之前只会短暂地等待更多数据到达。而同时，结果的完整性可能会受到影响，因为相关数据可能因为迟到而被视为“延迟数据”，这样就不会包含在结果中。相反，非常保守的水位线提供了足够的时间去等待所有数据到达，这样会增加处理延迟，但提高了结果的完整性。 watermark的传递和事件时间在本节中，我们将讨论算子如何处理水位线。Flink把watermark作为一条特殊的数据来实现，它也会由算子任务接收和发送。任务会有一个内部的时间服务，它会维护定时器，并在收到watermark时触发。任务可以在计时器服务中注册定时器，以便在将来特定的时间点执行计算。例如，窗口算子为每个活动窗口注册一个定时器，当事件时间超过窗口的结束时间时，该计时器将清除窗口的状态。 当任务收到watermark时，将执行以下操作： 任务根据watermark的时间戳更新其内部事件时钟。 任务的时间服务会将所有过期的计时器标识出来，它们的时间小于当前的事件时间。对于每个过期的计时器，任务调用一个回调函数，该函数可以执行计算并发送结果。 任务会发出一个带有更新后的事件时间的watermark。 Flink限制通过DataStream API访问时间戳和watermark。函数不能读取或修改数据的时间戳和watermark，但底层的“处理函数”（process functions）除外，它们可以读取当前处理数据的时间戳、请求算子的当前事件时间，还可以注册定时器。通常的函数都不会暴露这些可以设置时间戳、操作任务事件时间时钟、或者发出水位线的API。而基于时间的数据流算子任务则会配置发送出的数据的时间戳，以确保它们能够与已到达的水位线平齐。例如，窗口计算完成后，时间窗口的算子任务会将窗口的结束时间作为时间戳附加到将要发送出的结果数据上，然后再使用触发窗口计算的时间戳发出watermark。 现在，让我们更详细地解释一下任务在接收到新的watermark时，如何继续发送watermark并更新其事件时钟。正如我们在“数据并发和任务并发”中所了解的，Flink将数据流拆分为多个分区，并通过单独的算子任务并行地处理每个分区。每个分区都是一个流，里面包含了带着时间戳的数据和watermark。一个算子与它前置或后续算子的连接方式有多种情况，所以它对应的任务可以从一个或多个“输入分区”接收数据和watermark，同时也可以将数据和watermark发送到一个或多个“输出分区”。接下来，我们将详细描述一个任务如何向多个输出任务发送watermark，以及如何通过接收到的watermark来驱动事件时间时钟前进。 任务为每个输入分区维护一个分区水位线（watermark）。当从一个分区接收到watermark时，它会比较新接收到的值和当前水位值，然后将相应的分区watermark更新为两者的最大值。然后，任务会比较所有分区watermark的大小，将其事件时钟更新为所有分区watermark的最小值。如果事件时间时钟前进了，任务就将处理所有被触发的定时器操作，并向所有连接的输出分区发送出相应的watermark，最终将新的事件时间广播给所有下游任务。 图3-9显示了具有四个输入分区和三个输出分区的任务如何接收watermark、更新分区watermark和事件时间时钟，以及向下游发出watermark。 具有两个或多个输入流（如Union或CoFlatMap）的算子任务（参见“多流转换”一节）也会以所有分区watermark的最小值作为事件时间时钟。它们并不区分不同输入流的分区watermark，所以两个输入流的数据都是基于相同的事件时间时钟进行处理的。当然我们可以想到，如果应用程序的各个输入流的事件时间不一致，那么这种处理方式可能会导致问题。 Flink的水位处理和传递算法，确保了算子任务发出的时间戳和watermark是“对齐”的。不过它依赖一个条件，那就是所有分区都会提供不断增长的watermark。一旦一个分区不再推进水位线的上升，或者完全处于空闲状态、不再发送任何数据和watermark，任务的事件时间时钟就将停滞不前，任务的定时器也就无法触发了。对于基于时间的算子来说，它们需要依赖时钟的推进来执行计算和清除状态，这种情况显然就会有问题。如果任务没有定期从所有输入任务接收到新的watermark，那么基于时间的算子的处理延迟和状态空间的大小都会显著增加。 对于具有两个输入流而且watermark明显不同的算子，也会出现类似的情况。具有两个输入流的任务的事件时间时钟，将会同较慢的那条流的watermark保持一致，而通常较快流的数据或者中间结果会在state中缓冲，直到事件时间时钟达到这条流的watermark，才会允许处理它们。 时间戳的分配和水位线的产生我们已经解释了什么是时间戳和水位线，以及它们是如何由Flink内部处理的；然而我们还没有讨论它们的产生。流应用程序接收到数据流时，通常就会先分配时间戳并生成水位线（watermark）。因为时间戳的选择是由不同的应用程序决定的，而且watermark取决于时间戳和流的特性，所以应用程序必须首先显式地分配时间戳并生成watermark。Flink流应用程序可以通过三种方式分配时间戳和生成watermark： 在数据源（source）处分配：当数据流被摄入到应用程序中时，可以由“源函数”SourceFunction分配和生成时间戳和watermark。SourceFunction可以产生并发送一个数据流；数据会与相关的时间戳一起发送出去，而watermark可以作为一条特殊数据在任何时间点发出。如果SourceFunction（暂时）不再发出watermark，它可以声明自己处于“空闲”（idle）状态。Flink会在后续算子的水位计算中，把空闲的SourceFunction产生的流分区排除掉。source的这一空闲机制，可以用来解决前面提到的水位不再上升的问题。源函数（Source Function）在“实现自定义源函数”一节中进行了更详细的讨论。 定期分配：在Flink中，DataStream API提供一个名为AssignerWithPeriodicWatermarks的用户定义函数，它可以从每个数据中提取时间戳，并被定期调用以生成当前watermark。提取出的时间戳被分配给相应的数据，而生成的watermark也会添加到流中。这个函数将在“分配时间戳和生成水位线”一节中讨论。 间断分配：AssignerWithPunctuatedWatermarks是另一个用户定义的函数，它同样会从每个数据中提取一个时间戳。它可以用于生成特殊输入数据中的watermark。与AssignerWithPeriodicWatermarks相比，此函数可以（但不是必须）从每个记录中提取watermark。我们在“分配时间戳和生成水位线”一节中同样讨论了该函数。 用户定义的时间戳分配函数并没有严格的限制，通常会放在尽可能靠近source算子的位置，因为当经过一些算子处理后，数据及其时间戳的顺序就更加难以解释了。所以尽管我们可以在流应用程序的中段覆盖已有的时间戳和watermark——Flink通过用户定义的函数提供了这种灵活性，但这显然并不是推荐的做法。 状态管理在第2章中，我们已经知道大多数流应用程序都是有状态的。许多算子会不断地读取和更新状态，例如在窗口中收集的数据、读取输入源的位置，或者像机器学习模型那样的用户定制化的算子状态。 Flink用同样的方式处理所有的状态，无论是内置的还是用户自定义的算子。本节我们将会讨论Flink支持的不同类型的状态，并解释“状态后端”是如何存储和维护状态的。 一般来说，由一个任务维护，并且用来计算某个结果的所有数据，都属于这个任务的状态。你可以认为状态就是一个本地变量，可以被任务的业务逻辑访问。图3-10显示了任务与其状态之间的交互。 任务会接收一些输入数据。在处理数据时，任务可以读取和更新状态，并根据输入数据和状态计算结果。最简单的例子，就是统计接收到多少条数据的任务。当任务收到新数据时，它会访问状态以获取当前的计数，然后让计数递增，更新状态并发送出新的计数。 应用程序里，读取和写入状态的逻辑一般都很简单直接，而有效可靠的状态管理会复杂一些。这包括如何处理很大的状态——可能会超过内存，并且保证在发生故障时不会丢失任何状态。幸运的是，Flink会帮我们处理这相关的所有问题，包括状态一致性、故障处理以及高效存储和访问，以便开发人员可以专注于应用程序的逻辑。 在Flink中，状态始终与特定算子相关联。为了使运行时的Flink了解算子的状态，算子需要预先注册其状态。总的说来，有两种类型的状态：算子状态（operator state）和键控状态（keyed state），它们有着不同的范围访问，我们将在下面展开讨论。 算子状态算子状态的作用范围限定为算子任务。这意味着由同一并行任务所处理的所有数据都可以访问到相同的状态，状态对于同一任务而言是共享的。算子状态不能由相同或不同算子的另一个任务访问。图3-11显示了任务如何访问算子状态。 Flink为算子状态提供三种基本数据结构： 列表状态（List state）将状态表示为一组数据的列表。 联合列表状态（Union list state）也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保存点（savepoint）启动应用程序时如何恢复。我们将在后面继续讨论。 广播状态（Broadcast state）如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态。在保存检查点和重新调整算子并行度时，会用到这个特性。这两部分内容将在本章后面讨论。 键控状态（Keyed State）顾名思义，键控状态是根据输入数据流中定义的键（key）来维护和访问的。Flink为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的key。因此，具有相同key的所有数据都会访问相同的状态。图3-12显示了任务如何与键控状态进行交互。 我们可以将键控状态看成是在算子所有并行任务上，对键进行分区（或分片）之后的一个键值映射（key-value map）。 Flink为键控状态提供不同的数据结构，用于确定map中每个key存储的值的类型。我们简单了解一下最常见的键控状态。 值状态（Value state）为每个键存储一个任意类型的单个值。复杂数据结构也可以存储为值状态。 列表状态（List state）为每个键存储一个值的列表。列表里的每个数据可以是任意类型。 映射状态（Map state）为每个键存储一个键值映射（map）。map的key和value可以是任意类型。 状态的数据结构可以让Flink实现更有效的状态访问。我们将在“在运行时上下文（RuntimeContext）中声明键控状态”中做进一步讨论。 状态后端（State Backends）每传入一条数据，有状态的算子任务都会读取和更新状态。由于有效的状态访问对于处理数据的低延迟至关重要，因此每个并行任务都会在本地维护其状态，以确保快速的状态访问。状态到底是如何被存储、访问以及维护的？这件事由一个可插入的组件决定，这个组件就叫做状态后端（state backend）。状态后端主要负责两件事：本地的状态管理，以及将检查点（checkpoint）状态写入远程存储。 对于本地状态管理，状态后端会存储所有键控状态，并确保所有的访问都被正确地限定在当前键范围。 Flink提供了默认的状态后端，会将键控状态作为内存中的对象进行管理，将它们存储在JVM堆上。另一种状态后端则会把状态对象进行序列化，并将它们放入RocksDB中，然后写入本地硬盘。第一种方式可以提供非常快速的状态访问，但它受内存大小的限制；而访问RocksDB状态后端存储的状态速度会较慢，但其状态可以增长到非常大。 状态检查点的写入也非常重要，这是因为Flink是一个分布式系统，而状态只能在本地维护。 TaskManager进程（所有任务在其上运行）可能在任何时间点挂掉。因此，它的本地存储只能被认为是不稳定的。状态后端负责将任务的状态检查点写入远程的持久存储。写入检查点的远程存储可以是分布式文件系统，也可以是数据库。不同的状态后端在状态检查点的写入机制方面有所不同。例如，RocksDB状态后端支持增量的检查点，这对于非常大的状态来说，可以显著减少状态检查点写入的开销。 我们将在“选择状态后端”一节中更详细地讨论不同的状态后端及其优缺点。 调整有状态算子的并行度流应用程序的一个常见要求是，为了增大或较小输入数据的速率，需要灵活地调整算子的并行度。对于无状态算子而言，并行度的调整没有任何问题，但更改有状态算子的并行度显然就没那么简单了，因为它们的状态需要重新分区并分配给更多或更少的并行任务。 Flink支持四种模式来调整不同类型的状态。 具有键控状态的算子通过将键重新分区为更少或更多任务来缩放并行度。不过，并行度调整时任务之间会有一些必要的状态转移。为了提高效率，Flink并不会对单独的key做重新分配，而是用所谓的“键组”（key group）把键管理起来。键组是key的分区形式，同时也是Flink为任务分配key的方式。图3-13显示了如何在键组中重新分配键控状态。 具有算子列表状态的算子，会通过重新分配列表中的数据项目来进行并行度缩放。从概念上讲，所有并行算子任务的列表项目会被收集起来，并将其均匀地重新分配给更少或更多的任务。如果列表条目少于算子的新并行度，则某些任务将以空状态开始。图3-14显示了算子列表状态的重新分配。 具有算子联合列表状态的算子，会通过向每个任务广播状态的完整列表，来进行并行度的缩放。然后，任务可以选择要使用的状态项和要丢弃的状态项。图3-15显示了如何重新分配算子联合列表状态。 具有算子广播状态的算子，通过将状态复制到新任务，来增大任务的并行度。这是没问题的，因为广播状态保证了所有任务都具有相同的状态。而对于缩小并行度的情况，我们可以直接取消剩余任务，因为状态是相同的，已经被复制并且不会丢失。图3-16显示了算子广播状态的重新分配。 检查点，保存点和状态恢复Flink是一个分布式数据处理系统，因此必须有一套机制处理各种故障，比如被杀掉的进程，故障的机器和中断的网络连接。任务都是在本地维护状态的，所以Flink必须确保状态不会丢失，并且在发生故障时能够保持一致。 在本节中，我们将介绍Flink的检查点（checkpoint）和恢复机制，这保证了“精确一次”（exactly-once）的状态一致性。我们还会讨论Flink独特的保存点（savepoint）功能，这是一个“瑞士军刀”式的工具，可以解决许多操作数据流时面对的问题。 一致的检查点（Checkpoints）Flink的恢复机制的核心，就是应用状态的一致检查点。有状态流应用的一致检查点，其实就是所有任务状态在某个时间点的一份拷贝，而这个时间点应该是所有任务都恰好处理完一个相同的输入数据的时候。这个过程可以通过一致检查点的一个简单算法步骤来解释。这个算法的步骤是： 暂停所有输入流的摄取，也就是不再接收新数据的输入。 等待所有正在处理的数据计算完毕，这意味着结束时，所有任务都已经处理了所有输入数据。 通过将每个任务的状态复制到远程持久存储，来得到一个检查点。所有任务完成拷贝操作后，检查点就完成了。 恢复所有输入流的摄取。 需要注意，Flink实现的并不是这种简单的机制。我们将在本节后面介绍Flink更精妙的检查点算法。 图3-17显示了一个简单应用中的一致检查点。 上面的应用程序中具有单一的输入源（source）任务，输入数据就是一组不断增长的数字的流——1,2,3等。数字流被划分为偶数流和奇数流。求和算子（sum）的两个任务会分别实时计算当前所有偶数和奇数的总和。源任务会将其输入流的当前偏移量存储为状态，而求和任务则将当前的总和值存储为状态。在图3-17中，Flink在输入偏移量为5时，将检查点写入了远程存储，当前的总和为6和9。 从一致检查点中恢复状态在执行流应用程序期间，Flink会定期检查状态的一致检查点。如果发生故障，Flink将会使用最近的检查点来一致恢复应用程序的状态，并重新启动处理流程。图3-18显示了恢复过程。 应用程序从检查点的恢复分为三步： 重新启动整个应用程序。 将所有的有状态任务的状态重置为最近一次的检查点。 恢复所有任务的处理。 这种检查点的保存和恢复机制可以为应用程序状态提供“精确一次”（exactly-once）的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流就都会被重置到检查点完成时的位置。至于数据源是否可以重置它的输入流，这取决于其实现方式和消费流数据的外部接口。例如，像Apache Kafka这样的事件日志系统可以提供流上之前偏移位置的数据，所以我们可以将源重置到之前的偏移量，重新消费数据。而从套接字（socket）消费数据的流就不能被重置了，因为套接字的数据一旦被消费就会丢弃掉。因此，对于应用程序而言，只有当所有的输入流消费的都是可重置的数据源时，才能确保在“精确一次”的状态一致性下运行。 从检查点重新启动应用程序后，其内部状态与检查点完成时的状态完全相同。然后它就会开始消费并处理检查点和发生故障之间的所有数据。尽管这意味着Flink会对一些数据处理两次（在故障之前和之后），我们仍然可以说这个机制实现了精确一次的一致性语义，因为所有算子的状态都已被重置，而重置后的状态下还不曾看到这些数据。 我们必须指出，Flink的检查点保存和恢复机制仅仅可以重置流应用程序的内部状态。对于应用中的一些的输出（sink）算子，在恢复期间，某些结果数据可能会多次发送到下游系统，比如事件日志、文件系统或数据库。对于某些存储系统，Flink提供了具有精确一次输出功能的sink函数，比如，可以在检查点完成时提交发出的记录。另一种适用于许多存储系统的方法是幂等更新。在“应用程序一致性保证”一节中，我们还会详细讨论如何解决应用程序端到端的精确一次一致性问题。 Flink的检查点算法Flink的恢复机制，基于它的一致性检查点。前面我们已经了解了从流应用中创建检查点的简单方法——先暂停应用，保存检查点，然后再恢复应用程序，这种方法很好理解，但它的理念是“停止一切”，这对于即使是中等延迟要求的应用程序而言也是不实用的。所以Flink没有这么简单粗暴，而是基于Chandy-Lamport算法实现了分布式快照的检查点保存。该算法并不会暂停整个应用程序，而是将检查点的保存与数据处理分离，这样就可以实现在其它任务做检查点状态保存状态时，让某些任务继续进行而不受影响。接下来我们将解释此算法的工作原理。 Flink的检查点算法用到了一种称为“检查点分界线”（checkpoint barrier）的特殊数据形式。与水位线（watermark）类似，检查点分界线由source算子注入到常规的数据流中，它的位置是限定好的，不能超过其他数据，也不能被后面的数据超过。检查点分界线带有检查点ID，用来标识它所属的检查点；这样，这个分界线就将一条流逻辑上分成了两部分。分界线之前到来的数据导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中。 我们用一个简单的流应用程序作为示例，来一步一步解释这个算法。该应用程序有两个源（source）任务，每个任务都消费一个增长的数字流。源任务的输出被划分为两部分：偶数和奇数的流。每个分区由一个任务处理，该任务计算所有收到的数字的总和，并将更新的总和转发给输出（sink）任务。这个应用程序的结构如图3-19所示。 JobManager会向每个数据源（source）任务发送一条带有新检查点ID的消息，通过这种方式来启动检查点，如图3-20所示。 当source任务收到消息时，它会暂停发出新的数据，在状态后端触发本地状态的检查点保存，并向所有传出的流分区广播带着检查点ID的分界线（barriers）。状态后端在状态检查点完成后会通知任务，而任务会向JobManager确认检查点完成。在发出所有分界线后，source任务就可以继续常规操作，发出新的数据了。通过将分界线注入到输出流中，源函数（source function）定义了检查点在流中所处的位置。图3-21显示了两个源任务将本地状态保存到检查点，并发出检查点分界线之后的流应用程序。 源任务发出的检查点分界线（barrier），将被传递给所连接的任务。与水位线（watermark）类似，barrier会被广播到所有连接的并行任务，以确保每个任务从它的每个输入流中都能接收到。当任务收到一个新检查点的barrier时，它会等待这个检查点的所有输入分区的barrier到达。在等待的过程中，任务并不会闲着，而是会继续处理尚未提供barrier的流分区中的数据。对于那些barrier已经到达的分区，如果继续有新的数据到达，它们就不会被立即处理，而是先缓存起来。这个等待所有分界线到达的过程，称为“分界线对齐”（barrier alignment），如图3-22所示。 当任务从所有输入分区都收到barrier时，它就会在状态后端启动一个检查点的保存，并继续向所有下游连接的任务广播检查点分界线，如图3-23所示。 所有的检查点barrier都发出后，任务就开始处理之前缓冲的数据。在处理并发出所有缓冲数据之后，任务就可以继续正常处理输入流了。图3-24显示了此时的应用程序。 最终，检查点分界线会到达输出（sink）任务。当sink任务接收到barrier时，它也会先执行“分界线对齐”，然后将自己的状态保存到检查点，并向JobManager确认已接收到barrier。一旦从应用程序的所有任务收到一个检查点的确认信息，JobManager就会将这个检查点记录为已完成。图3-25显示了检查点算法的最后一步。这样，当发生故障时，我们就可以用已完成的检查点恢复应用程序了。 检查点的性能影响Flink的检查点算法可以在不停止整个应用程序的情况下，生成一致的分布式检查点。但是，它可能会增加应用程序的处理延迟。Flink对此有一些调整措施，可以在某些场景下显得对性能的影响没那么大。 当任务将其状态保存到检查点时，它其实处于一个阻塞状态，而此时新的输入会被缓存起来。由于状态可能变得非常大，而且检查点需要通过网络将数据写入远程存储系统，检查点的写入很容易就会花费几秒到几分钟的时间——这对于要求低延迟的应用程序而言，显然是不可接受的。在Flink的设计中，真正负责执行检查点写入的，其实是状态后端。具体怎样复制任务的状态，取决于状态后端的实现方式。例如，文件系统（FileSystem）状态后端和RocksDB状态后端都支持了异步（asynchronous）检查点。触发检查点操作时，状态后端会先创建状态的本地副本。本地拷贝完成后，任务就将继续常规的数据处理，这往往并不会花费太多时间。一个后台线程会将本地快照异步复制到远程存储，并在完成检查点后再回来通知任务。异步检查点的机制，显著减少了任务继续处理数据之前的等待时间。此外，RocksDB状态后端还实现了增量的检查点，这样可以大大减少要传输的数据量。 为了减少检查点算法对处理延迟的影响，另一种技术是调整分界线对齐的步骤。对于需要非常低的延迟、并且可以容忍“至少一次”（at-least-once）状态保证的应用程序，Flink可以将检查点算法配置为，在等待barrier对齐期间处理所有到达的数据，而不是把barrier已经到达的那些分区的数据缓存起来。当检查点的所有barrier到达，算子任务就会将状态写入检查点——当然，现在的状态中，就可能包括了一些“提前”的更改，这些更改由本该属于下一个检查点的数据到来时触发。如果发生故障，从检查点恢复时，就将再次处理这些数据：这意味着检查点现在提供的是“至少一次”（at-least-once）而不是“精确一次”（exactly-once）的一致性保证。 保存点（Savepoints）Flink的恢复算法是基于状态检查点的。Flink根据可配置的策略，定期保存并自动丢弃检查点。检查点的目的是确保在发生故障时可以重新启动应用程序，所以当应用程序被显式地撤销（cancel）时，检查点会被删除掉。除此之外，应用程序状态的一致性快照还可用于除故障恢复之外的更多功能。 Flink中一个最有价值，也是最独特的功能是保存点（savepoints）。原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为就是具有一些额外元数据的检查点。 Flink不会自动创建保存点，因此用户（或者外部调度程序）必须明确地触发创建操作。同样，Flink也不会自动清理保存点。第10章将会具体介绍如何触发和处理保存点。 使用保存点有了应用程序和与之兼容的保存点，我们就可以从保存点启动应用程序了。这会将应用程序的状态初始化为保存点的状态，并从保存点创建时的状态开始运行应用程序。虽然看起来这种行为似乎与用检查点从故障中恢复应用程序完全相同，但实际上故障恢复只是一种特殊情况，它只是在相同的集群上以相同的配置启动相同的应用程序。而从保存点启动应用程序会更加灵活，这就可以让我们做更多事情了。 可以从保存点启动不同但兼容的应用程序。这样一来，我们就可以及时修复应用程序中的逻辑bug，并让流式应用的源尽可能多地提供之前发生的事件，然后重新处理，以便修复之前的计算结果。修改后的应用程序还可用于运行A / B测试，或者具有不同业务逻辑的假设场景。这里要注意，应用程序和保存点必须兼容才可以这么做——也就是说，应用程序必须能够加载保存点的状态。 可以使用不同的并行度来启动相同的应用程序，可以将应用程序的并行度增大或减小。 可以在不同的集群上启动同样的应用程序。这非常有意义，意味着我们可以将应用程序迁移到较新的Flink版本或不同的集群上去。 可以使用保存点暂停应用程序，稍后再恢复。这样做的意义在于，可以为更高优先级的应用程序释放集群资源，或者在输入数据不连续生成时释放集群资源。 还可以将保存点设置为某一版本，并归档（archive）存储应用程序的状态。 保存点是非常强大的功能，所以许多用户会定期创建保存点以便能够及时退回之前的状态。我们见到的各种场景中，保存点一个最有趣的应用是不断将流应用程序迁移到更便宜的数据中心上去。 从保存点启动应用程序前面提到的保存点的所有用例，都遵循相同的模式。那就是首先创建正在运行的应用程序的保存点，然后在一个新启动的应用程序中用它来恢复状态。之前我们已经知道，保存点的创建和检查点非常相似，而接下来我们就将介绍对于一个从保存点启动的应用程序，Flink如何初始化其状态。 应用程序由多个算子组成。每个算子可以定义一个或多个键控状态和算子状态。算子由一个或多个算子任务并行执行。因此，一个典型的应用程序会包含多个状态，这些状态分布在多个算子任务中，这些任务可以运行在不同的TaskManager进程上。 图3-26显示了一个具有三个算子的应用程序，每个算子执行两个算子任务。一个算子（OP-1）具有单一的算子状态（OS-1），而另一个算子（OP-2）具有两个键控状态（KS-1和KS-2）。当保存点创建时，会将所有任务的状态复制到持久化的存储位置。 保存点中的状态拷贝会以算子标识符（operator ID）和状态名称（state name）组织起来。算子ID和状态名称必须能够将保存点的状态数据，映射到一个正在启动的应用程序的算子状态。从保存点启动应用程序时，Flink会将保存点的数据重新分配给相应的算子任务。 请注意，保存点不包含有关算子任务的信息。这是因为当应用程序以不同的并行度启动时，任务数量可能会更改。 如果我们要从保存点启动一个修改过的应用程序，那么保存点中的状态只能映射到符合标准的应用程序——它里面的算子必须具有相应的ID和状态名称。默认情况下，Flink会自动分配唯一的算子ID。然而，一个算子的ID，是基于它之前算子的ID确定性地生成的。因此，算子的ID会在其前序算子改变时改变，比如，当我们添加了新的或移除掉一个算子时，前序算子ID改变，当前算子ID就会变化。所以对于具有默认算子ID的应用程序而言，如果想在不丢失状态的前提下升级，就会受到极大的限制。因此，我们强烈建议在程序中为算子手动分配唯一ID，而不是依靠Flink的默认分配。我们将在“指定唯一的算子标识符”一节中详细说明如何分配算子标识符。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列02流处理基础","slug":"flink系列02流处理基础","date":"2020-06-27T15:24:42.000Z","updated":"2020-06-27T15:25:52.705Z","comments":true,"path":"2020/06/27/flink系列02流处理基础/","link":"","permalink":"https://masteryang4.github.io/2020/06/27/flink%E7%B3%BB%E5%88%9702%E6%B5%81%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/","excerpt":"","text":"第二章，流处理基础数据流编程简介在我们深入研究流处理的基础知识之前，让我们来看看在数据流程编程的背景和使用的术语。 数据流图(dataflow graph)顾名思义，数据流程序描述了数据如何在算子之间流动。数据流程序通常表示为有向图，其中节点称为算子，用来表示计算，边表示数据之间的依赖性。算子是数据流程序的基本功能单元。他们从输入消耗数据，对它们执行计算，并生成数据输出用于进一步处理。一个数据流图必须至少有一个数据源和一个数据接收器。 像图2-1中的数据流图被称为逻辑流图，因为它们表示了计算逻辑的高级视图。为了执行一个数据流程序，Flink会将逻辑流图转换为物理数据流图，详细说明程序的执行方式。例如，如果我们使用分布式处理引擎，每个算子在不同的物理机器可能有几个并行的任务运行。图2-2显示了图2-1逻辑图的物理数据流图。而在逻辑数据流图中节点表示算子，在物理数据流图中，节点是任务。“Extract hashtags”和“Count”算子有两个并行算子任务，每个算子任务对输入数据的子集执行计算。 数据并行和任务并行我们可以以不同方式利用数据流图中的并行性。第一，我们可以对输入数据进行分区，并在数据的子集上并行执行具有相同算子的任务并行。这种类型的并行性被称为数据并行性。数据并行是有用的，因为它允许处理大量数据，并将计算分散到不同的计算节点上。第二，我们可以将不同的算子在相同或不同的数据上并行执行。这种并行性称为任务并行性。使用任务并行性，我们可以更好地利用计算资源。 数据交换策略数据交换策略定义了在物理执行流图中如何将数据分配给任务。数据交换策略可以由执行引擎自动选择，具体取决于算子的语义或我们明确指定的语义。在这里，我们简要回顾一些常见的数据交换策略，如图2-3所示。 前向策略将数据从一个任务发送到接收任务。如果两个任务都位于同一台物理计算机上（这通常由任务调度器确保），这种交换策略可以避免网络通信。 广播策略将所有数据发送到算子的所有的并行任务上面去。因为这种策略会复制数据和涉及网络通信，所以代价相当昂贵。 基于键控的策略通过Key值(键)对数据进行分区保证具有相同Key的数据将由同一任务处理。在图2-2中，输出“Extract hashtags”算子使用键来分区（hashtag），以便count算子的任务可以正确计算每个#标签的出现次数。 随机策略统一将数据分配到算子的任务中去，以便均匀地将负载分配到不同的计算任务。 并行处理流数据既然我们熟悉了数据流编程的基础知识，现在是时候看看这些概念如何应用于并行的处理数据流了。但首先，让我们定义术语数据流：数据流是一个可能无限的事件序列。 数据流中的事件可以表示监控数据，传感器测量数据，信用卡交易数据，气象站观测数据，在线用户交互数据，网络搜索数据等。在本节中，我们将学习如何并行处理无限流，使用数据流编程范式。 延迟和吞吐量流处理程序不同与批处理程序。在评估性能时，要求也有所不同。对于批处理程序，我们通常关心一个作业的总的执行时间，或我们的处理引擎读取输入所需的时间，执行计算，并回写结果。由于流处理程序是连续运行的，输入可能是无界的，所以数据流处理中没有总执行时间的概念。 相反，流处理程序必须尽可能快的提供输入数据的计算结果。我们使用延迟和吞吐量来表征流处理的性能要求。 延迟延迟表示处理事件所需的时间。它是接收事件和看到在输出中处理此事件的效果之间的时间间隔。要直观的理解延迟，考虑去咖啡店买咖啡。当你进入咖啡店时，可能还有其他顾客在里面。因此，你排队等候直到轮到你下订单。收银员收到你的付款并通知准备饮料的咖啡师。一旦你的咖啡准备好了，咖啡师会叫你的名字，你可以到柜台拿你的咖啡。服务延迟是从你进入咖啡店的那一刻起，直到你喝上第一口咖啡之间的时间间隔。 在数据流中，延迟是以时间为单位测量的，例如毫秒。根据应用程序，我们可能会关心平均延迟，最大延迟或百分位延迟。例如，平均延迟值为10ms意味着处理事件的平均时间在10毫秒内。或者，延迟值为95%，10ms表示95%的事件在10ms内处理完毕。平均值隐藏了处理延迟的真实分布，可能会让人难以发现问题。如果咖啡师在准备卡布奇诺之前用完了牛奶，你必须等到他们从供应室带来一些。虽然你可能会因为这么长时间的延迟而生气，但大多数其他客户仍然会感到高兴。 确保低延迟对于许多流应用程序来说至关重要，例如欺诈检测，系统警报，网络监控和提供具有严格服务水平协议的服务。低延迟是流处理的关键特性，它实现了我们所谓的实时应用程序。像Apache Flink这样的现代流处理器可以提供低至几毫秒的延迟。相比之下，传统批处理程序延迟通常从几分钟到几个小时不等。在批处理中，首先需要收集事件批次，然后才能处理它们。因此，延迟是受每个批次中最后一个事件的到达时间的限制。所以自然而然取决于批的大小。真正的流处理不会引入这样的人为延迟，因此可以实现真正的低延迟。真的流模型，事件一进入系统就可以得到处理。延迟更密切地反映了在每个事件上必须进行的实际工作。 吞吐量吞吐量是衡量系统处理能力的指标，也就是处理速率。也就是说，吞吐量告诉我们每个时间单位系统可以处理多少事件。重温咖啡店的例子，如果商店营业时间为早上7点至晚上7点。当天为600个客户提供了服务，它的平均吞吐量将是每小时50个客户。虽然我们希望延迟尽可能低，但我们通常也需要吞吐量尽可能高。 吞吐量以每个时间单位系统所能处理的事件数量或操作数量来衡量。值得注意的是，事件处理速率取决于事件到达的速率，低吞吐量并不一定表示性能不佳。 在流式系统中，我们通常希望确保我们的系统可以处理最大的预期事件到达的速率。也就是说，我们主要的关注点在于确定的峰值吞吐量是多少，当系统处于最大负载时性能怎么样。为了更好地理解峰值吞吐量的概念，让我们考虑一个流处理 程序没有收到任何输入的数据，因此没有消耗任何系统资源。当第一个事件进来时，它会尽可能以最小延迟立即处理。例如，如果你是第一个出现在咖啡店的顾客，在早上开门后，你将立即获得服务。理想情况下，您希望此延迟保持不变 ，并且独立于传入事件的速率。但是，一旦我们达到使系统资源被完全使用的事件传入速率，我们将不得不开始缓冲事件。在咖啡店里 ，午餐后会看到这种情况发生。许多人出现在同一时间，必须排队等候。在此刻，咖啡店系统已达到其峰值吞吐量，进一步增加 事件传入的速率只会导致更糟糕的延迟。如果系统继续以可以处理的速率接收数据，缓冲区可能变为不可用，数据可能会丢失。这种情况是众所周知的 作为背压，有不同的策略来处理它。 延迟与吞吐量的对比此时，应该清楚延迟和吞吐量不是独立指标。如果事件需要在处理流水线中待上很长时间，我们不能轻易确保高吞吐量。同样，如果系统容量很小，事件将被缓冲，而且必须等待才能得到处理。 让我们重温一下咖啡店的例子来阐明一下延迟和吞吐量如何相互影响。首先，应该清楚存在没有负载时的最佳延迟。也就是说，如果你是咖啡店的唯一客户，会很快得到咖啡。然而，在繁忙时期，客户将不得不排队等待，并且会有延迟增加。另一个影响延迟和吞吐量的因素是处理事件所花费的时间或为每个客户提供服务所花费的时间。想象一下，期间圣诞节假期，咖啡师不得不为每杯咖啡画圣诞老人。这意味着准备一杯咖啡需要的时间会增加，导致每个人花费 更多的时间在等待咖啡师画圣诞老人，从而降低整体吞吐量。 那么，你可以同时获得低延迟和高吞吐量吗？或者这是一个无望的努力？我们可以降低得到咖啡的延迟 ，方法是：聘请一位更熟练的咖啡师来准备咖啡。在高负载时，这种变化也会增加吞吐量，因为会在相同的时间内为更多的客户提供服务。 实现相同结果的另一种方法是雇用第二个咖啡师来利用并行性。这里的主要想法是降低延迟来增加吞吐量。当然，如果系统可以更快的执行操作，它可以在相同的时间内执行更多操作。 事实上，在流中利用并行性时也会发生这种情况。通过并行处理多个流，在同时处理更多事件的同时降低延迟。 数据流上的操作流处理引擎通常提供一组内置操作：摄取(ingest)，转换(transform)和输出流(output)。这些操作可以 结合到数据流图中来实现逻辑流处理程序。在本节中，我们描述最常见的流处理操作。 操作可以是无状态的或有状态的。无状态操作不保持任何内部状态。也就是说，事件的处理不依赖于过去看到的任何事件，也没有保留历史。 无状态操作很容易并行化，因为事件可以彼此独立地处理，也独立于事件到达的顺序(和事件到达顺序没有关系)。 而且，在失败的情况下，无状态操作可以是简单的重新启动并从中断处继续处理。相反， 有状态操作可能会维护之前收到的事件的信息。此状态可以通过传入事件更新，也可以用于未来事件的处理逻辑。有状态的流 处理应用程序更难以并行化和以容错的方式来运行，因为状态需要有效的进行分区和在发生故障的情况下可靠地恢复。 数据摄入和数据吞吐量数据摄取和数据出口操作允许流处理程序与外部系统通信。数据摄取是操作从外部源获取原始数据并将其转换为其他格式(ETL)。实现数据提取逻辑的运算符被称为数据源。数据源可以从TCP Socket，文件，Kafka Topic或传感器数据接口中提取数据。数据出口是以适合消费的形式产出到外部系统。执行数据出口的运算符称为数据接收器，包括文件，数据库，消息队列和监控接口。 转换算子 转换算子是单遍处理算子，碰到一个事件处理一个事件。这些操作在使用后会消费一个事件，然后对事件数据做一些转换，产生一个新的输出流。转换逻辑可以集成在 操作符中或由UDF函数提供，如图所示图2-4。程序员编写实现自定义计算逻辑。 操作符可以接受多个输入流并产生多个输出流。他们还可以通过修改数据流图的结构要么将流分成多个流，要么将流合并为一条流。 滚动聚合滚动聚合是一种聚合，例如sum，minimum和maximum，为每个输入事件不断更新。 聚合操作是有状态的，并将当前状态与传入事件一起计算以产生更新的聚合值。请注意能够有效地将当前状态与事件相结合 产生单个值，聚合函数必须是关联的和可交换的。否则，操作符必须存储完整的流数据历史。图2-5显示了最小滚动 聚合。操作符保持当前的最小值和相应地为每个传入的事件来更新最小值。 窗口操作符转换和滚动聚合一次处理一个事件产生输出事件并可能更新状态。但是，有些操作必须收集并缓冲数据以计算其结果。 例如，考虑不同流之间的连接或整体聚合这样的操作，例如中值函数。为了在无界流上高效运行这些操作符，我们需要限制 这些操作维护的数据量。在本节中，我们将讨论窗口操作，提供此服务。 窗口还可以在语义上实现关于流的比较复杂的查询。我们已经看到了滚动聚合的方式，以聚合值编码整个流的历史数据来为每个事件提供低延迟的结果。 但如果我们只对最近的数据感兴趣的话会怎样？考虑给司机提供实时交通信息的应用程序。这个程序可以使他们避免拥挤的路线。在这种场景下，你想知道某个位置在最近几分钟内是否有事故发生。 另一方面，了解所有发生过的事故在这个应用场景下并没有什么卵用。更重要的是，通过将流历史缩减为单一聚合值，我们将丢失这段时间内数据的变化。例如，我们可能想知道每5分钟有多少车辆穿过 某个路口。 窗口操作不断从无限事件流中创建有限的事件集，好让我们执行有限集的计算。通常会基于数据属性或基于时间的窗口来分配事件。 要正确定义窗口运算符语义，我们需要确定如何给窗口分配事件以及对窗口中的元素进行求值的频率是什么样的。 窗口的行为由一组策略定义。窗口策略决定何时创建新的窗口以及要分配的事件属于哪个窗口，以及何时对窗口中的元素进行求值。 而窗口的求值基于触发条件。一旦触发条件得到满足，窗口的内容将会被发送到求值函数，求值函数会将计算逻辑应用于窗口中的元素。 求值函数可以是sum或minimal或自定义的聚合函数。 求值策略可以根据时间或者数据属性计算(例如，在过去五秒内收到的事件或者最近的一百个事件等等)。 接下来，我们描述常见窗口类型的语义。 滚动窗口是将事件分配到固定大小的不重叠的窗口中。当通过窗口的结尾时，全部事件被发送到求值函数进行处理。基于计数的滚动窗口定义了在触发求值之前需要收集多少事件。图2-6显示了一个基于计数的翻滚窗口，每四个元素一个窗口。基于时间的滚动窗口定义一个时间间隔，包含在此时间间隔内的事件。图2-7显示了基于时间的滚动窗口，将事件收集到窗口中每10分钟触发一次计算。 滑动窗口将事件分配到固定大小的重叠的窗口中去。因此，事件可能属于多个桶。我们通过提供窗口的长度和滑动距离来定义滑动窗口。滑动距离定义了创建新窗口的间隔。基于滑动计数的窗口，图2-8的长度为四个事件，三个为滑动距离。 会话窗口在常见的真实场景中很有用，一些场景既不能使用滚动窗口也不能使用滑动窗口。考虑一个分析在线用户行为的应用程序。在应用程序里，我们想把源自同一时期的用户活动或会话事件分组在一起。会话由一系列相邻时间发生的事件组成，接下来有一段时间没有活动。例如，用户在App上浏览一系列的新闻，然后关掉App，那么浏览新闻这段时间的浏览事件就是一个会话。会话窗口事先没有定义窗口的长度，而是取决于数据的实际情况，滚动窗口和滑动窗口无法应用于这个场景。相反，我们需要将同一会话中的事件分配到同一个窗口中去，而不同的会话可能窗口长度不一样。会话窗口会定义一个间隙值来区分不同的会话。间隙值的意思是：用户一段时间内不活动，就认为用户的会话结束了。图2-9显示了一个会话窗口。 到目前为止，所有窗口类型都是在整条流上去做窗口操作。但实际上你可能想要将一条流分流成多个逻辑流并定义并行窗口。 例如，如果我们正在接收来自不同传感器的测量结果，那么可能想要在做窗口计算之前按传感器ID对流进行分流操作。 在并行窗口中，每条流都独立于其他流，然后应用了窗口逻辑。图2-10显示了一个基于计数的长度为2的并行滚动窗口，根据事件颜色分流。 在流处理中，窗口操作与两个主要概念密切相关：时间语义和状态管理。时间也许是流处理最重要的方面。即使低延迟是流处理的一个有吸引力的特性，它的真正价值不仅仅是快速分析。真实世界的系统，网络和通信渠道远非完美，流数据经常被推迟或无序(乱序)到达。理解如何在这种条件下提供准确和确定的结果是至关重要的。 更重要的是，流处理程序可以按原样处理事件制作的也应该能够处理相同的历史事件方式，从而实现离线分析甚至时间旅行分析。 当然，前提是我们的系统可以保存状态，因为可能有故障发生。到目前为止，我们看到的所有窗口类型在产生结果前都需要保存之前的数据。实际上，如果我们想计算任何指标，即使是简单的计数，我们也需要保存状态。考虑到流处理程序可能会运行几天，几个月甚至几年，我们需要确保状态可以在发生故障的情况下可靠地恢复。 并且即使程序崩溃，我们的系统也能保证计算出准确的结果。本章，我们将在流处理应用可能发生故障的语境下，深入探讨时间和状态的概念。 时间语义在本节中，我们将介绍时间语义，并描述流中不同的时间概念。我们将讨论流处理器在乱序事件流的情况下如何提供准确的计算结果，以及我们如何处理历史事件流，如何在流中进行时间旅行。 在流处理中一分钟代表什么？在处理可能是无限的事件流（包含了连续到达的事件），时间成为流处理程序的核心方面。假设我们想要连续的计算结果，可能每分钟就要计算一次。在我们的流处理程序上下文中，一分钟的意思是什么？ 考虑一个程序需要分析一款移动端的在线游戏的用户所产生的事件流。游戏中的用户分了组，而应用程序将收集每个小组的活动数据，基于小组中的成员多快达到了游戏设定的目标，然后在游戏中提供奖励。例如额外的生命和用户升级。例如，如果一个小组中的所有用户在一分钟之内都弹出了500个泡泡，他们将升一级。Alice是一个勤奋的玩家，她在每天早晨的通勤时间玩游戏。问题在于Alice住在柏林，并且乘地铁去上班。而柏林的地铁手机信号很差。我们设想一个这样的场景，Alice当她的手机连上网时，开始弹泡泡，然后游戏会将数据发送到我们编写的应用程序中，这时地铁突然进入了隧道，她的手机也断网了。Alice还在玩这个游戏，而产生的事件将会缓存在手机中。当地铁离开隧道，Alice的手机又在线了，而手机中缓存的游戏事件将发送到应用程序。我们的应用程序应该如何处理这些数据？在这个场景中一分钟的意思是什么？这个一分钟应该包含Alice离线的那段时间吗？下图展示了这个问题。 在线手游是一个简单的场景，展示了应用程序的运算应该取决于事件实际发生的时间，而不是应用程序收到事件的时间。如果我们按照应用程序收到事件的时间来进行处理的话，最糟糕的后果就是，Alice和她的朋友们再也不玩这个游戏了。但是还有很多时间语义非常关键的应用程序，我们需要保证时间语义的正确性。如果我们只考虑我们在一分钟之内收到了多少数据，我们的结果会变化，因为结果取决于网络连接的速度或处理的速度。相反，定义一分钟之内的事件数量，这个一分钟应该是数据本身的时间。 在Alice的这个例子中，流处理程序可能会碰到两个不同的时间概念：处理时间和事件时间。我们将在接下来的部分，讨论这两个概念。 处理时间处理时间是处理流的应用程序的机器的本地时钟的时间（墙上时钟）。处理时间的窗口包含了一个时间段内来到机器的所有事件。这个时间段指的是机器的墙上时钟。如下图所示，在Alice的这个例子中，处理时间窗口在Alice的手机离线的情况下，时间将会继续行走。但这个处理时间窗口将不会收集Alice的手机离线时产生的事件。 事件时间事件时间是流中的事件实际发生的时间。事件时间基于流中的事件所包含的时间戳。通常情况下，在事件进入流处理程序前，事件数据就已经包含了时间戳。下图展示了事件时间窗口将会正确的将事件分发到窗口中去。可以如实反应事情是怎么发生的。即使事件可能存在延迟。 事件时间使得计算结果的过程不需要依赖处理数据的速度。基于事件时间的操作是可以预测的，而计算结果也是确定的。无论流处理程序处理流数据的速度快或是慢，无论事件到达流处理程序的速度快或是慢，事件时间窗口的计算结果都是一样的。 可以处理迟到的事件只是我们使用事件时间所克服的一个挑战而已。普遍存在的事件乱序问题可以使用事件时间得到解决。考虑和Alice玩同样游戏的Bob，他恰好和Alice在同一趟地铁上。Alice和Bob虽然玩的游戏一样，但他们的手机信号是不同的运营商提供的。当Alice的手机没信号时，Bob的手机依然有信号，游戏数据可以正常发送出去。 如果使用事件时间，即使碰到了事件乱序到达的情况，我们也可以保证结果的正确性。还有，当我们在处理可以重播的流数据时，由于时间戳的确定性，我们可以快进过去。也就是说，我们可以重播一条流，然后分析历史数据，就好像流中的事件是实时发生一样。另外，我们可以快进历史数据来使我们的应用程序追上现在的事件，然后应用程序仍然是一个实时处理程序，而且业务逻辑不需要改变。 水位线（Watermarks）在我们对事件时间窗口的讨论中，我们忽略了一个很重要的方面：我们应该怎样去决定何时触发事件时间窗口的计算？也就是说，在我们可以确定一个时间点之前的所有事件都已经到达之前，我们需要等待多久？我们如何知道事件是迟到的？在分布式系统无法准确预测行为的现实条件下，以及外部组件所引发的事件的延迟，以上问题并没有准确的答案。在本小节中，我们将会看到如何使用水位线来设置事件时间窗口的行为。 水位线是全局进度的度量标准。系统可以确信在一个时间点之后，不会有早于这个时间点发生的事件到来了。本质上，水位线提供了一个逻辑时钟，这个逻辑时钟告诉系统当前的事件时间。当一个运算符接收到含有时间T的水位线时，这个运算符会认为早于时间T的发生的事件已经全部都到达了。对于事件时间窗口和乱序事件的处理，水位线非常重要。运算符一旦接收到水位线，运算符会认为一段时间内发生的所有事件都已经观察到，可以触发针对这段时间内所有事件的计算了。 水位线提供了一种结果可信度和延时之间的妥协。激进的水位线设置可以保证低延迟，但结果的准确性不够。在这种情况下，迟到的事件有可能晚于水位线到达，我们需要编写一些代码来处理迟到事件。另一方面，如果水位线设置的过于宽松，计算的结果准确性会很高，但可能会增加流处理程序不必要的延时。 在很多真实世界的场景里面，系统无法获得足够的知识来完美的确定水位线。在手游这个场景中，我们无法得知一个用户离线时间会有多长，他们可能正在穿越一条隧道，可能正在乘飞机，可能永远不会再玩儿了。水位线无论是用户自定义的或者是自动生成的，在一个分布式系统中追踪全局的时间进度都不是很容易。所以仅仅依靠水位线可能并不是一个很好的主意。流处理系统还需要提供一些机制来处理迟到的元素（在水位线之后到达的事件）。根据应用场景，我们可能需要把迟到事件丢弃掉，或者写到日志里，或者使用迟到事件来更新之前已经计算好的结果。 处理时间 vs 事件时间大家可能会有疑问，既然事件时间已经可以解决我们的所有问题，为什么我们还要对比这两个时间概念？真相是，处理时间在很多情况下依然很有用。处理时间窗口将会带来理论上最低的延迟。因为我们不需要考虑迟到事件以及乱序事件，所以一个窗口只需要简单的缓存窗口内的数据即可，一旦机器时间超过指定的处理时间窗口的结束时间，就会触发窗口的计算。所以对于一些处理速度比结果准确性更重要的流处理程序，处理时间就派上用场了。另一个应用场景是，当我们需要在真实的时间场景下，周期性的报告结果时，同时不考虑结果的准确性。一个例子就是一个实时监控的仪表盘，负责显示当事件到达时立即聚合的结果。最后，处理时间窗口可以提供流本身数据的忠实表达，对于一些案例可能是很必要的特性。例如我们可能对观察流和对每分钟事件的计数（检测可能存在的停电状况）很感兴趣。简单的说，处理时间提供了低延迟，同时结果也取决于处理速度，并且也不能保证确定性。另一方面，事件时间保证了结果的确定性，同时还可以使我们能够处理迟到的或者乱序的事件流。 状态和持久化模型我们现在转向另一个对于流处理程序非常重要的话题：状态。在数据处理中，状态是普遍存在的。任何稍微复杂一点的计算，都涉及到状态。为了产生计算结果，一个函数在一段时间内的一定数量的事件上来累加状态（例如，聚合计算或者模式匹配）。有状态的运算符使用输入的事件以及内部保存的状态来计算得到输出。例如，一个滚动聚合运算符需要输出这个运算符所观察到的所有事件的累加和。这个运算符将会在内部保存当前观察到的所有事件的累加和，同时每输入一个事件就更新一次累加和的计算结果。相似的，当一个运算符检测到一个“高温”事件紧接着十分钟以内检测到一个“烟雾”事件时，将会报警。直到运算符观察到一个“烟雾”事件或者十分钟的时间段已经过去，这个运算符需要在内部状态中一直保存着“高温”事件。 当我们考虑一下使用批处理系统来分析一个无界数据集时，会发现状态的重要性显而易见。在现代流处理器兴起之前，处理无界数据集的一个通常做法是将输入的事件攒成微批，然后交由批处理器来处理。当一个任务结束时，计算结果将被持久化，而所有的运算符状态就丢失了。一旦一个任务在计算下一个微批次的数据时，这个任务是无法访问上一个任务的状态的（都丢掉了）。这个问题通常使用将状态代理到外部系统（例如数据库）的方法来解决。相反，在一个连续不间断运行的流处理任务中，事件的状态是一直存在的，我们可以将状态暴露出来作为编程模型中的一等公民。当然，我们的确可以使用外部系统来管理流的状态，即使这个解决方案会带来额外的延迟。 由于流处理运算符默认处理的是无界数据流。所以我们必须要注意不要让内部状态无限的增长。为了限制状态的大小，运算符通常情况下会保存一些之前所观察到的事件流的总结或者概要。这个总结可能是一个计数值，一个累加和，或者事件流的采样，窗口的缓存操作，或者是一个自定义的数据结构，这个数据结构用来保存数据流中感兴趣的一些特性。 我们可以想象的到，支持有状态的运算符可能会碰到一些实现上的挑战： 状态管理 系统需要高效的管理状态，并保证针对状态的并发更新，不会产生竞争条件（race condition）。 状态分区 并行会带来复杂性。因为计算结果同时取决于已经保存的状态和输入的事件流。幸运的是，大多数情况下，我们可以使用Key来对状态进行分区，然后独立的管理每一个分区。例如，当我们处理一组传感器的测量事件流时，我们可以使用分区的运算符状态来针对不同的传感器独立的保存状态。 状态恢复 第三个挑战是有状态的运算符如何保证状态可以恢复，即使出现任务失败的情况，计算也是正确的。 下一节，我们将讨论任务失败和计算结果的保证。 任务失败流任务中的运算符状态是很宝贵的，也需要抵御任务失败带来的问题。如果在任务失败的情况下，状态丢失的话，在任务恢复以后计算的结果将是不正确的。流任务会连续不断的运行很长时间，而状态可能已经收集了几天甚至几个月。在失败的情况下，重新处理所有的输入并重新生成一个丢失的状态，将会很浪费时间，开销也很大。 在本章开始时，我们看到如何将流的编程建模成数据流模型。在执行之前，流程序将会被翻译成物理层数据流图，物理层数据流图由连接的并行任务组成，而一个并行任务运行一些运算符逻辑，消费输入流数据，并为其他任务产生输出流数据。真实场景下，可能有数百个这样的任务并行运行在很多的物理机器上。在长时间的运行中，流任务中的任意一个任务在任意时间点都有可能失败。我们如何保证任务的失败能被正确的处理，以使任务能继续的运行下去呢？事实上，我们可能希望我们的流处理器不仅能在任务失败的情况下继续处理数据，还能保证计算结果的正确性以及运算符状态的安全。我们在本小节来讨论这些问题。 什么是任务失败？对于流中的每一个事件，一个处理任务分为以下步骤：（1）接收事件，并将事件存储在本地的缓存中；（2）可能会更新内部状态；（3）产生输出记录。这些步骤都能失败，而系统必须对于在失败的场景下如何处理有清晰的定义。如果任务在第一步就失败了，事件会丢失吗？如果当更新内部状态的时候任务失败，那么内部状态会在任务恢复以后更新吗？在以上这些场景中，输出是确定性的吗？ 在批处理场景下，所有的问题都不是问题。因为我们可以很方便的重新计算。所以不会有事件丢失，状态也可以得到完全恢复。在流的世界里，处理失败不是一个小问题。流系统在失败的情况下需要保证结果的准确性。接下来，我们需要看一下现代流处理系统所提供的一些保障，以及实现这些保障的机制。 结果的保证当我们讨论保证计算的结果时，我们的意思是流处理器的内部状态需要保证一致性。也就是说我们关心的是应用程序的代码在故障恢复以后看到的状态值是什么。要注意保证应用程序状态的一致性并不是保证应用程序的输出结果的一致性。一旦输出结果被持久化，结果的准确性就很难保证了。除非持久化系统支持事务。 AT-MOST-ONCE 当任务故障时，最简单的做法是什么都不干，既不恢复丢失的状态，也不重播丢失的事件。At-most-once语义的含义是最多处理一次事件。换句话说，事件可以被丢弃掉，也没有任何操作来保证结果的准确性。这种类型的保证也叫“没有保证”，因为一个丢弃掉所有事件的系统其实也提供了这样的保障。没有保障听起来是一个糟糕的主意，但如果我们能接受近似的结果，并且希望尽可能低的延迟，那么这样也挺好。 AT-LEAST-ONCE 在大多数的真实应用场景，我们希望不丢失事件。这种类型的保障成为at-least-once，意思是所有的事件都得到了处理，而且一些事件还可能被处理多次。如果结果的正确性仅仅依赖于数据的完整性，那么重复处理是可以接受的。例如，判断一个事件是否在流中出现过，at-least-once这样的保证完全可以正确的实现。在最坏的情况下，我们多次遇到了这个事件。而如果我们要对一个特定的事件进行计数，计算结果就可能是错误的了。 为了保证在at-least-once语义的保证下，计算结果也能正确。我们还需要另一套系统来从数据源或者缓存中重新播放数据。持久化的事件日志系统将会把所有的事件写入到持久化存储中。所以如果任务发生故障，这些数据可以重新播放。还有一种方法可以获得同等的效果，就是使用结果承认机制。这种方法将会把每一条数据都保存在缓存中，直到数据的处理等到所有的任务的承认。一旦得到所有任务的承认，数据将被丢弃。 EXACTLY-ONCE 恰好处理一次是最严格的保证，也是最难实现的。恰好处理一次语义不仅仅意味着没有事件丢失，还意味着针对每一个数据，内部状态仅仅更新一次。本质上，恰好处理一次语义意味着我们的应用程序可以提供准确的结果，就好像从未发生过故障。 提供恰好处理一次语义的保证必须有至少处理一次语义的保证才行，同时还需要数据重放机制。另外，流处理器还需要保证内部状态的一致性。也就是说，在故障恢复以后，流处理器应该知道一个事件有没有在状态中更新。事务更新是达到这个目标的一种方法，但可能引入很大的性能问题。Flink使用了一种轻量级快照机制来保证恰好处理一次语义。 端到端恰好处理一次 目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在Flink流处理器内部保证的。而在真实世界中，流处理应用除了流处理器以外还包含了数据源（例如Kafka）和持久化系统。端到端的一致性保证意味着结果的正确性贯穿了整个流处理应用的始终。每一个组件都保证了它自己的一致性。而整个端到端的一致性级别取决于所有组件中一致性最弱的组件。要注意的是，我们可以通过弱一致性来实现更强的一致性语义。例如，当任务的操作具有幂等性时，比如流的最大值或者最小值的计算。在这种场景下，我们可以通过最少处理一次这样的一致性来实现恰好处理一次这样的最高级别的一致性。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"flink系列01有状态的流式处理简介","slug":"flink系列01有状态的流式处理简介","date":"2020-06-27T15:21:57.000Z","updated":"2020-06-27T15:24:20.800Z","comments":true,"path":"2020/06/27/flink系列01有状态的流式处理简介/","link":"","permalink":"https://masteryang4.github.io/2020/06/27/flink%E7%B3%BB%E5%88%9701%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86%E7%AE%80%E4%BB%8B/","excerpt":"","text":"第一章，有状态的流式处理简介Apache Flink是一个分布式流处理器，具有直观和富有表现力的API，可实现有状态的流处理应用程序。它以容错的方式有效地大规模运行这些应用程序。 Flink于2014年4月加入Apache软件基金会作为孵化项目，并于2015年1月成为顶级项目。从一开始，Flink就拥有一个非常活跃且不断增长的用户和贡献者社区。到目前为止，已有超过五百人为Flink做出贡献，并且它已经发展成为最复杂的开源流处理引擎之一，并得到了广泛采用的证明。 Flink为不同行业和全球的许多公司和企业提供大规模的商业关键应用。 流处理技术在大大小小的公司中越来越受欢迎，因为它为许多已建立的用例（如数据分析，ETL和事务应用程序）提供了卓越的解决方案，同时也促进了新颖的应用程序，软件架构和商机。接下来我们将讨论，为什么有状态流处理变得如此受欢迎并评估其潜力。我们首先回顾传统的数据应用程序架构并指出它们的局限性。接下来，我们介绍基于状态流处理的应用程序设计 与传统方法相比，它具有许多有趣的特征最后，我们简要讨论开源流处理器的发展，并在本地Flink实例上运行流应用程序。 传统数据处理架构数十年来，数据和数据处理在企业中无处不在。多年来，数据的收集和使用一直在增长，公司已经设计并构建了基础架构来管理数据。大多数企业实施的传统架构区分了两种类型的数据处理：事务处理（OLTP）和分析处理（OLAP）。 事务处理公司将各种应用程序用于日常业务活动，例如企业资源规划（ERP）系统，客户关系管理（CRM）软件和基于Web的应用程序。这些系统通常设计有单独的层，用于数据处理（应用程序本身）和数据存储（事务数据库系统），如图1-1所示。 应用程序通常连接到外部服务或直接面向用户，并持续处理传入的事件，如网站上的订单，电子邮件或点击。处理事件时，应用程序将会读取远程数据库的状态，或者通过运行事务来更新它。通常，一个数据库系统可以服务于多个应用程序，它们有时会访问相同的数据库或表。 当应用程序需要扩展时，这样的设计可能会导致问题。由于多个应用程序可能会同时用到相同的数据表示，或者共享相同的基础设施，因此想要更改表的结构或扩展数据库，就需要仔细的规划和大量的工作。克服紧耦合应用程序的最新方法是微服务设计模式。微服务被设计为小型、完备且独立的应用程序。他们遵循UNIX的理念，即“只做一件事并且把它做好”。通过将几个微服务相互连接来构建更复杂的应用程序，这些微服务仅通过标准化接口（例如RESTful HTTP连接）进行通信。由于微服务严格地彼此分离并且仅通过明确定义的接口进行通信，因此每个微服务都可以用不同技术栈来实现，包括编程语言、类库和数据存储。微服务和所有必需的软件和服务通常捆绑在一起并部署在独立的容器中。图1-2描绘了一种微服务架构。 分析处理大量数据存储在公司的各种事务数据库系统中，它们可以为公司业务运营提供宝贵的参考意见。例如，分析订单处理系统的数据，可以获得销量随时间的增长曲线；可以识别延迟发货的原因；还可以预测未来的销量以便提前调整库存。但是，事务数据通常分布在多个数据库中，它们往往汇总起来联合分析时更有价值。而且，数据通常需要转换为通用格式。 所以我们一般不会直接在事务数据库上运行分析查询，而是复制数据到数据仓库。数据仓库是对工作负载进行分析和查询的专用数据存储。为了填充数据仓库，需要将事务数据库系统管理的数据复制过来。将数据复制到数据仓库的过程称为extract-transform-load（ETL）。 ETL过程从事务数据库中提取数据，将其转换为某种通用的结构表示，可能包括验证，值的规范化，编码，重复数据删除（去重）和模式转换，最后将其加载到分析数据库中。 ETL过程可能非常复杂，并且通常需要技术复杂的解决方案来满足性能要求。 ETL过程需要定期运行以保持数据仓库中的数据同步。 将数据导入数据仓库后，可以查询和分析数据。通常，在数据仓库上执行两类查询。第一种类型是定期报告查询，用于计算与业务相关的统计信息，比如收入、用户增长或者输出的产量。这些指标汇总到报告中，帮助管理层评估业务的整体健康状况。第二种类型是即席查询，旨在提供特定问题的答案并支持关键业务决策，例如收集统计在投放商业广告上的花费，和获取的相应收入，以评估营销活动的有效性。两种查询由批处理方式由数据仓库执行，如图1-3所示。 如今，Apache Hadoop生态系统的组件，已经是许多企业IT基础架构中不可或缺的组成部分。现在的做法不是直接将所有数据都插入关系数据库系统，而是将大量数据（如日志文件，社交媒体或Web点击日志）写入Hadoop的分布式文件系统（HDFS）、S3或其他批量数据存储库，如Apache HBase，以较低的成本提供大容量存储容量。驻留在此类存储系统中的数据可以通过SQL-on-Hadoop引擎查询和处理，例如Apache Hive，Apache Drill或Apache Impala。但是，基础结构与传统数据仓库架构基本相同。 有状态的流式处理日常生活中，所有数据都是作为连续的事件流创建的。比如网站或者移动应用中的用户交互动作，订单的提交，服务器日志或传感器测量数据：所有这些都是事件流。实际上，很少有应用场景，能一次性地生成所需要的完整（有限）数据集。实际应用中更多的是无限事件流。有状态的流处理就是用于处理这种无限事件流的应用程序设计模式，在公司的IT基础设施中有广泛的应用场景。在我们讨论其用例之前，我们将简要介绍有状态流处理的工作原理。 如果我们想要无限处理事件流，并且不愿意繁琐地每收到一个事件就记录一次，那这样的应用程序就需要是有状态的，也就是说能够存储和访问中间数据。当应用程序收到一个新事件时，它可以从状态中读取数据，或者向该状态写入数据，总之可以执行任何计算。原则上讲，我们可以在各种不同的地方存储和访问状态，包括程序变量（内存）、本地文件，还有嵌入式或外部数据库。 Apache Flink将应用程序状态，存储在内存或者嵌入式数据库中。由于Flink是一个分布式系统，因此需要保护本地状态以防止在应用程序或计算机故障时数据丢失。 Flink通过定期将应用程序状态的一致性检查点（check point）写入远程且持久的存储，来保证这一点。状态、状态一致性和Flink的检查点将在后面的章节中更详细地讨论，但是，现在，图1-4显示了有状态的流式Flink应用程序。 有状态的流处理应用程序，通常从事件日志中提取输入事件。事件日志就用来存储和分发事件流。事件被写入持久的仅添加（append-only）日志，这意味着无法更改写入事件的顺序。写入事件日志的流，可以被相同或不同的消费者多次读取。由于日志的仅附加（append-only）属性，事件始终以完全相同的顺序发布给所有消费者。现在已有几种事件日志系统，其中Apache Kafka是最受欢迎的，可以作为开源软件使用，或者是云计算提供商提供的集成服务。 在Flink上运行的有状态的流处理应用程序，是很有意思的一件事。在这个架构中，事件日志会按顺序保留输入事件，并且可以按确定的顺序重播它们。如果发生故障，Flink将从先前的检查点（check point）恢复其状态，并重置事件日志上的读取位置，这样就可以恢复整个应用。应用程序将重放（并快进）事件日志中的输入事件，直到它到达流的尾部。此技术一般用于从故障中恢复，但也可用于更新应用程序、修复bug或者修复以前发出的结果，另外还可以用于将应用程序迁移到其他群集，或使用不同的应用程序版本执行A / B测试。 如前所述，有状态的流处理是一种通用且灵活的设计架构，可用于许多不同的场景。在下文中，我们提出了三类通常使用有状态流处理实现的应用程序：（1）事件驱动应用程序，（2）数据管道应用程序，以及（3）数据分析应用程序。 我们将应用程序分类描述，是为了强调有状态流处理适用于多种业务场景；而实际的应用中，往往会具有以上多种情况的特征。 事件驱动应用程序（Event-Driven Applications）事件驱动的应用程序是有状态的流应用程序，它们使用特定的业务逻辑来提取事件流并处理事件。根据业务逻辑，事件驱动的应用程序可以触发诸如发送警报、或电子邮件之类的操作，或者将事件写入向外发送的事件流以供另一个应用程序使用。 事件驱动应用程序的典型场景包括： 实时推荐（例如，在客户浏览零售商网站时推荐产品） 行为模式检测或复杂事件处理（例如，用于信用卡交易中的欺诈检测） 异常检测（例如，检测侵入计算机网络的尝试 事件驱动应用程序是微服务的演变。它们通过事件日志而不是REST调用进行通信，并将应用程序数据保存为本地状态，而不是将其写入外部数据存储区（例如关系数据库或键值数据库）。图1-5显示了由事件驱动的流应用程序组成的服务架构。 图1-5中的应用程序通过事件日志连接。一个应用程序将其输出发送到事件日志通道（kafka），另一个应用程序使用其他应用程序发出的事件。事件日志通道将发送者和接收者分离，并提供异步、非阻塞的事件传输。每个应用程序都可以是有状态的，并且可以本地管理自己的状态而无需访问外部数据存储。应用程序也可以单独处理和扩展。 与事务性应用程序或微服务相比，事件驱动的应用程序具有多种优势。与读写远程数据库相比，本地状态访问提供了非常好的性能。扩展性和容错性都由流处理器来保证，并且以事件日志作为输入源，应用程序的整个输入数据可以可靠地存储，并且可以确定性地重放。此外，Flink可以将应用程序的状态重置为先前的保存点（save point），从而可以在不丢失状态的情况下更新或重新扩展应用程序。 事件驱动的应用程序对运行它们的流处理器有很高的要求，并不是所有流处理器都适合运行事件驱动的应用程序。 API的表现力，以及对状态处理和事件时间支持的程度，决定了可以实现和执行的业务逻辑。这方面取决于流处理器的API，主要看它能提供什么样的状态类型，以及它对事件时间处理的支持程度。此外，精确一次（exactly-once）的状态一致性和扩展应用程序的能力是事件驱动应用程序的基本要求。 Apache Flink符合所有的这些要求，是运行此类应用程序的一个非常好的选择。 数据管道（Data Pipelines）当今的IT架构包括许多不同的数据存储，例如关系型数据库和专用数据库系统、事件日志、分布式文件系统，内存中的缓存和搜索索引。所有这些系统都以不同的格式和数据结构存储数据，为其特定的访问模式提供最佳性能。公司通常将相同的数据存储在多个不同的系统中，以提高数据访问的性能。例如，网上商店中提供的产品的信息，可以存储在交易数据库中，同时也存储在缓存（如redis）和搜索索引（如ES）中。由于数据的这种复制，数据存储必须保持同步。 在不同存储系统中同步数据的传统方法是定期ETL作业。但是，它们不能满足当今许多场景的延迟要求。另一种方法是使用事件日志（event log）来发布更新。更新将写入事件日志并由事件日志分发。日志的消费者获取到更新之后，将更新合并到受影响的数据存储中。根据使用情况，传输的数据可能需要标准化、使用外部数据进行扩展，或者在目标数据存储提取之前进行聚合。 以较低的延迟，来提取、转换和插入数据是有状态流处理应用程序的另一个常见应用场景。这种类型的应用程序称为数据管道（data pipeline）。数据管道必须能够在短时间内处理大量数据。操作数据管道的流处理器还应具有许多源（source）和接收器（sink）的连接器，以便从各种存储系统读取数据并将数据写入各种存储系统。当然，同样地，Flink完成了所有这些功能。 流分析ETL作业定期将数据导入数据存储区，数据的处理是由即席查询（用户自定义查询）或设定好的通常查询来做的。无论架构是基于数据仓库还是基于Hadoop生态系统的组件，这都是批处理。多年来最好的处理方式就是，定期将数据加载到数据分析系统中，但它给分析管道带了的延迟相当大，而且无法避免。 根据设定好的时间间隔，可能需要数小时或数天才能将数据点包含在报告中。我们前面已经提到，数据管道可以实现低延迟的ETL，所以在某种程度上，可以通过使用数据管道将数据导入存储区来减少延迟。但是，即使持续不停地进行ETL操作，在用查询来处理事件之前总会有延迟。虽然这种延迟在过去可能是可以接受的，但是今天的应用程序，往往要求必须能够实时收集数据，并立即对其进行操作（例如，在手机游戏中去适应不断变化的条件，或者在电商网站中提供个性化的用户体验）。 流式分析应用程序不是等待定期触发，而是连续地提取事件流，并且通过纳入最新事件来更新其计算结果，这个过程是低延迟的。这有些类似于数据库中用于更新视图（views）的技术。通常，流应用程序将其结果存储在支持更新的外部数据存储中，例如数据库或键值（key-value）存储。流分析应用程序的实时更新结果可用于驱动监控仪表板（dashboard）应用程序，如图1-6所示。 流分析应用程序最大的优势就是，将每个事件纳入到分析结果所需的时间短得多。除此之外，流分析应用程序还有另一个不太明显的优势。传统的分析管道由几个独立的组件组成，例如ETL过程、存储系统、对于基于Hadoop的环境，还包括用于触发任务（jobs）的数据处理和调度程序。相比之下，如果我们运行一个有状态流应用程序，那么流处理器就会负责所有这些处理步骤，包括事件提取、带有状态维护的连续计算以及更新结果。此外，流处理器可以从故障中恢复，并且具有精确一次（exactly-once）的状态一致性保证，还可以调整应用程序的计算资源。像Flink这样的流处理器还支持事件时间（event-time）处理，这可以保证产生正确和确定的结果，并且能够在很短的时间内处理大量数据。 流分析应用程序通常用于： 监控手机网络的质量分析 移动应用中的用户行为 实时数据的即席分析 虽然我们不在此处介绍，但Flink还提供对流上的分析SQL查询的支持。 开源流处理的演进数据流处理并不是一项新技术。一些最初的研究原型和商业产品可以追溯到20世纪90年代（1990s）。然而，在很大程度上，过去采用的流处理技术是由成熟的开源流处理器驱动的。如今，分布式开源流处理器在不同行业的许多企业中，处理着核心业务应用，比如电商、社交媒体、电信、游戏和银行等。开源软件是这一趋势的主要驱动力，主要原因有两个： 开源流处理软件是大家每一个人都可以评估和使用的产品。 由于许多开源社区的努力，可扩展流处理技术正在迅速成熟和发展 仅仅一个Apache软件基金会就支持了十几个与流处理相关的项目。新的分布式流处理项目不断进入开源阶段，并不断增加新的特性和功能。开源社区不断改进其项目的功能，并正在推动流处理的技术边界。我们将简要介绍一下过去，看看开源流处理的起源和今天的状态。 流处理的历史第一代分布式开源流处理器（2011）专注于具有毫秒延迟的事件处理，并提供了在发生故障时防止事件丢失的保证。这些系统具有相当低级的API，并且对于流应用程序的准确性和结果的一致性，不提供内置支持，因为结果会取决于到达事件的时间和顺序。另外，即使事件没有丢失，也可能不止一次地处理它们。与批处理器相比，第一代开源流处理器牺牲了结果准确性，用来获得更低的延迟。为了让当时的数据处理系统，可以同时提供快速和准确的结果，人们设计了所谓的lambda架构，如图1-7所示。 lambda架构增强了传统的批处理架构，其“快速层”（speed layer）由低延迟的流处理器来支持。数据到达之后由流处理器提取出来，并写入批处理存储。流处理器近乎实时地计算近似结果并将它们写入“快速表”（speed table）。批处理器定期处理批量存储中的数据，将准确的结果写入批处理表，并从速度表中删除相应的不准确结果。应用程序会合并快速表中的近似结果和批处理表中的准确结果，然后消费最终的结果。 lambda架构现在已经不再是最先进的，但仍在许多地方使用。该体系结构的最初目标是改善原始批处理分析体系结构的高延迟。但是，它有一些明显的缺点。首先，它需要对一个应用程序，做出两个语义上等效的逻辑实现，用于两个独立的、具有不同API的处理系统。其次，流处理器计算的结果只是近似的。第三，lambda架构很难建立和维护。 通过在第一代基础上进行改进，下一代分布式开源流处理器（2013）提供了更好的故障保证，并确保在发生故障时，每个输入记录仅对结果产生一次影响（exactly -once）。此外，编程API从相当低级的操作符接口演变为高级API。但是，一些改进（例如更高的吞吐量和更好的故障保证）是以将处理延迟从毫秒增加到几秒为代价的。此外，结果仍然取决于到达事件的时间和顺序。 第三代分布式开源流处理器（2015）解决了结果对到达事件的时间和顺序的依赖性。结合精确一次（exactly-once）的故障语义，这一代系统是第一个具有计算一致性和准确结果的开源流处理器。通过基于实际数据来计算结果（“重演”数据），这些系统还能够以与“实时”数据相同的方式处理历史数据。另一个改进是解决了延迟/吞吐量无法同时保证的问题。先前的流处理器仅能提供高吞吐量或者低延迟（其中之一），而第三代系统能够同时提供这两个特性。这一代的流处理器使得lambda架构过时了。当然，这一代流处理以flink为代表。 除了目前讨论的特性，例如容错、性能和结果准确性之外，流处理器还不断添加新的操作功能，例如高可用性设置，与资源管理器（如YARN或Kubernetes）的紧密集成，以及能够动态扩展流应用程序。其他功能包括：支持升级应用程序代码，或将作业迁移到其他群集或新版本的流处理器，而不会丢失当前状态。 Flink 简介Apache Flink是第三代分布式流处理器，它拥有极富竞争力的功能。它提供准确的大规模流处理，具有高吞吐量和低延迟。特别的是，以下功能使Flink脱颖而出： 事件时间（event-time）和处理时间（processing-tme）语义。即使对于无序事件流，事件时间（event-time）语义仍然能提供一致且准确的结果。而处理时间（processing-time）语义可用于具有极低延迟要求的应用程序。 精确一次（exactly-once）的状态一致性保证。 每秒处理数百万个事件，毫秒级延迟。 Flink应用程序可以扩展为在数千个核（cores）上运行。 分层API，具有不同的权衡表现力和易用性。本书介绍了DataStream API和过程函数（process function），为常见的流处理操作提供原语，如窗口和异步操作，以及精确控制状态和时间的接口。本书不讨论Flink的关系API，SQL和LINQ风格的Table API。 连接到最常用的存储系统，如Apache Kafka，Apache Cassandra，Elasticsearch，JDBC，Kinesis和（分布式）文件系统，如HDFS和S3。 由于其高可用的设置（无单点故障），以及与Kubernetes，YARN和Apache Mesos的紧密集成，再加上从故障中快速恢复和动态扩展任务的能力，Flink能够以极少的停机时间7*24全天候运行流应用程序。 能够更新应用程序代码并将作业（jobs）迁移到不同的Flink集群，而不会丢失应用程序的状态。 详细且可自定义的系统和应用程序指标集合，以提前识别问题并对其做出反应。 最后但同样重要的是，Flink也是一个成熟的批处理器。 除了这些功能之外，Flink还是一个非常易于开发的框架，因为它易于使用的API。嵌入式执行模式，可以在单个JVM进程中启动应用程序和整个Flink系统，这种模式一般用于在IDE中运行和调试Flink作业。在开发和测试Flink应用程序时，此功能非常有用。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"大数据/flink","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flink","slug":"flink","permalink":"https://masteryang4.github.io/tags/flink/"}]},{"title":"mysql的binlog","slug":"mysql的binlog","date":"2020-06-23T11:09:31.000Z","updated":"2020-06-23T11:11:12.598Z","comments":true,"path":"2020/06/23/mysql的binlog/","link":"","permalink":"https://masteryang4.github.io/2020/06/23/mysql%E7%9A%84binlog/","excerpt":"","text":"什么是BinlogMySQL的二进制日志可以说是MySQL最重要的日志了，它记录了所有的DDL和DML(除了数据查询语句)语句，以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。 一般来说开启二进制日志大概会有1%的性能损耗 。二进制有两个最重要的使用场景: 其一：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。 其二：自然就是数据恢复了，通过使用MySQLBinlog工具来使恢复数据。 二进制日志包括两类文件：二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件，二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。 Binlog的开启在MySQL的配置文件(Linux: /etc/my.cnf , Windows:\\my.ini)下,修改配置在[mysqld] 区块设置/添加 Code1log-bin&#x3D;mysql-bin 这个表示binlog日志的前缀是mysql-bin，以后生成的日志文件就是 mysql-bin.123456 的文件后面的数字按顺序生成。每次mysql重启或者到达单个文件大小的阈值时，新生一个文件，按顺序编号。 Binlog的分类设置MySQL Binlog的格式，那就是有三种，分别是STATEMENT,MIXED,ROW。 在配置文件中选择配置 canal无执行引擎，一般row Code1binlog_format&#x3D;row 区别： statement 语句级，binlog会记录每次一执行写操作的语句。 相对row模式节省空间，但是可能产生不一致性，比如1 update tt set create_date=now() 如果用binlog日志进行恢复，由于执行时间不同可能产生的数据就不同。 Code12优点：节省空间缺点：有可能造成数据不一致。 row 行级，binlog会记录每次操作后每行记录的变化。 Code12优点：保持数据的绝对一致性。因为不管sql是什么，引用了什么函数，他只记录执行后的效果。缺点：占用较大空间。 mixed statement的升级版，一定程度上解决了，因为一些情况而造成的statement模式不一致问题 在某些情况下譬如： 当函数中包含 UUID() 时； 包含 AUTO_INCREMENT 字段的表被更新时； 执行 INSERT DELAYED 语句时； 用 UDF 时； 会按照 ROW的方式进行处理 Code12优点：节省空间，同时兼顾了一定的一致性。缺点：还有些极个别情况依旧会造成不一致， 另外statement和mixed对于需要对binlog的监控的情况都不方便。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/categories/SQL/"},{"name":"MySQL","slug":"SQL/MySQL","permalink":"https://masteryang4.github.io/categories/SQL/MySQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"https://masteryang4.github.io/tags/MySQL/"}]},{"title":"spark系列之spark-core","slug":"spark系列之spark-core","date":"2020-06-19T03:04:35.000Z","updated":"2020-06-19T16:45:31.087Z","comments":true,"path":"2020/06/19/spark系列之spark-core/","link":"","permalink":"https://masteryang4.github.io/2020/06/19/spark%E7%B3%BB%E5%88%97%E4%B9%8Bspark-core/","excerpt":"","text":"Spark内核概述Spark内核泛指Spark的核心运行机制，包括Spark核心组件的运行机制、Spark任务调度机制、Spark内存管理机制、Spark核心功能的运行原理等，熟练掌握Spark内核原理，能够帮助我们更好地完成Spark代码设计，并能够帮助我们准确锁定项目运行过程中出现的问题的症结所在。 Spark核心组件Driver Spark驱动器节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责： 1) 将用户程序转化为作业（Job）； 2) 在Executor之间调度任务（Task）； 3) 跟踪Executor的执行情况； 4) 通过UI展示查询运行情况； Executor Spark Executor节点是负责在Spark作业中运行具体任务，任务彼此之间相互独立。Spark 应用启动时，Executor节点被同时启动，并且始终伴随着整个Spark应用的生命周期而存在。如果有Executor节点发生了故障或崩溃，Spark应用也可以继续执行，会将出错节点上的任务调度到其他Executor节点上继续运行。 Executor有两个核心功能： 1) 负责运行组成Spark应用的任务，并将结果返回给驱动器（Driver）； 2) 它们通过自身的块管理器（Block Manager）为用户程序中要求缓存的 RDD 提供内存式存储。RDD是直接缓存在Executor进程内的，因此任务可以在运行时充分利用缓存数据加速运算。 Spark通用运行流程 上图为Spark通用运行流程图，体现了基本的Spark应用程序在部署中的基本提交流程。 这个流程是按照如下的核心步骤进行工作的： 1) 任务提交后，都会先启动Driver程序； 2) 随后Driver向集群管理器注册应用程序； 3) 之后集群管理器根据此任务的配置文件分配Executor并启动； 4) Driver开始执行main函数，Spark查询为懒执行，当执行到Action算子时开始反向推算，根据宽依赖进行Stage的划分，随后每一个Stage对应一个Taskset，Taskset中有多个Task，查找可用资源Executor进行调度； 5) 根据本地化原则，Task会被分发到指定的Executor去执行，在任务执行的过程中，Executor也会不断与Driver进行通信，报告任务运行情况。 Spark部署模式Spark支持多种集群管理器（Cluster Manager），分别为： 1) Standalone：独立模式，Spark原生的简单集群管理器，自带完整的服务，可单独部署到一个集群中，无需依赖任何其他资源管理系统，使用Standalone可以很方便地搭建一个集群； 2) Hadoop YARN：统一的资源管理机制，在上面可以运行多套计算框架，如MR、Storm等。根据Driver在集群中的位置不同，分为yarn client和yarn cluster； 3) Apache Mesos：一个强大的分布式资源管理框架，它允许多种不同的框架部署在其上，包括Yarn。 4) K8S : 容器式部署环境。 实际上，除了上述这些通用的集群管理器外，Spark内部也提供了方便用户测试和学习的本地集群部署模式和Windows环境。由于在实际工厂环境下使用的绝大多数的集群管理器是Hadoop YARN，因此我们关注的重点是Hadoop YARN模式下的Spark集群部署。 Yarn模式运行机制YARN Cluster模式1) 执行脚本提交任务，实际是启动一个SparkSubmit的JVM进程； 2) SparkSubmit类中的main方法反射调用YarnClusterApplication的main方法； 3) YarnClusterApplication创建Yarn客户端，然后向Yarn发送执行指令：bin/java ApplicationMaster； 4) Yarn框架收到指令后会在指定的NM中启动ApplicationMaster； 5) ApplicationMaster启动Driver线程，执行用户的作业； 6) AM向RM注册，申请资源； 7) 获取资源后AM向NM发送指令：bin/java CoarseGrainedExecutorBackend； 8) CoarseGrainedExecutorBackend进程会接收消息，跟Driver通信，注册已经启动的Executor；然后启动计算对象Executor等待接收任务 Driver分配任务并监控任务的执行。 注意：SparkSubmit、ApplicationMaster和CoarseGrainedExecutorBackend是独立的进程；Driver是独立的线程；Executor和YarnClusterApplication是对象。 【9步】 YARN Client模式1) 执行脚本提交任务，实际是启动一个SparkSubmit的JVM进程； 2) SparkSubmit类中的main方法反射调用用户代码的main方法； 3) 启动Driver线程，执行用户的作业，并创建ScheduleBackend； 4) YarnClientSchedulerBackend向RM发送指令：bin/java ExecutorLauncher； 5) Yarn框架收到指令后会在指定的NM中启动ExecutorLauncher（实际上还是调用ApplicationMaster的main方法）； scala1234567object ExecutorLauncher &#123; def main(args: Array[String]): Unit = &#123; ApplicationMaster.main(args) &#125;&#125; 6) AM向RM注册，申请资源； 7) 获取资源后AM向NM发送指令：bin/java CoarseGrainedExecutorBackend； 8) CoarseGrainedExecutorBackend进程会接收消息，跟Driver通信，注册已经启动的Executor；然后启动计算对象Executor等待接收任务 9) Driver分配任务并监控任务的执行。 注意：SparkSubmit、ApplicationMaster和CoarseGrainedExecutorBackend是独立的进程；Executor和Driver是对象。 Standalone模式运行机制Standalone集群有2个重要组成部分，分别是： 1) Master(RM)：是一个进程，主要负责资源的调度和分配，并进行集群的监控等职责； 2) Worker(NM)：是一个进程，一个Worker运行在集群中的一台服务器上，主要负责两个职责，一个是用自己的内存存储RDD的某个或某些partition；另一个是启动其他进程和线程（Executor），对RDD上的partition进行并行的处理和计算。 Standalone Cluster模式在Standalone Cluster模式下，任务提交后，Master会找到一个Worker启动Driver。Driver启动后向Master注册应用程序，Master根据submit脚本的资源需求找到内部资源至少可以启动一个Executor的所有Worker，然后在这些Worker之间分配Executor，Worker上的Executor启动后会向Driver反向注册，所有的Executor注册完成后，Driver开始执行main函数，之后执行到Action算子时，开始划分Stage，每个Stage生成对应的taskSet，之后将Task分发到各个Executor上执行。 Standalone Client模式在Standalone Client模式下，Driver在任务提交的本地机器上运行。Driver启动后向Master注册应用程序，Master根据submit脚本的资源需求找到内部资源至少可以启动一个Executor的所有Worker，然后在这些Worker之间分配Executor，Worker上的Executor启动后会向Driver反向注册，所有的Executor注册完成后，Driver开始执行main函数，之后执行到Action算子时，开始划分Stage，每个Stage生成对应的TaskSet，之后将Task分发到各个Executor上执行。 Spark通讯架构概述Spark中通信框架的发展： Spark早期版本中采用Akka作为内部通信部件。 Spark1.3中引入Netty通信框架，为了解决Shuffle的大数据传输问题使用 Spark1.6中Akka和Netty可以配置使用。Netty完全实现了Akka在Spark中的功能。 Spark2系列中，Spark抛弃Akka，使用Netty。 RPC通信协议原理图： Spark通信终端 Driver: class DriverEndpoint extends ThreadSafeRpcEndpoint Executor class CoarseGrainedExecutorBackend extends ThreadSafeRpcEndpoint spark通讯架构解析 RpcEndpoint：RPC通信终端。Spark针对每个节点（Client/Master/Worker）都称之为一个RPC终端，且都实现RpcEndpoint接口，内部根据不同端点的需求，设计不同的消息和不同的业务处理，如果需要发送（询问）则调用Dispatcher。在Spark中，所有的终端都存在生命周期： Constructor onStart receive* onStop RpcEnv：RPC上下文环境，每个RPC终端运行时依赖的上下文环境称为RpcEnv；在把当前Spark版本中使用的NettyRpcEnv Dispatcher：消息调度（分发）器，针对于RPC终端需要发送远程消息或者从远程RPC接收到的消息，分发至对应的指令收件箱（发件箱）。如果指令接收方是自己则存入收件箱，如果指令接收方不是自己，则放入发件箱； Inbox：指令消息收件箱。一个本地RpcEndpoint对应一个收件箱，Dispatcher在每次向Inbox存入消息时，都将对应EndpointData加入内部ReceiverQueue中，另外Dispatcher创建时会启动一个单独线程进行轮询ReceiverQueue，进行收件箱消息消费； RpcEndpointRef：RpcEndpointRef是对远程RpcEndpoint的一个引用。当我们需要向一个具体的RpcEndpoint发送消息时，一般我们需要获取到该RpcEndpoint的引用，然后通过该应用发送消息。 OutBox：指令消息发件箱。对于当前RpcEndpoint来说，一个目标RpcEndpoint对应一个发件箱，如果向多个目标RpcEndpoint发送信息，则有多个OutBox。当消息放入Outbox后，紧接着通过TransportClient将消息发送出去。消息放入发件箱以及发送过程是在同一个线程中进行； RpcAddress：表示远程的RpcEndpointRef的地址，Host + Port。 TransportClient：Netty通信客户端，一个OutBox对应一个TransportClient，TransportClient不断轮询OutBox，根据OutBox消息的receiver信息，请求对应的远程TransportServer； TransportServer：Netty通信服务端，一个RpcEndpoint对应一个TransportServer，接受远程消息后调用Dispatcher分发消息至对应收发件箱； Spark任务调度机制在生产环境下，Spark集群的部署方式一般为YARN-Cluster模式，之后的内核分析内容中我们默认集群的部署方式为YARN-Cluster模式。在上一章中我们讲解了Spark YARN-Cluster模式下的任务提交流程，但是我们并没有具体说明Driver的工作流程， Driver线程主要是初始化SparkContext对象，准备运行所需的上下文，然后一方面保持与ApplicationMaster的RPC连接，通过ApplicationMaster申请资源，另一方面根据用户业务逻辑开始调度任务，将任务下发到已有的空闲Executor上。 当ResourceManager向ApplicationMaster返回Container资源时，ApplicationMaster就尝试在对应的Container上启动Executor进程，Executor进程起来后，会向Driver反向注册，注册成功后保持与Driver的心跳，同时等待Driver分发任务，当分发的任务执行完毕后，将任务状态上报给Driver。 概述当Driver起来后，Driver则会根据用户程序逻辑准备任务，并根据Executor资源情况逐步分发任务。在详细阐述任务调度前，首先说明下Spark里的几个概念。一个Spark应用程序包括Job、Stage以及Task三个概念： 1) Job是以Action方法为界，遇到一个Action方法则触发一个Job； 2) Stage是Job的子集，以RDD宽依赖(即Shuffle)为界，遇到Shuffle做一次划分； 3) Task是Stage的子集，以并行度(分区数)来衡量，分区数是多少，则有多少个task。 Spark的任务调度总体来说分两路进行，一路是Stage级的调度，一路是Task级的调度。 【重点】总体调度流程如下图所示 Spark RDD通过其Transactions操作，形成了RDD血缘（依赖）关系图，即DAG，最后通过Action的调用，触发Job并调度执行，执行过程中会创建两个调度器：DAGScheduler和TaskScheduler。 DAGScheduler负责Stage级的调度，主要是将job切分成若干Stages，并将每个Stage打包成TaskSet交给TaskScheduler调度。 TaskScheduler负责Task级的调度，将DAGScheduler给过来的TaskSet按照指定的调度策略分发到Executor上执行，调度过程中SchedulerBackend负责提供可用资源，其中SchedulerBackend有多种实现，分别对接不同的资源管理系统。 【扩展】EventQueue：双端（阻塞）队列； ​ BlockingQueue：阻塞队列 Driver初始化SparkContext过程中，会分别初始化DAGScheduler、TaskScheduler、SchedulerBackend以及HeartbeatReceiver，并启动SchedulerBackend以及HeartbeatReceiver。 SchedulerBackend通过ApplicationMaster申请资源，并不断从TaskScheduler中拿到合适的Task分发到Executor执行。HeartbeatReceiver负责接收Executor的心跳信息，监控Executor的存活状况，并通知到TaskScheduler。 Spark Stage级调度Spark的任务调度是从DAG切割开始，主要是由DAGScheduler来完成。当遇到一个Action操作后就会触发一个Job的计算，并交给DAGScheduler来提交，下图是涉及到Job提交的相关方法调用流程图。 1) Job由最终的RDD和Action方法封装而成； 2) SparkContext将Job交给DAGScheduler提交，它会根据RDD的血缘关系构成的DAG进行切分，将一个Job划分为若干Stages，具体划分策略是，由最终的RDD不断通过依赖回溯判断父依赖是否是宽依赖，即以Shuffle为界，划分Stage，窄依赖的RDD之间被划分到同一个Stage中，可以进行pipeline式的计算。划分的Stages分两类，一类叫做ResultStage，为DAG最下游的Stage，由Action方法决定，另一类叫做ShuffleMapStage，为下游Stage准备数据.，下面看一个简单的例子WordCount。 Job由saveAsTextFile触发，该Job由RDD-3和saveAsTextFile方法组成，根据RDD之间的依赖关系从RDD-3开始回溯搜索，直到没有依赖的RDD-0，在回溯搜索过程中，RDD-3依赖RDD-2，并且是宽依赖，所以在RDD-2和RDD-3之间划分Stage，RDD-3被划到最后一个Stage，即ResultStage中，RDD-2依赖RDD-1，RDD-1依赖RDD-0，这些依赖都是窄依赖，所以将RDD-0、RDD-1和RDD-2划分到同一个Stage，形成pipeline操作。即ShuffleMapStage中，实际执行的时候，数据记录会一气呵成地执行RDD-0到RDD-2的转化。不难看出，其本质上是一个深度优先搜索（Depth First Search）算法。 一个Stage是否被提交，需要判断它的父Stage是否执行，只有在父Stage执行完毕才能提交当前Stage，如果一个Stage没有父Stage，那么从该Stage开始提交。Stage提交时会将Task信息（分区信息以及方法等）序列化并被打包成TaskSet交给TaskScheduler，一个Partition对应一个Task，另一方面TaskScheduler会监控Stage的运行状态，只有Executor丢失或者Task由于Fetch失败才需要重新提交失败的Stage以调度运行失败的任务，其他类型的Task失败会在TaskScheduler的调度过程中重试。 相对来说DAGScheduler做的事情较为简单，仅仅是在Stage层面上划分DAG，提交Stage并监控相关状态信息。TaskScheduler则相对较为复杂，下面详细阐述其细节。 Spark Task级调度Spark Task的调度是由TaskScheduler来完成，由前文可知，DAGScheduler将Stage打包到TaskSet交给TaskScheduler，TaskScheduler会将TaskSet封装为TaskSetManager加入到调度队列中，TaskSetManager结构如下图所示。 TaskSetManager负责监控管理同一个Stage中的Tasks，TaskScheduler就是以TaskSetManager为单元来调度任务。 前面也提到，TaskScheduler初始化后会启动SchedulerBackend，它负责跟外界打交道，接收Executor的注册信息，并维护Executor的状态，所以说SchedulerBackend是管“粮食”的，同时它在启动后会定期地去“询问”TaskScheduler有没有任务要运行，也就是说，它会定期地“问”TaskScheduler“我有这么余粮，你要不要啊”，TaskScheduler在SchedulerBackend“问”它的时候，会从调度队列中按照指定的调度策略选择TaskSetManager去调度运行，大致方法调用流程如下图所示： 将TaskSetManager加入rootPool调度池中之后，调用SchedulerBackend的riviveOffers方法给driverEndpoint发送ReviveOffer消息；driverEndpoint收到ReviveOffer消息后调用makeOffers方法，过滤出活跃状态的Executor（这些Executor都是任务启动时反向注册到Driver的Executor），然后将Executor封装成WorkerOffer对象；准备好计算资源（WorkerOffer）后，taskScheduler基于这些资源调用resourceOffer在Executor上分配task。 调度策略TaskScheduler支持两种调度策略，一种是FIFO，也是默认的调度策略，另一种是FAIR。在TaskScheduler初始化过程中会实例化rootPool，表示树的根节点，是Pool类型。 1) FIFO调度策略 如果是采用FIFO调度策略，则直接简单地将TaskSetManager按照先来先到的方式入队，出队时直接拿出最先进队的TaskSetManager，其树结构如下图所示，TaskSetManager保存在一个FIFO队列中。 2) FAIR调度策略 FAIR调度策略的树结构如下图所示： FAIR模式中有一个rootPool和多个子Pool，各个子Pool中存储着所有待分配的TaskSetMagager。 在FAIR模式中，需要先对子Pool进行排序，再对子Pool里面的TaskSetManager进行排序，因为Pool和TaskSetMagager都继承了Schedulable特质，因此使用相同的排序算法。 排序过程的比较是基于Fair-share来比较的，每个要排序的对象包含三个属性: runningTasks值（正在运行的Task数）、minShare值（资源合理利用的值，比如核的利用率）、weight值，比较时会综合考量runningTasks值，minShare值以及weight值。 注意，minShare、weight的值均在公平调度配置文件fairscheduler.xml中被指定，调度池在构建阶段会读取此文件的相关配置。 如果A对象的runningTasks大于它的minShare，B对象的runningTasks小于它的minShare，那么B排在A前面；（runningTasks比minShare小的先执行） 如果A、B对象的runningTasks都小于它们的minShare，那么就比较runningTasks与minShare的比值（minShare使用率），谁小谁排前面；（minShare使用率低的先执行） 如果A、B对象的runningTasks都大于它们的minShare，那么就比较runningTasks与weight的比值（权重使用率），谁小谁排前面。（权重使用率低的先执行） 如果上述比较均相等，则比较名字。 整体上来说就是通过minShare和weight这两个参数控制比较过程，可以做到让minShare使用率和权重使用率少（实际运行task比例较少）的先运行。 FAIR模式排序完成后，所有的TaskSetManager被放入一个ArrayBuffer里，之后依次被取出并发送给Executor执行。 从调度队列中拿到TaskSetManager后，由于TaskSetManager封装了一个Stage的所有Task，并负责管理调度这些Task，那么接下来的工作就是TaskSetManager按照一定的规则一个个取出Task给TaskScheduler，TaskScheduler再交给SchedulerBackend去发到Executor上执行。 本地化调度WHY？【解决任务发给谁的问题】【其实就是计算和数据的相对位置】 【移动数据不如移动计算】 DAGScheduler切割Job，划分Stage, 通过调用submitStage来提交一个Stage对应的tasks，submitStage会调用submitMissingTasks，submitMissingTasks 确定每个需要计算的 task 的preferredLocations，通过调用getPreferrdeLocations()得到partition 的优先位置，由于一个partition对应一个Task，此partition的优先位置就是task的优先位置，对于要提交到TaskScheduler的TaskSet中的每一个Task，该task优先位置与其对应的partition对应的优先位置一致。 从调度队列中拿到TaskSetManager后，那么接下来的工作就是TaskSetManager按照一定的规则一个个取出task给TaskScheduler，TaskScheduler再交给SchedulerBackend去发到Executor上执行。前面也提到，TaskSetManager封装了一个Stage的所有Task，并负责管理调度这些Task。 根据每个Task的优先位置，确定Task的Locality级别，Locality一共有五种，优先级由高到低顺序： 名称 解析 PROCESS_LOCAL 进程本地化，task和数据在同一个Executor中，性能最好。 NODE_LOCAL 节点本地化，task和数据在同一个节点中，但是task和数据不在同一个Executor中，数据需要在进程间进行传输。 RACK_LOCAL 机架本地化，task和数据在同一个机架的两个节点上，数据需要通过网络在节点之间进行传输。 NO_PREF 对于task来说，从哪里获取都一样，没有好坏之分。 ANY task和数据可以在集群的任何地方，而且不在一个机架中，性能最差。 在调度执行时，Spark调度总是会尽量让每个task以最高的本地性级别来启动，当一个task以X本地性级别启动，但是该本地性级别对应的所有节点都没有空闲资源而启动失败，此时并不会马上降低本地性级别启动而是在某个时间长度内再次以X本地性级别来启动该task，若超过限时时间则降级启动，去尝试下一个本地性级别，依次类推。 可以通过调大每个类别的最大容忍延迟时间，在等待阶段对应的Executor可能就会有相应的资源去执行此task，这就在在一定程度上提到了运行性能。 失败重试与黑名单机制除了选择合适的Task调度运行外，还需要监控Task的执行状态，前面也提到，与外部打交道的是SchedulerBackend，Task被提交到Executor启动执行后，Executor会将执行状态上报给SchedulerBackend，SchedulerBackend则告诉TaskScheduler，TaskScheduler找到该Task对应的TaskSetManager，并通知到该TaskSetManager，这样TaskSetManager就知道Task的失败与成功状态，对于失败的Task，会记录它失败的次数，如果失败次数还没有超过最大重试次数，那么就把它放回待调度的Task池子中，否则整个Application失败。 在记录Task失败次数过程中，会记录它上一次失败所在的Executor Id和Host，这样下次再调度这个Task时，会使用黑名单机制，避免它被调度到上一次失败的节点上，起到一定的容错作用。黑名单记录Task上一次失败所在的Executor Id和Host，以及其对应的“拉黑”时间，“拉黑”时间是指这段时间内不要再往这个节点上调度这个Task了。 Spark shuffle解析 shuffle的本质就是落盘，关键是如何落盘，是排序后落盘还是不排序落盘 核心要点ShuffleMapStage与ResultStage 在划分stage时，最后一个stage称为finalStage，它本质上是一个ResultStage对象，前面的所有stage被称为ShuffleMapStage。 ShuffleMapStage的结束伴随着shuffle文件的写磁盘。 ResultStage基本上对应代码中的action算子，即将一个函数应用在RDD的各个partition的数据集上，意味着一个job的运行结束。 HashShuffle解析未优化的HashShuffle这里我们先明确一个假设前提：每个Executor只有1个CPU core，也就是说，无论这个Executor上分配多少个task线程，同一时间都只能执行一个task线程。 如下图中有3个 Reducer，从Task 开始那边各自把自己进行 Hash 计算(分区器：hash/numreduce取模)，分类出3个不同的类别，每个 Task 都分成3种类别的数据，想把不同的数据汇聚然后计算出最终的结果，所以Reducer 会在每个 Task 中把属于自己类别的数据收集过来，汇聚成一个同类别的大集合，每1个 Task 输出3份本地文件，这里有4个 Mapper Tasks，所以总共输出了4个 Tasks x 3个分类文件 = 12个本地小文件。 优化的HashShuffle优化的HashShuffle过程就是启用合并机制，合并机制就是复用buffer，开启合并机制的配置是spark.shuffle.consolidateFiles。该参数默认值为false，将其设置为true即可开启优化机制。通常来说，如果我们使用HashShuffleManager，那么都建议开启这个选项。 这里还是有4个Tasks，数据类别还是分成3种类型，因为Hash算法会根据你的 Key 进行分类，在同一个进程中，无论是有多少过Task，都会把同样的Key放在同一个Buffer里，然后把Buffer中的数据写入以Core数量为单位的本地文件中，(一个Core只有一种类型的Key的数据)，每1个Task所在的进程中，分别写入共同进程中的3份本地文件，这里有4个Mapper Tasks，所以总共输出是 2个Cores x 3个分类文件 = 6个本地小文件。 SortShuffle解析普通SortShuffle在该模式下，数据会先写入一个数据结构，reduceByKey写入Map，一边通过Map局部聚合，一遍写入内存。Join算子写入ArrayList直接写入内存中。然后需要判断是否达到阈值，如果达到就会将内存数据结构的数据写入到磁盘，清空内存数据结构。 在溢写磁盘前，先根据key进行排序，排序过后的数据，会分批写入到磁盘文件中。默认批次为10000条，数据会以每批一万条写入到磁盘文件。写入磁盘文件通过缓冲区溢写的方式，每次溢写都会产生一个磁盘文件，也就是说一个Task过程会产生多个临时文件。 最后在每个Task中，将所有的临时文件合并，这就是merge过程，此过程将所有临时文件读取出来，一次写入到最终文件。意味着一个Task的所有数据都在这一个文件中。同时单独写一份索引文件，标识下游各个Task的数据在文件中的索引，start offset和end offset。 bypass SortShufflebypass运行机制的触发条件如下： 1)不是聚合类的shuffle算子，比如reduceByKey。 2) shuffle reduce task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值，默认为200。 此时task会为每个reduce端的task都创建一个临时磁盘文件，并将数据按key进行hash然后根据key的hash值，将key写入对应的磁盘文件之中。当然，写入磁盘文件时也是先写入内存缓冲，缓冲写满之后再溢写到磁盘文件的。最后，同样会将所有临时磁盘文件都合并成一个磁盘文件，并创建一个单独的索引文件。 该过程的磁盘写机制其实跟未经优化的HashShuffleManager是一模一样的，因为都要创建数量惊人的磁盘文件，只是在最后会做一个磁盘文件的合并而已。因此少量的最终磁盘文件，也让该机制相对未经优化的HashShuffleManager来说，shuffle read的性能会更好。 而该机制与普通SortShuffleManager运行机制的不同在于：不会进行排序。也就是说，启用该机制的最大好处在于，shuffle write过程中，不需要进行数据的排序操作，也就节省掉了这部分的性能开销。 Spark内存管理堆内和堆外内存规划作为一个JVM 进程，Executor 的内存管理建立在JVM的内存管理之上，Spark对 JVM的堆内（On-heap）空间进行了更为详细的分配，以充分利用内存。同时，Spark引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，进一步优化了内存的使用。堆内内存受到JVM统一管理，堆外内存是直接向操作系统进行内存的申请和释放。 堆内内存堆内内存的大小，由Spark应用程序启动时的 –executor-memory 或 spark.executor.memory 参数配置。Executor 内运行的并发任务共享 JVM 堆内内存，这些任务在缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为存储（Storage）内存，而这些任务在执行 Shuffle 时占用的内存被规划为执行（Execution）内存，剩余的部分不做特殊规划，那些Spark内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例，均占用剩余的空间。不同的管理模式下，这三部分占用的空间大小各不相同。Spark对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由JVM完成，Spark只能在申请后和释放前记录这些内存，我们来看其具体流程：申请内存流程如下：Spark 在代码中 new 一个对象实例；JVM 从堆内内存分配空间，创建对象并返回对象引用；Spark 保存该对象的引用，记录该对象占用的内存。释放内存流程如下： Spark记录该对象释放的内存，删除该对象的引用； 等待JVM的垃圾回收机制释放该对象占用的堆内内存。我们知道，JVM 的对象可以以序列化的方式存储，序列化的过程是将对象转换为二进制字节流，本质上可以理解为将非连续空间的链式存储转化为连续空间或块存储，在访问时则需要进行序列化的逆过程——反序列化，将字节流转化为对象，序列化的方式可以节省存储空间，但增加了存储和读取时候的计算开销。对于Spark中序列化的对象，由于是字节流的形式，其占用的内存大小可直接计算，而对于非序列化的对象，其占用的内存是通过周期性地采样近似估算而得，即并不是每次新增的数据项都会计算一次占用的内存大小，这种方法降低了时间开销但是有可能误差较大，导致某一时刻的实际内存有可能远远超出预期。此外，在被Spark标记为释放的对象实例，很有可能在实际上并没有被JVM回收，导致实际可用的内存小于Spark记录的可用内存。所以 Spark并不能准确记录实际可用的堆内内存，从而也就无法完全避免内存溢出（OOM, Out of Memory）的异常。虽然不能精准控制堆内内存的申请和释放，但 Spark 通过对存储内存和执行内存各自独立的规划管理，可以决定是否要在存储内存里缓存新的 RDD，以及是否为新的任务分配执行内存，在一定程度上可以提升内存的利用率，减少异常的出现。 堆外内存为了进一步优化内存的使用以及提高Shuffle时排序的效率，Spark引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据。堆外内存意味着把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。利用JDK Unsafe API（从Spark 2.0开始，在管理堆外的存储内存时不再基于Tachyon，而是与堆外的执行内存一样，基于 JDK Unsafe API 实现），Spark 可以直接操作系统堆外内存，减少了不必要的内存开销，以及频繁的 GC 扫描和回收，提升了处理性能。堆外内存可以被精确地申请和释放（堆外内存之所以能够被精确的申请和释放，是由于内存的申请和释放不再通过JVM机制，而是直接向操作系统申请，JVM对于内存的清理是无法准确指定时间点的，因此无法实现精确的释放），而且序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。在默认情况下堆外内存并不启用，可通过配置spark.memory.offHeap.enabled 参数启用，并由 spark.memory.offHeap.size参数设定堆外空间的大小。除了没有 other 空间，堆外内存与堆内内存的划分方式相同，所有运行中的并发任务共享存储内存和执行内存。 内存空间分配静态内存管理在Spark最初采用的静态内存管理机制下，存储内存、执行内存和其他内存的大小在Spark应用程序运行期间均为固定的，但用户可以应用程序启动前进行配置，堆内内存的分配如图所示： 可以看到，可用的堆内内存的大小需要按照下列方式计算： Code123可用的存储内存 &#x3D; systemMaxMemory * spark.storage.memoryFraction * spark.storage.safety Fraction可用的执行内存 &#x3D; systemMaxMemory * spark.shuffle.memoryFraction * spark.shuffle.safety Fraction 其中systemMaxMemory取决于当前JVM堆内内存的大小，最后可用的执行内存或者存储内存要在此基础上与各自的memoryFraction 参数和safetyFraction 参数相乘得出。上述计算公式中的两个 safetyFraction 参数，其意义在于在逻辑上预留出 1-safetyFraction 这么一块保险区域，降低因实际内存超出当前预设范围而导致 OOM 的风险（上文提到，对于非序列化对象的内存采样估算会产生误差）。值得注意的是，这个预留的保险区域仅仅是一种逻辑上的规划，在具体使用时 Spark 并没有区别对待，和”其它内存”一样交给了 JVM 去管理。 Storage内存和Execution内存都有预留空间，目的是防止OOM，因为Spark堆内内存大小的记录是不准确的，需要留出保险区域。 堆外的空间分配较为简单，只有存储内存和执行内存，如下图所示。可用的执行内存和存储内存占用的空间大小直接由参数spark.memory.storageFraction 决定，由于堆外内存占用的空间可以被精确计算，所以无需再设定保险区域。 静态内存管理机制实现起来较为简单，但如果用户不熟悉Spark的存储机制，或没有根据具体的数据规模和计算任务或做相应的配置，很容易造成”一半海水，一半火焰”的局面，即存储内存和执行内存中的一方剩余大量的空间，而另一方却早早被占满，不得不淘汰或移出旧的内容以存储新的内容。由于新的内存管理机制的出现，这种方式目前已经很少有开发者使用，出于兼容旧版本的应用程序的目的，Spark 仍然保留了它的实现。 统一内存管理Spark1.6 之后引入的统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域，统一内存管理的堆内内存结构如图所示： 统一内存管理的堆外内存结构如下图所示： 其中最重要的优化在于动态占用机制，其规则如下： 1) 设定基本的存储内存和执行内存区域（spark.storage.storageFraction参数），该设定确定了双方各自拥有的空间的范围； 2) 双方的空间都不足时，则存储到硬盘；若己方空间不足而对方空余时，可借用对方的空间;（存储空间不足是指不足以放下一个完整的Block） 3) 执行内存的空间被对方占用后，可让对方将占用的部分转存到硬盘，然后”归还”借用的空间； 4) 存储内存的空间被对方占用后，无法让对方”归还”，因为需要考虑 Shuffle过程中的很多因素，实现起来较为复杂。【为了让execution保证计算准确】 统一内存管理的动态占用机制如图所示： 【重点】 凭借统一内存管理机制，Spark在一定程度上提高了堆内和堆外内存资源的利用率，降低了开发者维护Spark内存的难度，但并不意味着开发者可以高枕无忧。如果存储内存的空间太大或者说缓存的数据过多，反而会导致频繁的全量垃圾回收，降低任务执行时的性能，因为缓存的RDD数据通常都是长期驻留内存的。所以要想充分发挥Spark的性能，需要开发者进一步了解存储内存和执行内存各自的管理方式和实现原理。 存储内存管理RDD的持久化机制 RDD的缓存过程 淘汰与落盘 执行内存管理Shuffle Write Shuffle Read 小结Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374任务的划分：ShuffleMapStage(1) &#x3D;&gt; ShuffleMapTask(N) &#x3D;&gt; shuffle write &#x3D;&gt; shuffle readResultStage(1) &#x3D;&gt; ResultTask(N) &#x3D;&gt; shuffle read任务的封装：Task &#x3D;&gt; TaskSet &#x3D;&gt; TaskSetManager &#x3D;&gt; TaskPool任务调度器(默认使用FIFO)FIFO : 先进先出FAIR : 公平 （runningTasks, minShare, weight）sortWith任务本地化级别：PROCESS_LOCAL : 内存数据的数据处理NODE_LOCAL : yarn集群的方式访问HDFS文件RACK_LOCALAny任务的执行Driver &#x3D;&gt; encode(Task) &#x3D;&gt; RPC &#x3D;&gt; ExecutorBackend &#x3D;&gt; decode(Task) &#x3D;&gt; ExecutorExecutor &#x3D;&gt; ThreadPool &#x3D;&gt; TaskRunner &#x3D;&gt; run &#x3D;&gt; Task.run &#x3D;&gt; XXXTask.runTaskShuffle管理器 :SortShuffleManagerShuffle Writer:1.UnsafeShuffleWriter &#x3D;&gt; SerializedShuffleHandle2.BypassMergeSortShuffleWriter &#x3D;&gt; BypassMergeSortShuffleHandle 没有预聚合功能 &amp; reduce阶段的分区数量 &lt;&#x3D; 阈值（200） 有预聚合功能的算子 : reduceByKey combineByKey, aggregateByKey, foldByKey 没有预聚合功能的算子 : groupByKey sortByKey 实现方式类似于HashShuffle3.SortShuffleWriter &#x3D;&gt; BaseShuffleHandle 写磁盘文件时，首席会按照分区进行排序，然后默认按照key.hashCode排序 排序时，如果超过内存阈值 ：5m预聚合的原理： 在shuffle落盘之前的聚合功能PartitionedAppendOnlyMap &#x3D;&gt; Hashtable &#x3D;&gt; ( (分区ID，Key)， value )不支持预聚合PartitionedPairBuffer &#x3D;&gt; ( (分区ID，Key)， value )Spark内存静态内存管理： 存储内存： val systemMaxMemory &#x3D; conf.getLong(&quot;spark.testing.memory&quot;, Runtime.getRuntime.maxMemory) val memoryFraction &#x3D; conf.getDouble(&quot;spark.storage.memoryFraction&quot;, 0.6) val safetyFraction &#x3D; conf.getDouble(&quot;spark.storage.safetyFraction&quot;, 0.9) (systemMaxMemory * memoryFraction * safetyFraction).toLong 执行内存： val systemMaxMemory &#x3D; conf.getLong(&quot;spark.testing.memory&quot;, Runtime.getRuntime.maxMemory) val memoryFraction &#x3D; conf.getDouble(&quot;spark.shuffle.memoryFraction&quot;, 0.2) val safetyFraction &#x3D; conf.getDouble(&quot;spark.shuffle.safetyFraction&quot;, 0.8) (systemMaxMemory * memoryFraction * safetyFraction).toLong统一内存管理 存储内存： val usableMemory &#x3D; systemMemory - reservedMemory val memoryFraction &#x3D; conf.getDouble(&quot;spark.memory.fraction&quot;, 0.6) maxMemory &#x3D; (usableMemory * memoryFraction).toLong onHeapStorageRegionSize &#x3D; (maxMemory * conf.getDouble(&quot;spark.memory.storageFraction&quot;, 0.5)).toLong, 执行内存：Spark配置：spark.scheduler.mode : 任务调度器，默认为FIFO，可以改为FAIRspark.locality.wait: 本地化等待时间，默认3sspark.shuffle.sort.bypassMergeThreshold : 忽略排序的阈值spark.local.dir : 本地文件存储路径spark.shuffle.spill.batchSize : 溢写磁盘的数据量 10000spark.memory.useLegacyMode : 内存管理兼容模式","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"},{"name":"spark-core","slug":"spark-core","permalink":"https://masteryang4.github.io/tags/spark-core/"}]},{"title":"kafka事务","slug":"kafka事务","date":"2020-06-18T14:24:20.000Z","updated":"2020-06-18T14:25:10.271Z","comments":true,"path":"2020/06/18/kafka事务/","link":"","permalink":"https://masteryang4.github.io/2020/06/18/kafka%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"kafka事务Kafka从【0.11】版本开始引入了事务支持。 事务可以保证Kafka在Exactly Once语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。 Producer事务为了实现跨分区跨会话的事务，需要引入一个全局唯一的Transaction ID，并将Producer获得的PID和Transaction ID绑定。这样当Producer重启后就可以通过正在进行的Transaction ID获得原来的PID。 为了管理Transaction，Kafka引入了一个新的组件Transaction Coordinator。 Producer就是通过和Transaction Coordinator交互获得Transaction ID对应的任务状态。Transaction Coordinator还负责将事务所有写入Kafka的一个内部Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。 Consumer事务上述事务机制主要是从Producer方面考虑，对于Consumer而言，事务的保证就会相对较弱，尤其时无法保证Commit的信息被精确消费。 这是由于Consumer可以通过offset访问任意信息，而且不同的Segment File生命周期不同，同一事务的消息可能会出现重启后被删除的情况。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"大数据/kafka","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"kafka","permalink":"https://masteryang4.github.io/tags/kafka/"}]},{"title":"kafka_exactly_once语义","slug":"kafka-exactly-once语义","date":"2020-06-18T14:22:35.000Z","updated":"2020-06-18T14:28:03.087Z","comments":true,"path":"2020/06/18/kafka-exactly-once语义/","link":"","permalink":"https://masteryang4.github.io/2020/06/18/kafka-exactly-once%E8%AF%AD%E4%B9%89/","excerpt":"","text":"Exactly Once语义 kafka 每个分区内的 Exactly Once 将服务器的ACK级别设置为-1，可以保证Producer到Server之间不会丢失数据，即At Least Once语义。 相对的，将服务器ACK级别设置为0，可以保证生产者每条消息只会被发送一次，即At Most Once语义。 At Least Once可以保证数据不丢失，但是不能保证数据不重复； 相对的，At Least Once可以保证数据不重复，但是不能保证数据不丢失。 但是，对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据既不重复也不丢失，即Exactly Once语义。在0.11版本以前的Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。 【0.11】版本的Kafka，引入了一项重大特性：幂等性。 开启幂等性enable.idempotence=true。 所谓的幂等性就是指Producer不论向Server发送多少次重复数据，Server端都只会持久化一条。幂等性结合At Least Once语义，就构成了Kafka的Exactly Once语义。即： At Least Once + 幂等性 = Exactly Once 要启用幂等性，只需要将Producer的参数中enable.idompotence设置为true即可。 Code123Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带Sequence Number。而Broker端会对&lt;PID, Partition, SeqNumber&gt;做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。 但是PID重启就会变化，同时不同的Partition也具有不同主键， 所以幂等性无法保证跨分区跨会话的Exactly Once。 保证 kafka 数据无重复 ​ 1、幂等性+ack=-1+事务 ​ 2、可以在下一级：SparkStreaming、redis 或者 hive 中 dwd 层去重， ​ 去重的手段：分组、按照id开窗只取第一个值；","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"大数据/kafka","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"kafka","permalink":"https://masteryang4.github.io/tags/kafka/"}]},{"title":"MySQL练习题","slug":"MySQL练习题","date":"2020-06-18T07:13:23.000Z","updated":"2020-06-18T07:15:24.523Z","comments":true,"path":"2020/06/18/MySQL练习题/","link":"","permalink":"https://masteryang4.github.io/2020/06/18/MySQL%E7%BB%83%E4%B9%A0%E9%A2%98/","excerpt":"","text":"MySQL练习题1. 组合两个表需求：编写一个 SQL 查询，对两表进行关联，展示列为：FirstName, LastName, City, State 展示效果： FirstName LastName City State Allen Wang New York City New York Code123456Create table Person (PersonId int, FirstName varchar(255), LastName varchar(255));Create table Address (AddressId int, PersonId int, City varchar(255), State varchar(255));insert into Person (PersonId, LastName, FirstName) values (1, &#39;Wang&#39;, &#39;Allen&#39;);insert into Address (AddressId, PersonId, City, State) values (1, 1, &#39;New York City&#39;, &#39;New York&#39;); 最终SQL: Code1234567891011select p.FirstName, p.LastName, a.City, a.Statefrom Person as p left join Address as a on p.PersonId &#x3D; a.PersonId; 2. 第二高的薪水需求二：编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary）。如果不存在第二高的薪水，那么查询应返回 null。 展示效果： SecondHighestSalary 200 建表语句： Code12345Create table If Not Exists Employee (Id int, Salary int);insert into Employee (Id, Salary) values (1, 100);insert into Employee (Id, Salary) values (2, 200);insert into Employee (Id, Salary) values (3, 300); 最终SQL: Code123456789101112131415161718192021方法一：select ( select DISTINCT Salary from Employee order by Salary DESC limit 1,1 ) as SecondHighestSalary;方法二：select max(Salary) as SecondHighestSalary from Employeewhere Salary &lt; (select max(Salary) from Employee ); 提示：LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。 需求二：编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。 Code123456789101112131415161718192021222324方法一：CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN SET n &#x3D; N-1; RETURN ( SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT n,1 );ENDselect getNthHighestSalary(2) ;方案二：CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN RETURN ( SELECT IF(count&lt;N,NULL,min) FROM (SELECT MIN(Salary) AS min, COUNT(1) AS count FROM (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT N) AS a ) as b );END 3. 分数排名需求：编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。 展示效果： Score Rank 4.00 1 4.00 1 3.85 2 3.65 3 3.65 3 3.50 4 Code12345678Create table If Not Exists Scores (Id int, Score DECIMAL(3,2));insert into Scores (Id, Score) values (1, 3.5);insert into Scores (Id, Score) values (2, 3.65);insert into Scores (Id, Score) values (3, 4.0);insert into Scores (Id, Score) values (4, 3.85);insert into Scores (Id, Score) values (5, 4.0);insert into Scores (Id, Score) values (6, 3.65); 最终SQL: Code123456789101112select a.Score as score , (select count(distinct b.Score) from Scores b where b.Score &gt;&#x3D;a.Score) as rankfrom Scores a order by Score DESC; 4. 连续出现的数字需求：编写一个 SQL 查询，查找所有至少连续出现三次的数字。 展示效果： ConsecutiveNums 1 Code123456789Create table If Not Exists Logs (Id int, Num int);insert into Logs (Id, Num) values (1, 1);insert into Logs (Id, Num) values (2, 1);insert into Logs (Id, Num) values (3, 1);insert into Logs (Id, Num) values (4, 2);insert into Logs (Id, Num) values (5, 1);insert into Logs (Id, Num) values (6, 2);insert into Logs (Id, Num) values (7, 2); 最终SQL: Code12345678SELECT *FROM Logs l1, Logs l2, Logs l3WHERE l1.Id &#x3D; l2.Id - 1 AND l1.Num &#x3D; l2.Num AND l2.Id &#x3D; l3.Id - 1 AND l2.Num &#x3D; l3.Num; 5. 超过经理收入的员工需求：Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。 数据样式： Id Name Salary ManagerId 1 Joe 70000 3 2 Henry 80000 4 3 Sam 60000 null 4 Max 90000 null 展示效果： Employee Joe Code123456create table If Not Exists Employee (Id int, Name varchar(255), Salary int, ManagerId int);insert into Employee (Id, Name, Salary, ManagerId) values (1, &#39;Joe&#39;, 70000, 3);insert into Employee (Id, Name, Salary, ManagerId) values (2, &#39;Henry&#39;, 80000, 4);insert into Employee (Id, Name, Salary, ManagerId) values (3, &#39;Sam&#39;, 60000, null);insert into Employee (Id, Name, Salary, ManagerId) values (4, &#39;Max&#39;, 90000, null); 最终SQL: Code12345678910SELECT a.NAME AS EmployeeFROM Employee AS a JOIN Employee AS bON a.ManagerId &#x3D; b.Id AND a.Salary &gt; b.Salary; 6. 查找重复的邮箱需求：编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 展示效果： Email a@b.com Code12345Create table If Not Exists Person (Id int, Email varchar(255))insert into Person (Id, Email) values (1, &#39;a@b.com&#39;)insert into Person (Id, Email) values (2, &#39;c@d.com&#39;)insert into Person (Id, Email) values (3, &#39;a@b.com&#39;) 最终SQL: Code12345678select Emailfrom Persongroup by Emailhaving count(Email) &gt; 1; 7. 从不订购的客户需求：某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 展示效果： Customers Henry Max Code12345678910Create table If Not Exists Customers (Id int, Name varchar(255));Create table If Not Exists Orders (Id int, CustomerId int);insert into Customers (Id, Name) values (1, &#39;Joe&#39;);insert into Customers (Id, Name) values (2, &#39;Henry&#39;);insert into Customers (Id, Name) values (3, &#39;Sam&#39;);insert into Customers (Id, Name) values (4, &#39;Max&#39;);insert into Orders (Id, CustomerId) values (1, 3);insert into Orders (Id, CustomerId) values (2, 1); 最终SQL: Code1234567891011select customers.name as &#39;Customers&#39;from customerswhere customers.id not in( select customerid from orders ); 8. 部门工资最高的员工需求一：编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。 展示效果： Department Employee Salary IT Jim 90000 IT Max 90000 Sales Henry 80000 Code12345678910111213Create table If Not Exists Employee (Id int, Name varchar(255), Salary int, DepartmentId int);Create table If Not Exists Department (Id int, Name varchar(255));insert into Employee (Id, Name, Salary, DepartmentId) values (1, &#39;Joe&#39;, 70000, 1);insert into Employee (Id, Name, Salary, DepartmentId) values (2, &#39;Jim&#39;, 90000, 1);insert into Employee (Id, Name, Salary, DepartmentId) values (3, &#39;Henry&#39;, 80000, 2);insert into Employee (Id, Name, Salary, DepartmentId) values (4, &#39;Sam&#39;, 60000, 2);insert into Employee (Id, Name, Salary, DepartmentId) values (5, &#39;Max&#39;, 90000, 1);insert into Employee (Id, Name, Salary, DepartmentId) values (6, &#39;Randy&#39;, 85000, 1);insert into Employee (Id, Name, Salary, DepartmentId) values (7, &#39;Will&#39;, 70000, 1);insert into Department (Id, Name) values (1, &#39;IT&#39;);insert into Department (Id, Name) values (2, &#39;Sales&#39;); 最终SQL: Code12345678910111213141516SELECT Department.name AS &#39;Department&#39;, Employee.name AS &#39;Employee&#39;, SalaryFROM Employee JOIN Department ON Employee.DepartmentId &#x3D; Department.IdWHERE (Employee.DepartmentId , Salary) IN ( SELECT DepartmentId, MAX(Salary) FROM Employee GROUP BY DepartmentId ); 需求二：编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。 展示效果： Department Employee Salary IT Max 90000 IT Randy 85000 IT Joe 85000 IT Will 70000 Sales Henry 80000 Sales Sam 60000 最终SQL: Code123456789101112131415SELECT d.Name AS &#39;Department&#39;, e1.Name AS &#39;Employee&#39;, e1.SalaryFROM Employee e1 JOIN Department d ON e1.DepartmentId &#x3D; d.IdWHERE 3 &gt; (SELECT COUNT(DISTINCT e2.Salary) FROM Employee e2 WHERE e2.Salary &gt; e1.Salary AND e1.DepartmentId &#x3D; e2.DepartmentId ); 9. 删除重复的电子邮箱需求：编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。 展示效果： Id Email 1 john@example.com 2 bob@example.com Code12345Create table If Not Exists Person (Id int, email varchar(255));insert into Person (Id, email) values (1, &#39;john@example.com&#39;);insert into Person (Id, email) values (2, &#39;bob@example.com&#39;);insert into Person (Id, email) values (3, &#39;john@example.com&#39;); 最终SQL: Code1234567DELETE p1 FROM Person p1, Person p2WHERE p1.Email &#x3D; p2.Email AND p1.Id &gt; p2.Id; 10. 上升的温度需求：编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。 Id 2 4 Code123456Create table If Not Exists Weather (Id int, RecordDate date, Temperature int);insert into Weather (Id, RecordDate, Temperature) values (1, &#39;2015-01-01&#39;, 10);insert into Weather (Id, RecordDate, Temperature) values (2, &#39;2015-01-02&#39;, 25);insert into Weather (Id, RecordDate, Temperature) values (3, &#39;2015-01-03&#39;, 20);insert into Weather (Id, RecordDate, Temperature) values (4, &#39;2015-01-04&#39;, 30); 最终SQL: Code123456789SELECT weather.id AS &#39;Id&#39;FROM weatherJOIN weather w ON DATEDIFF(weather.RecordDate, w.RecordDate) &#x3D; 1AND weather.Temperature &gt; w.Temperature; 11. 行程和用户需求：写一段 SQL 语句查出 2019年10月1日 至 2019年10月3日 期间非禁止用户的取消率。基于上表，你的 SQL 语句应返回如下结果，取消率（Cancellation Rate）保留两位小数。 取消率的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数) Trips表：所有出租车的行程信息。每段行程有唯一键 Id，Client_Id 和 Driver_Id 是 Users 表中 Users_Id 的外键。Status 是枚举类型，枚举成员为 (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’)。 Id Client_Id Driver_Id City_Id Status Request_at 1 1 10 1 completed 2019-10-01 2 2 11 1 cancelled_by_driver 2019-10-01 3 3 12 6 completed 2019-10-01 4 4 13 6 cancelled_by_client 2019-10-01 5 1 10 1 completed 2019-10-02 6 2 11 6 completed 2019-10-02 7 3 12 6 completed 2019-10-02 8 2 12 12 completed 2019-10-03 9 3 10 12 completed 2019-10-03 10 4 13 12 cancelled_by_driver 2019-10-03 Users 表存所有用户。每个用户有唯一键 Users_Id。Banned 表示这个用户是否被禁止，Role 则是一个表示（‘client’, ‘driver’, ‘partner’）的枚举类型。 Users_Id Banned Cancellation Rate 1 No client 2 Yes client 3 No client 4 No client 10 No driver 11 No driver 12 No driver 13 No driver 展示效果： Day Cancellation Rate 2019-10-01 0.33 2019-10-02 0.00 2019-10-03 0.50 Code1234567891011121314151617181920212223Create table If Not Exists Trips (Id int, Client_Id int, Driver_Id int, City_Id int, Status ENUM(&#39;completed&#39;, &#39;cancelled_by_driver&#39;, &#39;cancelled_by_client&#39;), Request_at varchar(50));Create table If Not Exists Users (Users_Id int, Banned varchar(50), Role ENUM(&#39;client&#39;, &#39;driver&#39;, &#39;partner&#39;));insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (1, 1, 10, 1, &#39;completed&#39;, &#39;2019-10-01&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (2, 2, 11, 1, &#39;cancelled_by_driver&#39;, &#39;2019-10-01&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (3, 3, 12, 6, &#39;completed&#39;, &#39;2019-10-01&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (4, 4, 13, 6, &#39;cancelled_by_client&#39;, &#39;2019-10-01&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (5, 1, 10, 1, &#39;completed&#39;, &#39;2019-10-02&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (6, 2, 11, 6, &#39;completed&#39;, &#39;2019-10-02&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (7, 3, 12, 6, &#39;completed&#39;, &#39;2019-10-02&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (8, 2, 12, 12, &#39;completed&#39;, &#39;2019-10-03&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (9, 3, 10, 12, &#39;completed&#39;, &#39;2019-10-03&#39;);insert into Trips (Id, Client_Id, Driver_Id, City_Id, Status, Request_at) values (10, 4, 13, 12, &#39;cancelled_by_driver&#39;, &#39;2019-10-03&#39;);insert into Users (Users_Id, Banned, Role) values (1, &#39;No&#39;, &#39;client&#39;);insert into Users (Users_Id, Banned, Role) values (2, &#39;Yes&#39;, &#39;client&#39;);insert into Users (Users_Id, Banned, Role) values (3, &#39;No&#39;, &#39;client&#39;);insert into Users (Users_Id, Banned, Role) values (4, &#39;No&#39;, &#39;client&#39;);insert into Users (Users_Id, Banned, Role) values (10, &#39;No&#39;, &#39;driver&#39;);insert into Users (Users_Id, Banned, Role) values (11, &#39;No&#39;, &#39;driver&#39;);insert into Users (Users_Id, Banned, Role) values (12, &#39;No&#39;, &#39;driver&#39;);insert into Users (Users_Id, Banned, Role) values (13, &#39;No&#39;, &#39;driver&#39;); 最终SQL: Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687方法一：SELECT T.request_at AS &#96;Day&#96;, ROUND( SUM(IF(T.STATUS &#x3D; &#39;completed&#39;,0,1))&#x2F; COUNT(T.STATUS), 2 ) AS &#96;Cancellation Rate&#96;FROM Trips AS TJOIN Users AS U1 ON T.client_id &#x3D; U1.users_id AND U1.banned &#x3D;&#39;No&#39;JOIN Users AS U2 ON T.driver_id &#x3D; U2.users_id AND U2.banned &#x3D;&#39;No&#39;WHERE T.request_at BETWEEN &#39;2019-10-01&#39; AND &#39;2019-10-03&#39;GROUP BY T.request_at;方法二：SELECT T.request_at AS &#96;Day&#96;, ROUND( SUM(IF(T.STATUS &#x3D; &#39;completed&#39;,0,1))&#x2F; COUNT(T.STATUS), 2 ) AS &#96;Cancellation Rate&#96;FROM trips AS T LEFT JOIN ( SELECT users_id FROM users WHERE banned &#x3D; &#39;Yes&#39; ) AS A ON T.Client_Id &#x3D; A.users_idLEFT JOIN ( SELECT users_id FROM users WHERE banned &#x3D; &#39;Yes&#39; ) AS A1ON T.Driver_Id &#x3D; A1.users_idWHERE A.users_id IS NULL AND A1.users_id IS NULL AND T.request_at BETWEEN &#39;2019-10-01&#39; AND &#39;2019-10-03&#39;GROUP BY T.request_at;方法三：SELECT T.request_at AS &#96;Day&#96;, ROUND( SUM(IF(T.STATUS &#x3D; &#39;completed&#39;,0,1))&#x2F; COUNT(T.STATUS), 2 ) AS &#96;Cancellation Rate&#96;FROM trips AS TWHERE T.Client_Id NOT IN ( SELECT users_id FROM users WHERE banned &#x3D; &#39;Yes&#39; )AND T.Driver_Id NOT IN ( SELECT users_id FROM users WHERE banned &#x3D; &#39;Yes&#39; )AND T.request_at BETWEEN &#39;2019-10-01&#39; AND &#39;2019-10-03&#39;; 12. 游戏玩法分析需求一：写一条 SQL 查询语句获取每位玩家 第一次登陆平台的日期。 Activity表：显示了某些游戏的玩家的活动情况。 player_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-05-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 展示效果： player_id first_login 1 2016-03-01 2 2017-06-25 3 2016-03-02 Code1234567Create table If Not Exists Activity (player_id int, device_id int, event_date date, games_played int);insert into Activity (player_id, device_id, event_date, games_played) values (1, 2, &#39;2016-03-01&#39;, 5);insert into Activity (player_id, device_id, event_date, games_played) values (1, 2, &#39;2016-05-02&#39;, 6);insert into Activity (player_id, device_id, event_date, games_played) values (2, 3, &#39;2017-06-25&#39;, 1);insert into Activity (player_id, device_id, event_date, games_played) values (3, 1, &#39;2016-03-02&#39;, 0);insert into Activity (player_id, device_id, event_date, games_played) values (3, 4, &#39;2018-07-03&#39;, 5); 最终SQL: Code1234567select player_id, min(event_date) as first_login from Activity group by player_id; 需求二：描述每一个玩家首次登陆的设备名称 player_id device_id 1 2 2 3 3 1 最终SQL: Code123456789101112131415161718select player_id, device_id from (select * from Activity where (player_id,event_date) in (select player_id, device_id min(event_date) from Activity group by player_id ) ) as t; 需求三：编写一个 SQL 查询，同时报告每组玩家和日期，以及玩家到目前为止玩了多少游戏。也就是说，在此日期之前玩家所玩的游戏总数。详细情况请查看示例。 player_id event_date games_played_so_far 1 2016-03-01 5 1 2016-05-02 11 2 2017-06-25 1 3 2016-03-02 0 3 2018-07-03 5 提示：对于 ID 为 3 的玩家，2018-07-03 共玩了 0+5=5 个游戏。 最终SQL: Code1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F;方法一SELECT C.player_id,C.event_date,C.games_played_so_farFROM ( SELECT A.player_id, A.event_date, @sum_cnt:&#x3D; if(A.player_id &#x3D; @pre_id AND A.event_date !&#x3D; @pre_date, @sum_cnt + A.games_played, A.games_played ) AS &#96;games_played_so_far&#96;, @pre_id:&#x3D;A.player_id AS &#96;player_ids&#96;, @pre_date:&#x3D;A.event_date AS &#96;event_dates&#96; FROM activity AS A, (SELECT @pre_id:&#x3D;NULL,@pre_date:&#x3D;NULL,@sum_cnt:&#x3D;0) AS B order BY A.player_id,A.event_date) AS C&#x2F;&#x2F;方法二SELECT B.player_id, B.event_date, SUM(A.games_played) AS &#96;games_played_so_far&#96;FROM Activity AS AJOIN Activity AS B ON A.player_id &#x3D; B.player_id AND A.event_date &lt;&#x3D; B.event_dateGROUP BY B.player_id,B.event_date; 需求四：编写一个 SQL 查询，报告在首次登录的第二天再次登录的玩家的百分比，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。 fraction 0.00 提示：对于 ID 为 1 的玩家，2016-05-02 共玩了 5+6=11 个游戏.对于 ID 为 3 的玩家，2018-07-03 共玩了 0+5=5 个游戏。 最终SQL: Code123456789101112131415161718select round( sum(case when datediff(a.event_date,b.first_date)&#x3D;1 then 1 else 0 end) &#x2F; (select count(distinct(player_id)) from activity) ,2 ) as fractionfrom activity a, (select player_id, min(event_date) first_date from activity group by player_id ) bwhere a.player_id&#x3D;b.player_id; 需求五：编写一个 SQL 查询，报告每个安装日期、当天安装游戏的玩家数量和第一天的保留时间。 install_dt installs Day1_retention 2016-03-01 2 0.50 2017-06-25 1 0.00 提示：玩家 1 和 3 在 2016-03-01 安装了游戏，但只有玩家 1 在 2016-03-02 重新登录，所以 2016-03-01 的第一天保留时间是 1/2=0.50玩家 2 在 2017-06-25 安装了游戏，但在 2017-06-26 没有重新登录，因此 2017-06-25 的第一天保留为 0/1=0.00 最终SQL: Code12345678910111213141516171819202122232425262728293031323334353637383940#方法一SELECT A.install_date, COUNT(A.player_id) AS &#96;installs&#96;, COUNT(AA.player_id) AS &#96;return_cnt&#96;FROM (SELECT player_id, MIN(event_date) AS &#96;install_date&#96; FROM Activity GROUP BY player_id ) AS Aleft JOIN Activity AS AA ON AA.event_date &#x3D; DATE_ADD(A.install_date,INTERVAL 1 DAY) AND AA.player_id &#x3D; A.player_idGROUP BY A.install_date;#方法二SELECT A.event_date AS &#96;install_dt&#96;, COUNT(A.player_id) AS &#96;installs&#96;, round(COUNT(C.player_id)&#x2F;COUNT(A.player_id),2) AS &#96;Day1_retention&#96;FROM Activity AS A left JOIN Activity AS BON A.player_id &#x3D; B.player_id AND A.event_date &gt; B.event_dateleft JOIN Activity AS CON A.player_id &#x3D; C.player_id AND C.event_date &#x3D; DATE_ADD(A.event_date,INTERVAL 1 DAY)WHERE B.event_date IS NULLGROUP BY A.event_date; 13. 员工薪水中位数需求：请编写SQL查询来查找每个公司的薪水中位数。挑战点：你是否可以在不使用任何内置的SQL函数的情况下解决此问题。 展示效果： Id Company Salary 5 A 451 6 A 513 12 B 234 9 B 1154 14 C 2645 Code12345678910111213141516171819Create table If Not Exists Employee (Id int, Company varchar(255), Salary int);insert into Employee (Id, Company, Salary) values (1, &#39;A&#39;, 2341);insert into Employee (Id, Company, Salary) values (2, &#39;A&#39;, 341);insert into Employee (Id, Company, Salary) values (3, &#39;A&#39;, 15);insert into Employee (Id, Company, Salary) values (4, &#39;A&#39;, 15314);insert into Employee (Id, Company, Salary) values (5, &#39;A&#39;, 451);insert into Employee (Id, Company, Salary) values (6, &#39;A&#39;, 513);insert into Employee (Id, Company, Salary) values (7, &#39;B&#39;, 15);insert into Employee (Id, Company, Salary) values (8, &#39;B&#39;, 13);insert into Employee (Id, Company, Salary) values (9, &#39;B&#39;, 1154);insert into Employee (Id, Company, Salary) values (10, &#39;B&#39;, 1345);insert into Employee (Id, Company, Salary) values (11, &#39;B&#39;, 1221);insert into Employee (Id, Company, Salary) values (12, &#39;B&#39;, 234);insert into Employee (Id, Company, Salary) values (13, &#39;C&#39;, 2345);insert into Employee (Id, Company, Salary) values (14, &#39;C&#39;, 2645);insert into Employee (Id, Company, Salary) values (15, &#39;C&#39;, 2645);insert into Employee (Id, Company, Salary) values (16, &#39;C&#39;, 2652);insert into Employee (Id, Company, Salary) values (17, &#39;C&#39;, 65); 最终SQL: Code1234567891011121314151617181920212223242526272829select b.id, b.company, b.salaryfrom (select id, company, salary, case @com when company then @rk:&#x3D;@rk+1 else @rk:&#x3D;1 end rk, @com:&#x3D;company from employee, (select @rk:&#x3D;0, @com:&#x3D;&#39;&#39;) a order by company,salary ) bleft join (select company, count(1)&#x2F;2 cnt from employee group by company ) con b.company&#x3D;c.companywhere b.rk in (cnt+0.5,cnt+1,cnt); 14. 至少有5名直接下属的经理需求：Employee 表，请编写一个SQL查询来查找至少有5名直接下属的经理。 展示效果： Name John Code12345678Create table If Not Exists Employee (Id int, Name varchar(255), Department varchar(255), ManagerId int);insert into Employee (Id, Name, Department, ManagerId) values (101, &#39;John&#39;, &#39;A&#39;, null);insert into Employee (Id, Name, Department, ManagerId) values (102, &#39;Dan&#39;, &#39;A&#39;, 101);insert into Employee (Id, Name, Department, ManagerId) values (103, &#39;James&#39;, &#39;A&#39;, 101);insert into Employee (Id, Name, Department, ManagerId) values (104, &#39;Amy&#39;, &#39;A&#39;, 101);insert into Employee (Id, Name, Department, ManagerId) values (105, &#39;Anne&#39;, &#39;A&#39;, 101);insert into Employee (Id, Name, Department, ManagerId) values (106, &#39;Ron&#39;, &#39;B&#39;, 101); 最终SQL: Code12345678910111213141516SELECT NameFROM Employee AS t1 JOIN (SELECT ManagerId FROM Employee GROUP BY ManagerId HAVING COUNT(ManagerId) &gt;&#x3D; 5 ) AS t2ON t1.Id &#x3D; t2.ManagerId; 15. 给定数字的频率查询中位数需求：编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：FirstName, LastName, City, State 展示效果： median 0.0000 Code123456Create table If Not Exists Numbers (Number int, Frequency int);insert into Numbers (Number, Frequency) values (0, 7);insert into Numbers (Number, Frequency) values (1, 1);insert into Numbers (Number, Frequency) values (2, 3);insert into Numbers (Number, Frequency) values (3, 1); 最终SQL: Code1234567891011121314151617181920212223242526select avg(t.number) as medianfrom (select n1.number, n1.frequency, (select sum(frequency) from numbers n2 where n2.number&lt;&#x3D;n1.number ) as asc_frequency, (select sum(frequency) from numbers n3 where n3.number&gt;&#x3D;n1.number ) as desc_frequency from numbers n1 ) twhere t.asc_frequency&gt;&#x3D; (select sum(frequency) from numbers)&#x2F;2 and t.desc_frequency&gt;&#x3D; (select sum(frequency) from numbers)&#x2F;2; 16. 当选者需求：请编写 sql 语句来找到当选者（CandidateId）的名字 展示效果： Name B Code1234567891011121314Create table If Not Exists Candidate (id int, Name varchar(255));Create table If Not Exists Vote (id int, CandidateId int);insert into Candidate (id, Name) values (1, &#39;A&#39;);insert into Candidate (id, Name) values (2, &#39;B&#39;);insert into Candidate (id, Name) values (3, &#39;C&#39;);insert into Candidate (id, Name) values (4, &#39;D&#39;);insert into Candidate (id, Name) values (5, &#39;E&#39;);insert into Vote (id, CandidateId) values (1, 2);insert into Vote (id, CandidateId) values (2, 44);insert into Vote (id, CandidateId) values (3, 3);insert into Vote (id, CandidateId) values (4, 2);insert into Vote (id, CandidateId) values (5, 5); 最终SQL: Code1234567891011121314151617SELECT name AS &#39;Name&#39;FROM CandidateJOIN (SELECT Candidateid FROM Vote GROUP BY Candidateid ORDER BY COUNT(*) DESC LIMIT 1 ) AS winnerWHERE Candidate.id &#x3D; winner.Candidateid; 17. 员工奖金需求：选出所有 bonus &lt; 1000 的员工的 name 及其 bonus。 展示效果： name bonus John null Dan 500 Brad null Code12345678910Create table If Not Exists Employee (EmpId int, Name varchar(255), Supervisor int, Salary int);Create table If Not Exists Bonus (EmpId int, Bonus int);insert into Employee (EmpId, Name, Supervisor, Salary) values (3, &#39;Brad&#39;, null, 4000);insert into Employee (EmpId, Name, Supervisor, Salary) values (1, &#39;John&#39;, 3, 1000);insert into Employee (EmpId, Name, Supervisor, Salary) values (2, &#39;Dan&#39;, 3, 2000);insert into Employee (EmpId, Name, Supervisor, Salary) values (4, &#39;Thomas&#39;, 3, 4000);insert into Bonus (EmpId, Bonus) values (2, 500);insert into Bonus (EmpId, Bonus) values (4, 2000); 最终SQL: Code1234567891011SELECT Employee.name, Bonus.bonusFROM EmployeeLEFT JOIN BonusON Employee.empid &#x3D; Bonus.empidWHERE bonus &lt; 1000 OR bonus IS NULL; 18. 最高回答率需求：请编写SQL查询来找到具有最高回答率的问题。 展示效果： survey_log 285 Code123456Create table If Not Exists survey_log (uid int, action varchar(255), question_id int, answer_id int, q_num int, timestamp int);insert into survey_log (uid, action, question_id, answer_id, q_num, timestamp) values (5, &#39;show&#39;, 285, null, 1, 123);insert into survey_log (uid, action, question_id, answer_id, q_num, timestamp) values (5, &#39;answer&#39;, 285, 124124, 1, &#39;124&#39;);insert into survey_log (uid, action, question_id, answer_id, q_num, timestamp) values (5, &#39;show&#39;, 369, null, 2, 125);insert into survey_log (uid, action, question_id, answer_id, q_num, timestamp) values (5, &#39;skip&#39;, 369, null, 2, 126); 最终SQL: Code123456789101112131415161718192021222324252627#方法一SELECT question_id as survey_logFROM (SELECT question_id, SUM(case when action&#x3D;&quot;answer&quot; THEN 1 ELSE 0 END) as num_answer, SUM(case when action&#x3D;&quot;show&quot; THEN 1 ELSE 0 END) as num_show FROM survey_log GROUP BY question_id ) as tblORDER BY (num_answer &#x2F; num_show) DESCLIMIT 1;#方法二SELECT question_id AS &#39;survey_log&#39;FROM survey_logGROUP BY question_idORDER BY COUNT(answer_id) &#x2F; COUNT(IF(action &#x3D; &#39;show&#39;, 1, 0)) DESCLIMIT 1; 19. 员工累计薪水需求：查询一个员工三个月内的累计薪水，但是不包括最近一个月的薪水。 展示效果： Id Month Salary 1 3 90 1 2 50 1 1 20 2 1 20 3 3 100 3 2 40 Code1234567891011Create table If Not Exists Employee (Id int, Month int, Salary int);insert into Employee (Id, Month, Salary) values (1, 1, 20);insert into Employee (Id, Month, Salary) values (2, 1, 20);insert into Employee (Id, Month, Salary) values (1, 2, 30);insert into Employee (Id, Month, Salary) values (2, 2, 30);insert into Employee (Id, Month, Salary) values (3, 2, 40);insert into Employee (Id, Month, Salary) values (1, 3, 40);insert into Employee (Id, Month, Salary) values (3, 3, 60);insert into Employee (Id, Month, Salary) values (1, 4, 60);insert into Employee (Id, Month, Salary) values (3, 4, 70); 最终SQL: Code123456789101112131415161718192021222324252627SELECT E1.id, E1.month, (IFNULL(E1.salary, 0) + IFNULL(E2.salary, 0) + IFNULL(E3.salary, 0)) AS SalaryFROM (SELECT id, MAX(month) AS month FROM Employee GROUP BY id HAVING COUNT(*) &gt; 1) AS maxmonth LEFT JOIN Employee E1 ON (maxmonth.id &#x3D; E1.id AND maxmonth.month &gt; E1.month) LEFT JOIN Employee E2 ON (E2.id &#x3D; E1.id AND E2.month &#x3D; E1.month - 1) LEFT JOIN Employee E3 ON (E3.id &#x3D; E1.id AND E3.month &#x3D; E1.month - 2)ORDER BY id ASC , month DESC; 20. 统计各专业人数需求：查询 department 表中每个专业的学生人数 （即使没有学生的专业也需列出）。 展示效果： dept_name student_number Engineering 2 Science 1 Law 0 Code12345678910CREATE TABLE IF NOT EXISTS student (student_id INT,student_name VARCHAR(45), gender VARCHAR(6), dept_id INT);CREATE TABLE IF NOT EXISTS department (dept_id INT, dept_name VARCHAR(255));insert into student (student_id, student_name, gender, dept_id) values (1, &#39;Jack&#39;, &#39;M&#39;, 1);insert into student (student_id, student_name, gender, dept_id) values (2, &#39;Jane&#39;, &#39;F&#39;, 1);insert into student (student_id, student_name, gender, dept_id) values (3, &#39;Mark&#39;, &#39;M&#39;, 2);insert into department (dept_id, dept_name) values (1, &#39;Engineering&#39;);insert into department (dept_id, dept_name) values (2, &#39;Science&#39;);insert into department (dept_id, dept_name) values (3, &#39;Law&#39;); 最终SQL: Code1234567891011121314SELECT dept_name, COUNT(student_id) AS student_numberFROM departmentLEFT OUTER JOIN student ON department.dept_id &#x3D; student.dept_idGROUP BY department.dept_nameORDER BY student_number DESC, department.dept_name; 21. 寻找用户推荐人需求：写一个查询语句，返回一个编号列表，列表中编号的推荐人的编号都 不是 2 展示效果： name Will Jane Bill Zack Code12345678CREATE TABLE IF NOT EXISTS customer (id INT,name VARCHAR(25),referee_id INT);insert into customer (id, name, referee_id) values (1, &#39;Will&#39;, null);insert into customer (id, name, referee_id) values (2, &#39;Jane&#39;, null);insert into customer (id, name, referee_id) values (3, &#39;Alex&#39;, 2);insert into customer (id, name, referee_id) values (4, &#39;Bill&#39;, null);insert into customer (id, name, referee_id) values (5, &#39;Zack&#39;, 1);insert into customer (id, name, referee_id) values (6, &#39;Mark&#39;, 2); 最终SQL: Code123456SELECT nameFROM customerWHERE referee_id &lt;&gt; 2 OR referee_id IS NULL; 22. 2016年的投资需求：写一个查询语句，将 2016 年 (TIV_2016) 所有成功投资的金额加起来，保留 2 位小数。 展示效果： TIV_2016 45.00 Code123456CREATE TABLE IF NOT EXISTS insurance (PID INTEGER(11), TIV_2015 NUMERIC(15,2), TIV_2016 NUMERIC(15,2), LAT NUMERIC(5,2), LON NUMERIC(5,2) );insert into insurance (PID, TIV_2015, TIV_2016, LAT, LON) values (1, 10, 5, 10, 10);insert into insurance (PID, TIV_2015, TIV_2016, LAT, LON) values (2, 20, 20, 20, 20);insert into insurance (PID, TIV_2015, TIV_2016, LAT, LON) values (3, 10, 30, 20, 20);insert into insurance (PID, TIV_2015, TIV_2016, LAT, LON) values (4, 10, 40, 40, 40); 提示： 对于一个投保人，他在 2016 年成功投资的条件是： 他在 2015 年的投保额 (TIV_2015) 至少跟一个其他投保人在 2015 年的投保额相同。他所在的城市必须与其他投保人都不同（也就是说维度和经度不能跟其他任何一个投保人完全相同）。 就如最后一个投保人，第一个投保人同时满足两个条件： 他在 2015 年的投保金额 TIV_2015 为 10 ，与第三个和第四个投保人在 2015 年的投保金额相同。 他所在城市的经纬度是独一无二的。 第二个投保人两个条件都不满足。他在 2015 年的投资 TIV_2015 与其他任何投保人都不相同。且他所在城市的经纬度与第三个投保人相同。基于同样的原因，第三个投保人投资失败。 最终SQL: Code12345678910111213141516171819202122232425SELECT SUM(insurance.TIV_2016) AS TIV_2016FROM insuranceWHERE insurance.TIV_2015 IN( SELECT TIV_2015 FROM insurance GROUP BY TIV_2015 HAVING COUNT(*) &gt; 1 ) AND CONCAT(LAT, LON) IN( SELECT CONCAT(LAT, LON) FROM insurance GROUP BY LAT , LON HAVING COUNT(*) &#x3D; 1 ); 23. 订单最多的客户需求：在表 orders 中找到订单数最多客户对应的 customer_number 。 展示效果： customer_number 3 Code123456Create table If Not Exists orders (order_number int, customer_number int, order_date date, required_date date, shipped_date date, status char(15), comment char(200), key(order_number));insert into orders (order_number, customer_number) values (1, 1);insert into orders (order_number, customer_number) values (2, 2);insert into orders (order_number, customer_number) values (3, 3);insert into orders (order_number, customer_number) values (4, 3); 最终SQL: Code123456789SELECT customer_numberFROM ordersGROUP BY customer_numberORDER BY COUNT(*) DESCLIMIT 1; 进阶： 如果有多位顾客订单数并列最多，你能找到他们所有的 customer_number 吗？ 24. 大的国家需求：编写一个SQL查询，输出表中所有大国家的名称、人口和面积。 展示效果： name population area Afghanistan 25500100 652230 Algeria 37100000 2381741 Code1234567Create table If Not Exists World (name varchar(255), continent varchar(255), area int, population int, gdp bigint);insert into World (name, continent, area, population, gdp) values (&#39;Afghanistan&#39;, &#39;Asia&#39;, 652230, 25500100, 20343000000);insert into World (name, continent, area, population, gdp) values (&#39;Albania&#39;, &#39;Europe&#39;, 28748, 2831741, 12960000000);insert into World (name, continent, area, population, gdp) values (&#39;Algeria&#39;, &#39;Africa&#39;, 2381741, 37100000, 188681000000);insert into World (name, continent, area, population, gdp) values (&#39;Andorra&#39;, &#39;Europe&#39;, 468, 78115, 3712000000);insert into World (name, continent, area, population, gdp) values (&#39;Angola&#39;, &#39;Africa&#39;, 1246700, 20609294, 100990000000); 最终SQL: Code12345678910111213141516171819202122232425262728#方法一：orselect w.name, w.population, w.areafrom world wwhere w.area &gt;3000000 or w.population &gt;25000000#方法二：unionselect w.name, w.population, w.areafrom world wwhere w.area&gt;3000000unionselect w.name, w.population, w.areafrom world wwhere w.population&gt;25000000 25. 超过五名学生的课需求：编写一个 SQL 查询，列出所有超过或等于5名学生的课。 展示效果： class Math Code1234567891011Create table If Not Exists courses (student varchar(255), class varchar(255));insert into courses (student, class) values (&#39;A&#39;, &#39;Math&#39;);insert into courses (student, class) values (&#39;B&#39;, &#39;English&#39;);insert into courses (student, class) values (&#39;C&#39;, &#39;Math&#39;);insert into courses (student, class) values (&#39;D&#39;, &#39;Biology&#39;);insert into courses (student, class) values (&#39;E&#39;, &#39;Math&#39;);insert into courses (student, class) values (&#39;F&#39;, &#39;Computer&#39;);insert into courses (student, class) values (&#39;G&#39;, &#39;Math&#39;);insert into courses (student, class) values (&#39;H&#39;, &#39;Math&#39;);insert into courses (student, class) values (&#39;I&#39;, &#39;Math&#39;); 最终SQL: Code12345678select class from courses group by classhaving count(distinct student)&gt;&#x3D;5 ; 26. 好友申请需求一：写一个查询语句，求出好友申请的通过率，用 2 位小数表示。通过率由接受好友申请的数目除以申请总数。 展示效果： accept_rate 0.80 Code1234567891011121314Create table If Not Exists friend_request ( sender_id INT NOT NULL, send_to_id INT NULL, request_date DATE NULL);Create table If Not Exists request_accepted ( requester_id INT NOT NULL, accepter_id INT NULL, accept_date DATE NULL);insert into friend_request (sender_id, send_to_id, request_date) values (1, 2, &#39;2016&#x2F;06&#x2F;01&#39;);insert into friend_request (sender_id, send_to_id, request_date) values (1, 3, &#39;2016&#x2F;06&#x2F;01&#39;);insert into friend_request (sender_id, send_to_id, request_date) values (1, 4, &#39;2016&#x2F;06&#x2F;01&#39;);insert into friend_request (sender_id, send_to_id, request_date) values (2, 3, &#39;2016&#x2F;06&#x2F;02&#39;);insert into friend_request (sender_id, send_to_id, request_date) values (3, 4, &#39;2016&#x2F;06&#x2F;09&#39;);insert into request_accepted (requester_id, accepter_id, accept_date) values (1, 2, &#39;2016&#x2F;06&#x2F;03&#39;);insert into request_accepted (requester_id, accepter_id, accept_date) values (1, 3, &#39;2016&#x2F;06&#x2F;08&#39;);insert into request_accepted (requester_id, accepter_id, accept_date) values (2, 3, &#39;2016&#x2F;06&#x2F;08&#39;);insert into request_accepted (requester_id, accepter_id, accept_date) values (3, 4, &#39;2016&#x2F;06&#x2F;09&#39;);insert into request_accepted (requester_id, accepter_id, accept_date) values (3, 4, &#39;2016&#x2F;06&#x2F;10&#39;); 最终SQL: Code12345678select round( ifnull( (select count(*) from (select distinct requester_id, accepter_id from request_accepted) as A) &#x2F; (select count(*) from (select distinct sender_id, send_to_id from friend_request) as B) , 0) , 2) as accept_rate; 需求二：写一个查询语句，求出谁拥有最多的好友和他拥有的好友数目。 展示效果： id num 3 3 最终SQL: Code123456789101112131415161718192021select ids as id, cnt as numfrom (select ids, count(*) as cnt from (select requester_id as ids from request_accepted union all select accepter_id from request_accepted ) as tbl1 group by ids ) as tbl2order by cnt desclimit 1; 27. 体育馆人流量需求：请编写一个查询语句，找出人流量的高峰期。高峰期时，至少连续三行记录中的人流量不少于100。 展示效果： id visit_date people 5 2017-01-05 145 6 2017-01-06 1455 7 2017-01-07 199 8 2017-01-08 188 Code12345678910Create table If Not Exists stadium (id int, visit_date DATE NULL, people int);insert into stadium (id, visit_date, people) values (1, &#39;2017-01-01&#39;, 10);insert into stadium (id, visit_date, people) values (2, &#39;2017-01-02&#39;, 109);insert into stadium (id, visit_date, people) values (3, &#39;2017-01-03&#39;, 150);insert into stadium (id, visit_date, people) values (4, &#39;2017-01-04&#39;, 99);insert into stadium (id, visit_date, people) values (5, &#39;2017-01-05&#39;, 145);insert into stadium (id, visit_date, people) values (6, &#39;2017-01-06&#39;, 1455);insert into stadium (id, visit_date, people) values (7, &#39;2017-01-07&#39;, 199);insert into stadium (id, visit_date, people) values (8, &#39;2017-01-08&#39;, 188); 最终SQL: Code123456789101112SELECT distinct a.*FROM stadium as a, stadium as b, stadium as cwhere ((a.id &#x3D; b.id-1 and b.id+1 &#x3D; c.id) or(a.id-1 &#x3D; b.id and a.id+1 &#x3D; c.id) or(a.id-1 &#x3D; c.id and c.id-1 &#x3D; b.id)) and (a.people&gt;&#x3D;100 and b.people&gt;&#x3D;100 and c.people&gt;&#x3D;100)order by a.id; 28. 连续空余座位需求：编写一个 SQL 查询，获取所有空余座位，并将它们按照 seat_id 排序 展示效果： seat_id 3 4 5 Code1234567Create table If Not Exists cinema (seat_id int primary key auto_increment, free bool);insert into cinema (seat_id, free) values (1, 1);insert into cinema (seat_id, free) values (2, 0);insert into cinema (seat_id, free) values (3, 1);insert into cinema (seat_id, free) values (4, 1);insert into cinema (seat_id, free) values (5, 1); 最终SQL: Code12345678910select distinct a.seat_idfrom cinema a join cinema bon abs(a.seat_id - b.seat_id) &#x3D; 1 and a.free &#x3D; true and b.free &#x3D; trueorder by a.seat_id; 29. 销售员需求：输出所有表 salesperson中，没有向公司 ‘RED’ 销售任何东西的销售员。 展示效果： name Amy Mark Alex Code12345678910111213141516171819Create table If Not Exists salesperson (sales_id int, name varchar(255), salary int,commission_rate int, hire_date varchar(255));Create table If Not Exists company (com_id int, name varchar(255), city varchar(255));Create table If Not Exists orders (order_id int, order_date varchar(255), com_id int, sales_id int, amount int);insert into salesperson (sales_id, name, salary, commission_rate, hire_date) values (1,&#39;John&#39;,100000, 6, &#39;4&#x2F;1&#x2F;2006&#39;);insert into salesperson (sales_id, name, salary, commission_rate, hire_date) values (2,&#39;Amy&#39;, 12000, 5, &#39;5&#x2F;1&#x2F;2010&#39;);insert into salesperson (sales_id, name, salary, commission_rate, hire_date) values (3,&#39;Mark&#39;,65000, 12, &#39;12&#x2F;25&#x2F;2008&#39;);insert into salesperson (sales_id, name, salary, commission_rate, hire_date) values (4,&#39;Pam&#39;, 25000, 25, &#39;1&#x2F;1&#x2F;2005&#39;);insert into salesperson (sales_id, name, salary, commission_rate, hire_date) values (5,&#39;Alex&#39;, 5000, 10, &#39;2&#x2F;3&#x2F;2007&#39;);insert into company (com_id, name, city) values (1, &#39;RED&#39;, &#39;Boston&#39;);insert into company (com_id, name, city) values (2, &#39;ORANGE&#39;, &#39;New York&#39;);insert into company (com_id, name, city) values (3, &#39;YELLOW&#39;, &#39;Boston&#39;);insert into company (com_id, name, city) values (4, &#39;GREEN&#39;, &#39;Austin&#39;);insert into orders (order_id, order_date, com_id, sales_id, amount) values (1, &#39;1&#x2F;1&#x2F;2014&#39;, 3, 4, 10000);insert into orders (order_id, order_date, com_id, sales_id, amount) values (2, &#39;2&#x2F;1&#x2F;2014&#39;, 4, 5, 5000);insert into orders (order_id, order_date, com_id, sales_id, amount) values (3, &#39;3&#x2F;1&#x2F;2014&#39;, 1, 1, 50000);insert into orders (order_id, order_date, com_id, sales_id, amount) values (4, &#39;4&#x2F;1&#x2F;2014&#39;, 1, 4, 25000); 最终SQL: Code1234567891011121314151617SELECT s.nameFROM salesperson sWHERE s.sales_id NOT IN ( SELECT o.sales_id FROM orders o LEFT JOIN company c ON o.com_id &#x3D; c.com_id WHERE c.name &#x3D; &#39;RED&#39; ); 30. 节点树需求：写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。 表 tree，id 是树节点的编号， p_id 是它父节点的 id 。 树中每个节点属于以下三种类型之一： ​ 叶子：如果这个节点没有任何孩子节点。 ​ 根：如果这个节点是整棵树的根，即没有父节点。 ​ 内部节点：如果这个节点既不是叶子节点也不是根节点。 id p_id 1 null 2 1 3 1 4 2 5 2 展示效果： id Type 1 Root 2 Inner 3 Leaf 4 Leaf 5 Leaf 解释: 节点 1 是根节点，因为它的父节点是 NULL ，同时它有孩子节点 2 和 3 。 节点 2 是内部节点，因为它有父节点 1 ，也有孩子节点 4 和 5 。 节点 3, 4 和 5 都是叶子节点，因为它们都有父节点同时没有孩子节点。 Code1234567Create table If Not Exists tree (id int, p_id int);insert into tree (id, p_id) values (1, null);insert into tree (id, p_id) values (2, 1);insert into tree (id, p_id) values (3, 1);insert into tree (id, p_id) values (4, 2);insert into tree (id, p_id) values (5, 2); 最终SQL: Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758方法一：SELECT id, &#39;Root&#39; AS TypeFROM treeWHERE p_id IS NULLUNIONSELECT id, &#39;Leaf&#39; AS TypeFROM treeWHERE id NOT IN (SELECT DISTINCT p_id FROM tree WHERE p_id IS NOT NULL) AND p_id IS NOT NULLUNIONSELECT id, &#39;Inner&#39; AS TypeFROM treeWHERE id IN (SELECT DISTINCT p_id FROM tree WHERE p_id IS NOT NULL) AND p_id IS NOT NULLORDER BY id;方法二：SELECT id AS &#96;Id&#96;, CASE WHEN tree.id &#x3D; (SELECT atree.id FROM tree atree WHERE atree.p_id IS NULL) THEN &#39;Root&#39; WHEN tree.id IN (SELECT atree.p_id FROM tree atree) THEN &#39;Inner&#39; ELSE &#39;Leaf&#39; END AS TypeFROM treeORDER BY &#96;Id&#96;;方法三：SELECT atree.id, IF(ISNULL(atree.p_id),&#39;Root&#39;, IF(atree.id IN (SELECT p_id FROM tree), &#39;Inner&#39;,&#39;Leaf&#39;)) TypeFROM tree atreeORDER BY atree.id; 31. 判断是否是三角形需求：编写一个 SQL 查询，判断三条线段是否能形成一个三角形。 展示效果： x y z triangle 13 15 15 No 10 20 15 Yes Code1234Create table If Not Exists triangle (x int, y int, z int);insert into triangle (x, y, z) values (13, 15, 30);insert into triangle (x, y, z) values (10, 20, 15); 最终SQL: Code123456select x, y, z, if((x + y &lt;&#x3D; z or x + z &lt;&#x3D; y or y + z &lt;&#x3D; x), &quot;No&quot;, &quot;Yes&quot;) as trianglefrom triangle; 32. 平面上的最近距离需求：写一个查询语句找到两点之间的最近距离，保留 2 位小数。 展示效果： shortest 1.00 Code12345CREATE TABLE If Not Exists point_2d (x INT NOT NULL, y INT NOT NULL);insert into point_2d (x, y) values (-1, -1);insert into point_2d (x, y) values (0, 0);insert into point_2d (x, y) values (-1, -2); 最终SQL: Code123456789101112131415161718#方法一：SELECT ROUND(SQRT(MIN((POW(p1.x - p2.x, 2) + POW(p1.y - p2.y, 2)))), 2) AS shortestFROM point_2d p1JOIN point_2d p2 ON p1.x !&#x3D; p2.x OR p1.y !&#x3D; p2.y;#方法二：SELECT ROUND(SQRT(MIN((POW(p1.x - p2.x, 2) + POW(p1.y - p2.y, 2)))),2) AS shortestFROM point_2d p1JOIN point_2d p2 ON (p1.x &lt;&#x3D; p2.x AND p1.y &lt; p2.y) OR (p1.x &lt;&#x3D; p2.x AND p1.y &gt; p2.y) OR (p1.x &lt; p2.x AND p1.y &#x3D; p2.y); 33. 直线上最近距离需求：找到这些点中最近两个点之间的距离。 展示效果： shortest 1 Code12345CREATE TABLE If Not Exists point (x INT NOT NULL, UNIQUE INDEX x_UNIQUE (x ASC));insert into point (x) values (-1);insert into point (x) values (0);insert into point (x) values (2); 最终SQL: Code1234567SELECT MIN(ABS(p1.x - p2.x)) AS shortestFROM point p1JOIN point p2 ON p1.x !&#x3D; p2.x; 34. 二级关注者需求：对每一个关注者(follower)，查询他的关注者数目。 展示效果： follower num B 2 D 1 Code123456Create table If Not Exists follow (followee varchar(255), follower varchar(255));insert into follow (followee, follower) values (&#39;A&#39;, &#39;B&#39;);insert into follow (followee, follower) values (&#39;B&#39;, &#39;C&#39;);insert into follow (followee, follower) values (&#39;B&#39;, &#39;D&#39;);insert into follow (followee, follower) values (&#39;D&#39;, &#39;E&#39;); 解释： 以A为主体，A为被关注者，B为被关注者，求出关注B的关注者。这里需要注意，被关注者永远不会被他 / 她自己关注。将结果按照字典序返回。 最终SQL: Code1234567891011select followee as &#39;follower&#39;, count(distinct follower) as numfrom followwhere followee in(select follower from follow)group by 1order by 1; 35. 平均工资需求：写一个查询语句，求出在每一个工资发放日，每个部门的平均工资与公司的平均工资的比较结果 （高 / 低 / 相同） 展示效果： pay_month department_id comparison 2017-03 1 higher 2017-03 2 lower 2017-02 1 same 2017-02 2 same Code12345678910111213Create table If Not Exists salary (id int, employee_id int, amount int, pay_date date);Create table If Not Exists employee (employee_id int, department_id int);insert into salary (id, employee_id, amount, pay_date) values (1, 1, 9000, &#39;2017&#x2F;03&#x2F;31&#39;);insert into salary (id, employee_id, amount, pay_date) values (2, 2, 6000, &#39;2017&#x2F;03&#x2F;31&#39;);insert into salary (id, employee_id, amount, pay_date) values (3, 3, 10000, &#39;2017&#x2F;03&#x2F;31&#39;);insert into salary (id, employee_id, amount, pay_date) values (4, 1, 7000, &#39;2017&#x2F;02&#x2F;28&#39;);insert into salary (id, employee_id, amount, pay_date) values (5, 2, 6000, &#39;2017&#x2F;02&#x2F;28&#39;);insert into salary (id, employee_id, amount, pay_date) values (6, 3, 8000, &#39;2017&#x2F;02&#x2F;28&#39;);insert into employee (employee_id, department_id) values (1, 1);insert into employee (employee_id, department_id) values (2, 2);insert into employee (employee_id, department_id) values (3, 2); 解释: 在三月，公司的平均工资是 (9000+6000+10000)/3 = 8333.33… 由于部门 1 里只有一个 employee_id 为 1 的员工，所以部门 1 的平均工资就是此人的工资 9000 。因为 9000 &gt; 8333.33 ，所以比较结果是 ‘higher’。 第二个部门的平均工资为 employee_id 为 2 和 3 两个人的平均工资，为 (6000+10000)/2=8000 。因为 8000 &lt; 8333.33 ，所以比较结果是 ‘lower’ 。 在二月用同样的公式求平均工资并比较，比较结果为 ‘same’ ，因为部门 1 和部门 2 的平均工资与公司的平均工资相同，都是 7000 。 最终SQL: Code123456789101112131415161718192021222324252627282930313233select department_salary.pay_month, department_id, case when department_avg&gt;company_avg then &#39;higher&#39; when department_avg&lt;company_avg then &#39;lower&#39; else &#39;same&#39; end as comparisonfrom (select department_id, avg(amount) as department_avg, date_format(pay_date, &#39;%Y-%m&#39;) as pay_month from salary join employee on salary.employee_id &#x3D; employee.employee_id group by department_id, pay_month ) as department_salaryjoin (select avg(amount) as company_avg, date_format(pay_date, &#39;%Y-%m&#39;) as pay_month from salary group by date_format(pay_date, &#39;%Y-%m&#39;) ) as company_salaryon department_salary.pay_month &#x3D; company_salary.pay_month; 36. 学生地理信息报告需求：写一个查询语句实现对大洲（continent）列的 透视表 操作，使得每个学生按照姓名的字母顺序依次排列在对应的大洲下面。输出的标题应依次为美洲（America）、亚洲（Asia）和欧洲（Europe）。数据保证来自美洲的学生不少于来自亚洲或者欧洲的学生。 展示效果： America Asia Europe Jack Xi Pascal Jane Code123456Create table If Not Exists student (name varchar(50), continent varchar(7));insert into student (name, continent) values (&#39;Jane&#39;, &#39;America&#39;);insert into student (name, continent) values (&#39;Pascal&#39;, &#39;Europe&#39;);insert into student (name, continent) values (&#39;Xi&#39;, &#39;Asia&#39;);insert into student (name, continent) values (&#39;Jack&#39;, &#39;America&#39;); 最终SQL: Code123456789101112131415161718192021222324252627282930313233343536SELECT MAX(if(A.continent &#x3D; &#39;America&#39;,A.NAME,NULL)) AS &#96;America&#96;, MAX(if(A.continent &#x3D; &#39;Asia&#39;,A.NAME,NULL)) AS &#96;Asia&#96;, MAX(if(A.continent &#x3D; &#39;Europe&#39;,A.NAME,NULL)) AS &#96;Europe&#96;FROM (SELECT S1.continent, S1.NAME, S1.row_id, COUNT(*) AS &#96;trank&#96; FROM (SELECT S.*, @row_id:&#x3D;(@row_id + 1) AS &#96;row_id&#96; FROM student AS S, (SELECT @row_id:&#x3D;0) AS T ) AS S1 JOIN (SELECT S.*, @n_row_id:&#x3D;(@n_row_id + 1) AS &#96;n_row_id&#96; FROM student AS S, (SELECT @n_row_id:&#x3D;0) AS T ) AS S2 ON (S1.continent &#x3D; S2.continent AND (S1.NAME &gt; S2.NAME OR (S1.NAME &#x3D; S2.NAME AND S1.row_id &gt;&#x3D; S2.n_row_id))) group BY S1.continent,S1.NAME,S1.row_id order BY S1.continent,S1.NAME ) AS AGROUP BY A.trank; 37. 只出现一次的最大数字需求：编写一个 SQL 查询，找到只出现过一次的数字中，最大的一个数字。如果没有只出现一次的数字，输出 null 。 展示效果： num 6 Code12345678910Create table If Not Exists my_numbers (num int);insert into my_numbers (num) values (8);insert into my_numbers (num) values (8);insert into my_numbers (num) values (3);insert into my_numbers (num) values (3);insert into my_numbers (num) values (1);insert into my_numbers (num) values (4);insert into my_numbers (num) values (5);insert into my_numbers (num) values (6); 最终SQL: Code123456789101112select ifnull((SELECT num FROM my_numbers group by num having count(*) &#x3D; 1 order by num desc limit 1), null) as num; 38. 有趣的电影需求：编写一个 SQL 查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列 展示效果： id movie description rating 5 House card Interesting 9.1 1 War great 3D 8.9 Code1234567Create table If Not Exists cinema (id int, movie varchar(255), description varchar(255), rating float(2, 1));insert into cinema (id, movie, description, rating) values (1, &#39;War&#39;, &#39;great 3D&#39;, 8.9);insert into cinema (id, movie, description, rating) values (2, &#39;Science&#39;, &#39;fiction&#39;, 8.5);insert into cinema (id, movie, description, rating) values (3, &#39;irish&#39;, &#39;boring&#39;, 6.2);insert into cinema (id, movie, description, rating) values (4, &#39;Ice song&#39;, &#39;Fantacy&#39;, 8.6);insert into cinema (id, movie, description, rating) values (5, &#39;House card&#39;, &#39;Interesting&#39;, 9.1); 最终SQL: Code1234567891011select id, movie, description, ratingfrom cinemawhere mod(id, 2) &#x3D; 1 and description !&#x3D; &#39;boring&#39;order by rating DESC; 39. 换座位需求：编写一个 SQL 查询，小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。 展示效果： id student 1 Doris 2 Abbot 3 Green 4 Emerson 5 Jeames Code1234567Create table If Not Exists seat(id int, student varchar(255));insert into seat (id, student) values (1, &#39;Abbot&#39;);insert into seat (id, student) values (2, &#39;Doris&#39;);insert into seat (id, student) values (3, &#39;Emerson&#39;);insert into seat (id, student) values (4, &#39;Green&#39;);insert into seat (id, student) values (5, &#39;Jeames&#39;); 最终SQL: Code12345678910111213141516171819202122232425262728293031323334353637383940#方法一select a.id, ifnull(b.student,a.student) as student from seat as a left join seat as b on (a.id%2&#x3D;1 &amp;&amp; a.id&#x3D;b.id-1) || (a.id%2&#x3D;0 &amp;&amp; a.id&#x3D;b.id+1) order by a.id;#方法二select if(id%2&#x3D;0,id-1,if(id&#x3D;cnt,id,id+1)) as id, studentfrom (select count(*) as cnt from seat )as a, seatorder by id;#方法三 select b.id, a.studentfrom seat as a, seat as b, (select count(*) as cnt from seat ) as c where b.id&#x3D;1^(a.id-1)+1 || (c.cnt%2 &amp;&amp; b.id&#x3D;c.cnt &amp;&amp; a.id&#x3D;c.cnt); 40. 交换工资需求：编写一个 SQL 查询，判断三条线段是否能形成一个三角形。 展示效果： id name sex salary 1 A f 2500 2 B m 1500 3 C f 5500 4 D m 500 Code123456create table if not exists salary(id int, name varchar(100), sex char(1), salary int);insert into salary (id, name, sex, salary) values (1, &#39;A&#39;, &#39;m&#39;, 2500);insert into salary (id, name, sex, salary) values (2, &#39;B&#39;, &#39;f&#39;, 1500);insert into salary (id, name, sex, salary) values (3, &#39;C&#39;, &#39;m&#39;, 5500);insert into salary (id, name, sex, salary) values (4, &#39;D&#39;, &#39;f&#39;, 500); 最终SQL: Code123456UPDATE salarySET sex &#x3D; CASE sex WHEN &#39;m&#39; THEN &#39;f&#39; ELSE &#39;m&#39; END; 41. 买下所有产品的用户需求：编写一个 SQL 查询，从 Customer 表中查询购买了 Product 表中所有产品的客户的 id。 展示效果： customer_id 1 3 Code1234567891011Create table If Not Exists Customer (customer_id int, product_key int)Create table Product (product_key int)insert into Customer (customer_id, product_key) values (1, 5)insert into Customer (customer_id, product_key) values (2, &#39;6&#39;)insert into Customer (customer_id, product_key) values (3, 5)insert into Customer (customer_id, product_key) values (3, &#39;6&#39;)insert into Customer (customer_id, product_key) values (1, &#39;6&#39;)insert into Product (product_key) values (5)insert into Product (product_key) values (&#39;6&#39;) 最终SQL: Code1234567891011select customer_idfrom (select customer_id,count(distinct product_key) as num from Customer group by customer_id) tjoin ( select count(product_key) as num from Product) m on t.num &#x3D; m.num; 42. 合作过至少三次的演员和导演需求：编写一个 SQL 查询，查询语句获取合作过至少三次的演员和导演的 id 对 (actor_id, director_id) 展示效果： actor_id director_id 1 15 Code123456789Create table If Not Exists ActorDirector (actor_id int, director_id int, timestamp int);insert into ActorDirector (actor_id, director_id, timestamp) values (1, 1, 0);insert into ActorDirector (actor_id, director_id, timestamp) values (1, 1, 1);insert into ActorDirector (actor_id, director_id, timestamp) values (1, 1, 2);insert into ActorDirector (actor_id, director_id, timestamp) values (1, 2, 3);insert into ActorDirector (actor_id, director_id, timestamp) values (1, 2, 4);insert into ActorDirector (actor_id, director_id, timestamp) values (2, 1, 5);insert into ActorDirector (actor_id, director_id, timestamp) values (2, 1, 6); 最终SQL: Code123456789select actor_id as ACTOR_ID , director_id as DIRECTOR_IDfrom ActorDirector group by actor_id,director_id having count(*)&gt;&#x3D;3; 43. 产品销售分析需求一：获取产品表 Product 中所有的 产品名称 product name 以及 该产品在 Sales 表中相对应的 上市年份 year 和 价格 price。 展示效果： product_name year price Nokia 2008 5000 Nokia 2009 5000 Apple 2011 9000 Code12345678910Create table Sales (sale_id int, product_id int, year int, quantity int, price int);Create table Product (product_id int, product_name varchar(10));insert into Sales (sale_id, product_id, year, quantity, price) values (1, 100, 2008, 10, 5000);insert into Sales (sale_id, product_id, year, quantity, price) values (2, 100, 2009, 12, 5000);insert into Sales (sale_id, product_id, year, quantity, price) values (7, 200, 2011, 15, 9000);insert into Product (product_id, product_name) values (100, &#39;Nokia&#39;);insert into Product (product_id, product_name) values (200, &#39;Apple&#39;);insert into Product (product_id, product_name) values (300, &#39;Samsung&#39;); 最终SQL: Code12345678910select product_name, year, pricefrom Sales inner join Producton Sales.product_id &#x3D; Product.product_id; 需求二：按产品 id product_id 来统计每个产品的销售总量。 展示效果： product_id total_quantity 100 22 200 15 最终SQL: Code1234567SELECT product_id, SUM(quantity) as total_quantityFROM SalesGROUP BY product_id; 需求三：选出每个销售产品的 第一年 的 产品 id、年份、数量 和 价格。 展示效果： product_id first_year quantity price 100 2008 10 5000 200 2011 15 9000 最终SQL: Code1234567891011121314151617select product_id, year as first_year, quantity, pricefrom Saleswhere (product_id , year) in( select product_id , min(year) from Sales group by product_id ); 44. 项目员工需求一：查询每一个项目中员工的平均工作年限，精确到小数点后两位。 展示效果： project_id average_years 1 2.00 2 2.50 Code12345678910111213Create table If Not Exists Project (project_id int, employee_id int);Create table If Not Exists Employee (employee_id int, name varchar(10), experience_years int);insert into Project (project_id, employee_id) values (1, 1);insert into Project (project_id, employee_id) values (1, 2);insert into Project (project_id, employee_id) values (1, 3);insert into Project (project_id, employee_id) values (2, 1);insert into Project (project_id, employee_id) values (2, 4);insert into Employee (employee_id, name, experience_years) values (1, &#39;Khaled&#39;, 3);insert into Employee (employee_id, name, experience_years) values (2, &#39;Ali&#39;, 2);insert into Employee (employee_id, name, experience_years) values (3, &#39;John&#39;, 1);insert into Employee (employee_id, name, experience_years) values (4, &#39;Doe&#39;, 2); 最终SQL: Code12345678910111213select project_id , round(avg(experience_years),2) as average_yearsfrom Projectleft join Employeeon Project.employee_id &#x3D; Employee.employee_idgroup by project_idorder by project_id; 需求二：报告所有雇员最多的项目。 展示效果： project_id 1 最终SQL: Code12345678910111213141516171819SELECT project_idFROM ProjectGROUP BY project_idHAVING COUNT(employee_id) &#x3D; (SELECT MAX(count_employee_id) FROM (SELECT project_id, COUNT(employee_id) AS count_employee_id FROM Project GROUP BY project_id ) As temp ); 需求三：报告在每一个项目中经验最丰富的雇员是谁。如果出现经验年数相同的情况，请报告所有具有最大经验年数的员工。 展示效果： project_id employee_id 1 1 1 3 2 1 最终SQL: Code12345678910111213141516171819202122select p.project_id, p.employee_idfrom Project pjoin Employee eon p.employee_id &#x3D; e.employee_idwhere (p.project_id, e.experience_years) in (select p.project_id, max(e.experience_years) from project p join employee e on p.employee_id &#x3D; e.employee_id group by p.project_id ); 45. 销售分析需求一：编写一个 SQL 查询，查询总销售额最高的销售者，如果有并列的，就都展示出来。 展示效果： seller_id 1 3 Code1234567891011Create table If Not Exists Product (product_id int, product_name varchar(10), unit_price int);Create table If Not Exists Sales (seller_id int, product_id int,buyer_id int, sale_date date, quantity int, price int);insert into Product (product_id, product_name, unit_price) values (1, &#39;S8&#39;, 1000);insert into Product (product_id, product_name, unit_price) values (2, &#39;G4&#39;, 800);insert into Product (product_id, product_name, unit_price) values (3, &#39;iPhone&#39;, 1400);insert into Sales (seller_id, product_id, buyer_id, sale_date, quantity, price) values (1, 1, 1,&#39;2019-01-21&#39;, 2, 2000);insert into Sales (seller_id, product_id, buyer_id, sale_date, quantity, price) values (1, 2, 2,&#39;2019-02-17&#39;, 1, 800);insert into Sales (seller_id, product_id, buyer_id, sale_date, quantity, price) values (2, 1, 3,&#39;2019-06-02&#39;, 1, 800);insert into Sales (seller_id, product_id, buyer_id, sale_date, quantity, price) values (3, 3, 3,&#39;2019-05-13&#39;, 2, 2800); 最终SQL: Code1234567891011121314151617select seller_id from Salesgroup by seller_idhaving sum(price) &#x3D; (select sum(price) as ye_ji from Sales group by seller_id order by ye_ji desc limit 1 ); 需求二：编写一个 SQL 查询，查询购买了 S8 手机却没有购买 iPhone 的买家。注意这里 S8 和 iPhone 是 Product 表中的产品。 展示效果： buyer_id 1 最终SQL: Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#方法一select distinct buyer_idfrom product p inner join sales son p.product_id&#x3D;s.product_idwhere product_name&#x3D;&#39;S8&#39; and buyer_id not in (select buyer_id from product p inner join sales s on p.product_id&#x3D;s.product_id where product_name&#x3D;&#39;iPhone&#39; );#方法二select s8 as buyer_idfrom (select distinct buyer_id s8 from product p inner join sales s on p.product_id&#x3D;s.product_id where product_name&#x3D;&#39;S8&#39;) t1left join (select distinct buyer_id ip from product p inner join sales s on p.product_id&#x3D;s.product_id where product_name&#x3D;&#39;iPhone&#39; ) t2on s8&#x3D;ipwhere ip is null; 需求三：编写一个 SQL 查询，报告2019年春季才售出的产品。即在2019-01-01至2019-03-31（含）之间。 展示效果： product_id product_name 1 S8 2 G4 最终SQL: Code1234567891011121314SELECT s.product_id, product_nameFROM Sales sJOIN Product pON s.product_id &#x3D; p.product_idGROUP BY s.product_idHAVING sale_date &gt;&#x3D; &#39;2019-01-01&#39; AND sale_date &lt;&#x3D; &#39;2019-03-31&#39;; 46. 小众书籍需求：筛选出订单总量 少于10本 的 书籍 。 展示效果： book_id name 1 “Kalila And Demna” 2 “28 Letters” 5 “The Hunger Games” Code12345678910111213141516Create table If Not Exists Books (book_id int, name varchar(50), available_from date);Create table If Not Exists Orders (order_id int, book_id int, quantity int, dispatch_date date);insert into Books (book_id, name, available_from) values (1, &#39;Kalila And Demna&#39;, &#39;2010-01-01&#39;);insert into Books (book_id, name, available_from) values (2, &#39;28 Letters&#39;, &#39;2012-05-12&#39;);insert into Books (book_id, name, available_from) values (3, &#39;The Hobbit&#39;, &#39;2019-06-10&#39;);insert into Books (book_id, name, available_from) values (4, &#39;13 Reasons Why&#39;, &#39;2019-06-01&#39;);insert into Books (book_id, name, available_from) values (5, &#39;The Hunger Games&#39;, &#39;2008-09-21&#39;);insert into Orders (order_id, book_id, quantity, dispatch_date) values (1, 1, 2, &#39;2018-07-26&#39;);insert into Orders (order_id, book_id, quantity, dispatch_date) values (2, 1, 1, &#39;2018-11-05&#39;);insert into Orders (order_id, book_id, quantity, dispatch_date) values (3, 3, 8, &#39;2019-06-11&#39;);insert into Orders (order_id, book_id, quantity, dispatch_date) values (4, 4, 6, &#39;2019-06-05&#39;);insert into Orders (order_id, book_id, quantity, dispatch_date) values (5, 4, 5, &#39;2019-06-20&#39;);insert into Orders (order_id, book_id, quantity, dispatch_date) values (6, 5, 9, &#39;2009-02-02&#39;);insert into Orders (order_id, book_id, quantity, dispatch_date) values (7, 5, 8, &#39;2010-04-13&#39;); 最终SQL: Code1234567891011121314151617181920select t1.book_id, t1.namefrom (select * from books where available_from &lt;date_sub(&#39;2019-06-23&#39;,interval 1 Month)) t1 left join (select *, case when dispatch_date between &#39;2018-06-23&#39; and &#39;2019-06-23&#39; then quantity else 0 end num from orders ) t2 on t1.book_id&#x3D;t2.book_id group by t1.book_id having sum(if(t2.num is null,0,t2.num))&lt;10; 47. 每日新用户统计需求一：查询每一个项目中员工的平均工作年限，精确到小数点后两位。 展示效果： login_date user_count 2019-05-01 1 2019-06-21 2 Code1234567891011121314151617Create table If Not Exists Traffic (user_id int, activity ENUM(&#39;login&#39;, &#39;logout&#39;, &#39;jobs&#39;, &#39;groups&#39;, &#39;homepage&#39;), activity_date date);insert into Traffic (user_id, activity, activity_date) values (1, &#39;login&#39;, &#39;2019-05-01&#39;);insert into Traffic (user_id, activity, activity_date) values (1, &#39;homepage&#39;, &#39;2019-05-01&#39;);insert into Traffic (user_id, activity, activity_date) values (1, &#39;logout&#39;, &#39;2019-05-01&#39;);insert into Traffic (user_id, activity, activity_date) values (2, &#39;login&#39;, &#39;2019-06-21&#39;);insert into Traffic (user_id, activity, activity_date) values (2, &#39;logout&#39;, &#39;2019-06-21&#39;);insert into Traffic (user_id, activity, activity_date) values (3, &#39;login&#39;, &#39;2019-01-01&#39;);insert into Traffic (user_id, activity, activity_date) values (3, &#39;jobs&#39;, &#39;2019-01-01&#39;);insert into Traffic (user_id, activity, activity_date) values (3, &#39;logout&#39;, &#39;2019-01-01&#39;);insert into Traffic (user_id, activity, activity_date) values (4, &#39;login&#39;, &#39;2019-06-21&#39;);insert into Traffic (user_id, activity, activity_date) values (4, &#39;groups&#39;, &#39;2019-06-21&#39;);insert into Traffic (user_id, activity, activity_date) values (4, &#39;logout&#39;, &#39;2019-06-21&#39;);insert into Traffic (user_id, activity, activity_date) values (5, &#39;login&#39;, &#39;2019-03-01&#39;);insert into Traffic (user_id, activity, activity_date) values (5, &#39;logout&#39;, &#39;2019-03-01&#39;);insert into Traffic (user_id, activity, activity_date) values (5, &#39;login&#39;, &#39;2019-06-21&#39;);insert into Traffic (user_id, activity, activity_date) values (5, &#39;logout&#39;, &#39;2019-06-21&#39;); 最终SQL: Code123456789101112131415161718select minx as login_date, count(user_id) as user_countfrom (select user_id, min(activity_date) as minx from Traffic where activity&#x3D;&#39;login&#39; group by user_id having datediff(&#39;2019-06-30&#39;,minx)&lt;&#x3D;90 )sgroup by minx; 48. 每位学生的最高成绩需求一：查询每一个项目中员工的平均工作年限，精确到小数点后两位。 展示效果： student_id average_years grade 1 2 99 2 2 95 3 3 82 Code123456789Create table If Not Exists Enrollments (student_id int, course_id int, grade int);insert into Enrollments (student_id, course_id, grade) values (2, 2, 95);insert into Enrollments (student_id, course_id, grade) values (2, 3, 95);insert into Enrollments (student_id, course_id, grade) values (1, 1, 90);insert into Enrollments (student_id, course_id, grade) values (1, 2, 99);insert into Enrollments (student_id, course_id, grade) values (3, 1, 80);insert into Enrollments (student_id, course_id, grade) values (3, 2, 75);insert into Enrollments (student_id, course_id, grade) values (3, 3, 82); 最终SQL: Code12345678910111213141516171819202122select t.student_id, if(count(e.grade) &gt; 1 ,min(e.course_id),course_id) as course_id, t.max1 as gradefrom Enrollments e right join (select student_id, max(grade) as max1 from Enrollments group by student_id )ton t.student_id&#x3D;e.student_id and t.max1 &#x3D; e.gradegroup by e.student_id order by t.student_id; 49. Reported Posts需求一：Write an SQL query that reports the number of posts reported yesterday for each report reason. Assume today is 2019-07-05. 展示效果： report_reason report_count spam 1 racism 2 Code123456789101112131415Create table If Not Exists Actions (user_id int, post_id int, action_date date, action ENUM(&#39;view&#39;, &#39;like&#39;, &#39;reaction&#39;, &#39;comment&#39;, &#39;report&#39;, &#39;share&#39;), extra varchar(10));insert into Actions (user_id, post_id, action_date, action, extra) values (1, 1, &#39;2019-07-01&#39;, &#39;view&#39;, null);insert into Actions (user_id, post_id, action_date, action, extra) values (1, 1, &#39;2019-07-01&#39;, &#39;like&#39;, null);insert into Actions (user_id, post_id, action_date, action, extra) values (1, 1, &#39;2019-07-01&#39;, &#39;share&#39;, null);insert into Actions (user_id, post_id, action_date, action, extra) values (2, 4, &#39;2019-07-04&#39;, &#39;view&#39;, null);insert into Actions (user_id, post_id, action_date, action, extra) values (2, 4, &#39;2019-07-04&#39;, &#39;report&#39;, &#39;spam&#39;);insert into Actions (user_id, post_id, action_date, action, extra) values (3, 4, &#39;2019-07-04&#39;, &#39;view&#39;, null);insert into Actions (user_id, post_id, action_date, action, extra) values (3, 4, &#39;2019-07-04&#39;, &#39;report&#39;, &#39;spam&#39;);insert into Actions (user_id, post_id, action_date, action, extra) values (4, 3, &#39;2019-07-02&#39;, &#39;view&#39;, null);insert into Actions (user_id, post_id, action_date, action, extra) values (4, 3, &#39;2019-07-02&#39;, &#39;report&#39;, &#39;spam&#39;);insert into Actions (user_id, post_id, action_date, action, extra) values (5, 2, &#39;2019-07-04&#39;, &#39;view&#39;, null);insert into Actions (user_id, post_id, action_date, action, extra) values (5, 2, &#39;2019-07-04&#39;, &#39;report&#39;, &#39;racism&#39;);insert into Actions (user_id, post_id, action_date, action, extra) values (5, 5, &#39;2019-07-04&#39;, &#39;view&#39;, null);insert into Actions (user_id, post_id, action_date, action, extra) values (5, 5, &#39;2019-07-04&#39;, &#39;report&#39;, &#39;racism&#39;); 最终SQL: Code1234567891011select extra report_reason, count(distinct post_id) report_count from Actions where datediff(&#39;2019-07-05&#39;, action_date) &#x3D; 1 and extra is not null and action &#x3D; &#39;report&#39; group by extra; 需求二：Write an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places. 展示效果： average_daily_percent 50.00 The percentage for 2019-07-04 is 50% because only one post of two spam reported posts was removed.The percentage for 2019-07-02 is 100% because one post was reported as spam and it was removed.The other days had no spam reports so the average is (50 + 100) / 2 = 75%Note that the output is only one number and that we do not care about the remove dates. Code1234create table if not exists Removals (post_id int, remove_date date);insert into Removals (post_id, remove_date) values (2, &#39;2019-07-20&#39;);insert into Removals (post_id, remove_date) values (3, &#39;2019-07-18&#39;); 最终SQL: Code12345678910111213141516171819202122SELECT round( SUM(delCount &#x2F; spamCount * 100) &#x2F; COUNT(DISTINCT action_date), 2) AS average_daily_percentFROM (SELECT action_date, COUNT(distinct a.post_id) AS spamCount, count(distinct b.post_id) AS delCount FROM Actions a LEFT JOIN Removals b ON a.post_id &#x3D; b.post_id where a.extra &#x3D; &#39;spam&#39; GROUP BY a.action_date ) a; 50. Active Businesses需求：Write an SQL query to find all active businesses. An active business is a business that has more than one event type with occurences greater than the average occurences of that event type among all businesses. 展示效果： business_id 1 Average for ‘reviews’, ‘ads’ and ‘page views’ are (7+3)/2=5, (11+7+6)/3=8, (3+12)/2=7.5 respectively.Business with id 1 has 7 ‘reviews’ events (more than 5) and 11 ‘ads’ events (more than 8) so it is an active business. Code123456789Create table If Not Exists Events (business_id int, event_type varchar(10), occurences int);insert into Events (business_id, event_type, occurences) values (1, &#39;reviews&#39;, 7);insert into Events (business_id, event_type, occurences) values (3, &#39;reviews&#39;, 3);insert into Events (business_id, event_type, occurences) values (1, &#39;ads&#39;, 11);insert into Events (business_id, event_type, occurences) values (2, &#39;ads&#39;, 7);insert into Events (business_id, event_type, occurences) values (3, &#39;ads&#39;, 6);insert into Events (business_id, event_type, occurences) values (1, &#39;page views&#39;, 3);insert into Events (business_id, event_type, occurences) values (2, &#39;page views&#39;, 12); 最终SQL: Code1234567891011121314SELECT DISTINCT(business_id) FROM Events e LEFT JOIN Events tmpON e.event_type &#x3D; tmp.event_type WHERE e.occurences &gt; tmp.avg_countGROUP BY business_idHAVING COUNT(1) &gt; 1 51. User Purchase Platform需求一：Write an SQL query to find the total number of users and the total amount spent using mobile only, desktop only and both mobile and desktop together for each date. 展示效果： spend_date platform total_amount total_users 2019-07-01 desktop 100 1 2019-07-01 mobile 100 1 2019-07-01 both 200 1 2019-07-02 desktop 100 1 2019-07-02 mobile 100 1 2019-07-02 both 0 0 Code12345678Create table If Not Exists Spending (user_id int, spend_date date, platform ENUM(&#39;desktop&#39;, &#39;mobile&#39;), amount int);insert into Spending (user_id, spend_date, platform, amount) values (1, &#39;2019-07-01&#39;, &#39;mobile&#39;, 100);insert into Spending (user_id, spend_date, platform, amount) values (1, &#39;2019-07-01&#39;, &#39;desktop&#39;, 100);insert into Spending (user_id, spend_date, platform, amount) values (2, &#39;2019-07-01&#39;, &#39;mobile&#39;, 100);insert into Spending (user_id, spend_date, platform, amount) values (2, &#39;2019-07-02&#39;, &#39;mobile&#39;, 100);insert into Spending (user_id, spend_date, platform, amount) values (3, &#39;2019-07-01&#39;, &#39;desktop&#39;, 100);insert into Spending (user_id, spend_date, platform, amount) values (3, &#39;2019-07-02&#39;, &#39;desktop&#39;, 100); On 2019-07-01, user 1 purchased using both desktop and mobile, user 2 purchased using mobile only and user 3 purchased using desktop only.On 2019-07-02, user 2 purchased using mobile only, user 3 purchased using desktop only and no one purchased using both platforms. 最终SQL: Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647select temp1.spend_date, temp1.platform, ifnull(temp3.total_amount, 0) total_amount, ifnull(temp3.total_users,0) total_usersfrom (select distinct(spend_date), p.platform from Spending, (select &#39;desktop&#39; as platform union select &#39;mobile&#39; as platform union select &#39;both&#39; as platform ) as p ) as temp1left join (select spend_date, platform, sum(amount) as total_amount, count(user_id) total_users from (select spend_date, user_id, case count(distinct platform) when 1 then platform when 2 then &#39;both&#39; end as platform, sum(amount) as amount from Spending group by spend_date, user_id ) as temp2 group by spend_date, platform ) as temp3on temp1.platform &#x3D; temp3.platform and temp1.spend_date &#x3D; temp3.spend_date; 52. User Activity for the Past 30 Days需求一：Write an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places. 展示效果： day active_users 2019-07-20 2 2019-07-21 2 Code12345678910111213Create table If Not Exists Activity (user_id int, session_id int, activity_date date, activity_type ENUM(&#39;open_session&#39;, &#39;end_session&#39;, &#39;scroll_down&#39;, &#39;send_message&#39;));insert into Activity (user_id, session_id, activity_date, activity_type) values (1, 1, &#39;2019-07-20&#39;, &#39;open_session&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (1, 1, &#39;2019-07-20&#39;, &#39;scroll_down&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (1, 1, &#39;2019-07-20&#39;, &#39;end_session&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (2, 4, &#39;2019-07-20&#39;, &#39;open_session&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (2, 4, &#39;2019-07-21&#39;, &#39;send_message&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (2, 4, &#39;2019-07-21&#39;, &#39;end_session&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (3, 2, &#39;2019-07-21&#39;, &#39;open_session&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (3, 2, &#39;2019-07-21&#39;, &#39;send_message&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (3, 2, &#39;2019-07-21&#39;, &#39;end_session&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (4, 3, &#39;2019-06-25&#39;, &#39;open_session&#39;);insert into Activity (user_id, session_id, activity_date, activity_type) values (4, 3, &#39;2019-06-25&#39;, &#39;end_session&#39;); 最终SQL: Code1234567891011121314151617181920select t.activity_date as day, count(distinct t.user_id) as active_usersfrom (select activity_date, user_id from Activity where datediff(&#39;2019-07-27&#39;,activity_date) &lt;30 and datediff( &#39;2019-07-27&#39;, activity_date) &gt;&#x3D;0 group by user_id, activity_date having count(activity_type)&gt;0 ) as tgroup by t.activity_date; 需求二：编写SQL查询以查找截至2019年7月27日（含）的30天内每个用户的平均会话数，四舍五入到小数点后两位。我们要为用户计算的会话是在该时间段内至少进行了一项活动的会话。 展示效果： average_sessions_per_user 1.00 最终SQL: Code123456789101112SELECT ROUND(IFNULL(AVG(count_session_id), 0), 2) AS average_sessions_per_userFROM (SELECT COUNT(DISTINCT session_id) AS count_session_id FROM Activity WHERE activity_date BETWEEN DATE_SUB(&quot;2019-07-27&quot;, INTERVAL 29 DAY) AND &quot;2019-07-27&quot; GROUP BY user_id ) AS temp; 52. 文章浏览需求一：查询每一个项目中员工的平均工作年限，精确到小数点后两位。 展示效果： id 4 7 Code12345678910Create table If Not Exists Views (article_id int, author_id int, viewer_id int, view_date date);Truncate table Views;insert into Views (article_id, author_id, viewer_id, view_date) values (1, 3, 5, &#39;2019-08-01&#39;);insert into Views (article_id, author_id, viewer_id, view_date) values (3, 4, 5, &#39;2019-08-01&#39;);insert into Views (article_id, author_id, viewer_id, view_date) values (1, 3, &#39;6&#39;, &#39;2019-08-02&#39;);insert into Views (article_id, author_id, viewer_id, view_date) values (2, &#39;7&#39;, &#39;7&#39;, &#39;2019-08-01&#39;);insert into Views (article_id, author_id, viewer_id, view_date) values (2, &#39;7&#39;, &#39;6&#39;, &#39;2019-08-02&#39;);insert into Views (article_id, author_id, viewer_id, view_date) values (4, &#39;7&#39;, 1, &#39;2019-07-22&#39;);insert into Views (article_id, author_id, viewer_id, view_date) values (3, 4, 4, &#39;2019-07-21&#39;);insert into Views (article_id, author_id, viewer_id, view_date) values (3, 4, 4, &#39;2019-07-21&#39;); 最终SQL: Code12345678select distinct viewer_id as idfrom Views where viewer_id &#x3D; author_idorder by viewer_id; 需求二：Write an SQL query to find all the people who viewed more than one article on the same date, sorted in ascending order by their id. 展示效果： project_id 5 6 最终SQL: Code12345678910SELECT DISTINCT viewer_id as id FROM viewsGROUP BY viewer_id,view_dateHAVING COUNT(DISTINCT article_id)&gt;&#x3D;2ORDER BY viewer_id; 53. Market Analysis需求一：Write an SQL query to find for each user, the join date and the number of orders they made as a buyer in 2019. 展示效果： buyer_id join_date orders_in_2019 1 2018-01-01 1 2 2018-02-09 2 3 2018-01-19 0 4 2018-05-21 0 Code1234567891011121314151617181920Create table If Not Exists Users (user_id int, join_date date, favorite_brand varchar(10));create table if not exists Orders (order_id int, order_date date, item_id int, buyer_id int, seller_id int);create table if not exists Items (item_id int, item_brand varchar(10));insert into Users (user_id, join_date, favorite_brand) values (1, &#39;2018-01-01&#39;, &#39;Lenovo&#39;);insert into Users (user_id, join_date, favorite_brand) values (2, &#39;2018-02-09&#39;, &#39;Samsung&#39;);insert into Users (user_id, join_date, favorite_brand) values (3, &#39;2018-01-19&#39;, &#39;LG&#39;);insert into Users (user_id, join_date, favorite_brand) values (4, &#39;2018-05-21&#39;, &#39;HP&#39;);insert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values (1, &#39;2019-08-01&#39;, 4, 1, 2);insert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values (2, &#39;2018-08-02&#39;, 2, 1, 3);insert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values (3, &#39;2019-08-03&#39;, 3, 2, 3);insert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values (4, &#39;2018-08-04&#39;, 1, 4, 2);insert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values (5, &#39;2018-08-04&#39;, 1, 3, 4);insert into Orders (order_id, order_date, item_id, buyer_id, seller_id) values (6, &#39;2019-08-05&#39;, 2, 2, 4);insert into Items (item_id, item_brand) values (1, &#39;Samsung&#39;);insert into Items (item_id, item_brand) values (2, &#39;Lenovo&#39;);insert into Items (item_id, item_brand) values (3, &#39;LG&#39;);insert into Items (item_id, item_brand) values (4, &#39;HP&#39;); 最终SQL: Code123456789101112131415SELECT user_id AS buyer_id, join_date, IFNULL(COUNT(buyer_Id), 0) AS orders_in_2019FROM Users u LEFT JOIN Orders oON U.user_id &#x3D; o.buyer_id AND order_date &gt;&#x3D; &#39;2019-01-01&#39;GROUP BY user_idORDER BY user_id; 需求二：Write an SQL query to find for each user, whether the brand of the second item (by date) they sold is their favorite brand. If a user sold less than two items, report the answer for that user as no. 展示效果： product_id 2nd_item_fav_brand 1 no 2 no 3 yes 4 no 最终SQL: Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950select user_id as seller_id, case when t3.item_brand is null then &#39;no&#39; when t3.item_brand &#x3D; u.favorite_brand then &#39;yes&#39; else &#39;no&#39; end as 2nd_item_fav_brandfrom Users uleft join (select order_id, order_date, t2.item_id, buyer_id, seller_id, i.item_brand as item_brand from (select order_id, order_date, item_id, buyer_id, seller_id, cast(if(@prev &#x3D; seller_id,@rank :&#x3D; @rank + 1,@rank :&#x3D; 1) as unsigned) as rank, @prev :&#x3D; seller_id as prev from (select order_id, order_date, item_id, buyer_id, seller_id from Orders group by seller_id, order_date ) as t1, (select @rank :&#x3D; 0, @prev :&#x3D; null ) as init) t2, Items i where rank &#x3D; 2 and t2.item_id &#x3D; i.item_id ) as t3on u.user_id &#x3D; t3.seller_id; 54. Product Price at a Given Date需求一：Write an SQL query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10. 展示效果： project_id price 2 50 1 35 3 10 Code12345678Create table If Not Exists Products (product_id int, new_price int, change_date date);Truncate table Products;insert into Products (product_id, new_price, change_date) values (1, 20, &#39;2019-08-14&#39;);insert into Products (product_id, new_price, change_date) values (2, 50, &#39;2019-08-14&#39;);insert into Products (product_id, new_price, change_date) values (1, 30, &#39;2019-08-15&#39;);insert into Products (product_id, new_price, change_date) values (1, 35, &#39;2019-08-16&#39;);insert into Products (product_id, new_price, change_date) values (2, 65, &#39;2019-08-17&#39;);insert into Products (product_id, new_price, change_date) values (3, 20, &#39;2019-08-18&#39;); 最终SQL: Code12345678910111213141516171819202122232425262728293031323334SELECT * FROM (SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) FROM Products WHERE change_date &lt;&#x3D; &#39;2019-08-16&#39; GROUP BY product_id ) UNION SELECT DISTINCT product_id, 10 AS price FROM Products WHERE product_id NOT IN (SELECT product_id FROM Products WHERE change_date &lt;&#x3D; &#39;2019-08-16&#39; ) ) tmpORDER BY price DESC; 55. Immediate Food Delivery需求一：Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places. 展示效果： immediate_percentage 42.86 Code123456789Create table If Not Exists Delivery (delivery_id int, customer_id int, order_date date, customer_pref_delivery_date date);Truncate table Delivery;insert into Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) values (1, 1, &#39;2019-08-01&#39;, &#39;2019-08-02&#39;);insert into Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) values (2, 5, &#39;2019-08-02&#39;, &#39;2019-08-02&#39;);insert into Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) values (3, 1, &#39;2019-08-11&#39;, &#39;2019-08-11&#39;);insert into Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) values (4, 3, &#39;2019-08-24&#39;, &#39;2019-08-26&#39;);insert into Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) values (5, 4, &#39;2019-08-21&#39;, &#39;2019-08-22&#39;);insert into Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) values (6, 2, &#39;2019-08-11&#39;, &#39;2019-08-13&#39;);insert into Delivery (delivery_id, customer_id, order_date, customer_pref_delivery_date) values (7, 4, &#39;2019-08-09&#39;, &#39;2019-08-09&#39;); 最终SQL: Code12345678SELECT ROUND( (SELECT COUNT(delivery_id) FROM Delivery WHERE order_date &#x3D; customer_pref_delivery_date) * 100 &#x2F; COUNT(delivery_id) , 2) AS immediate_percentageFROM Delivery; 需求二：Write an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places. 展示效果： immediate_percentage 40.00 最终SQL: Code1234567891011121314151617181920select round( count(case when d.order_date &#x3D; d.customer_pref_delivery_date then 1 end) * 100&#x2F;count(*), 2) as immediate_percentagefrom Delivery d, (select delivery_id, customer_id, min(order_date) as order_date from Delivery group by customer_id ) as twhere d.customer_id &#x3D; t.customer_id and d.order_date &#x3D; t.order_date; 56. 重新格式化部门表需求一：编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 每个月 的收入（revenue）列。 展示效果： id Jan_Revenue Feb_Revenue Mar_Revenue … Dec_Revenue 1 8000 7000 6000 … null 2 9000 null null … null 3 null 10000 null … null Code1234567Create table If Not Exists Department (id int, revenue int, month varchar(5));Truncate table Department;insert into Department (id, revenue, month) values (1, 8000, &#39;Jan&#39;);insert into Department (id, revenue, month) values (2, 9000, &#39;Jan&#39;);insert into Department (id, revenue, month) values (3, 10000, &#39;Feb&#39;);insert into Department (id, revenue, month) values (1, 7000, &#39;Feb&#39;);insert into Department (id, revenue, month) values (1, 6000, &#39;Mar&#39;); 最终SQL: Code1234567891011121314151617SELECT DISTINCT id AS &quot;id&quot;, SUM(IF (month &#x3D; &quot;Jan&quot;, revenue, null)) AS &quot;Jan_Revenue&quot;, SUM(IF (month &#x3D; &quot;Feb&quot;, revenue, null)) AS &quot;Feb_Revenue&quot;, SUM(IF (month &#x3D; &quot;Mar&quot;, revenue, null)) AS &quot;Mar_Revenue&quot;, SUM(IF (month &#x3D; &quot;Apr&quot;, revenue, null)) AS &quot;Apr_Revenue&quot;, SUM(IF (month &#x3D; &quot;May&quot;, revenue, null)) AS &quot;May_Revenue&quot;, SUM(IF (month &#x3D; &quot;Jun&quot;, revenue, null)) AS &quot;Jun_Revenue&quot;, SUM(IF (month &#x3D; &quot;Jul&quot;, revenue, null)) AS &quot;Jul_Revenue&quot;, SUM(IF (month &#x3D; &quot;Aug&quot;, revenue, null)) AS &quot;Aug_Revenue&quot;, SUM(IF (month &#x3D; &quot;Sep&quot;, revenue, null)) AS &quot;Sep_Revenue&quot;, SUM(IF (month &#x3D; &quot;Oct&quot;, revenue, null)) AS &quot;Oct_Revenue&quot;, SUM(IF (month &#x3D; &quot;Nov&quot;, revenue, null)) AS &quot;Nov_Revenue&quot;, SUM(IF (month &#x3D; &quot;Dec&quot;, revenue, null)) AS &quot;Dec_Revenue&quot; FROM DepartmentGROUP BY id; 57. 每月交易需求一：查询每一个项目中员工的平均工作年限，精确到小数点后两位。 展示效果： month country trans_count approved_count trans_total_amount approved_total_amount 2018-12 US 2 1 3000 1000 2019-01 US 1 1 2000 2000 2019-01 DE 1 1 2000 2000 2019-05 US 2 1 3000 1000 2019-06 US 3 2 12000 8000 Code12345678910111213141516create table if not exists Transactions (id int, country varchar(4), state enum(&#39;approved&#39;, &#39;declined&#39;), amount int, trans_date date);create table if not exists Chargebacks (trans_id int, trans_date date);insert into Transactions (id, country, state, amount, trans_date) values (101, &#39;US&#39;, &#39;approved&#39;, 1000, &#39;2018-12-18&#39;);insert into Transactions (id, country, state, amount, trans_date) values (102, &#39;US&#39;, &#39;declined&#39;, 2000, &#39;2018-12-19&#39;);insert into Transactions (id, country, state, amount, trans_date) values (103, &#39;US&#39;, &#39;approved&#39;, 2000, &#39;2019-01-01&#39;);insert into Transactions (id, country, state, amount, trans_date) values (104, &#39;DE&#39;, &#39;approved&#39;, 2000, &#39;2019-01-07&#39;);insert into Transactions (id, country, state, amount, trans_date) values (105, &#39;US&#39;, &#39;approved&#39;, 1000, &#39;2019-05-18&#39;);insert into Transactions (id, country, state, amount, trans_date) values (106, &#39;US&#39;, &#39;declined&#39;, 2000, &#39;2019-05-19&#39;);insert into Transactions (id, country, state, amount, trans_date) values (107, &#39;US&#39;, &#39;approved&#39;, 3000, &#39;2019-06-10&#39;);insert into Transactions (id, country, state, amount, trans_date) values (108, &#39;US&#39;, &#39;declined&#39;, 4000, &#39;2019-06-13&#39;);insert into Transactions (id, country, state, amount, trans_date) values (109, &#39;US&#39;, &#39;approved&#39;, 5000, &#39;2019-06-15&#39;);insert into Chargebacks (trans_id, trans_date) values (102, &#39;2019-05-29&#39;);insert into Chargebacks (trans_id, trans_date) values (101, &#39;2019-06-30&#39;);insert into Chargebacks (trans_id, trans_date) values (105, &#39;2019-09-18&#39;); 最终SQL: Code123456789101112select date_format(trans_date,&#39;%Y-%m&#39;) as month, country, count(*) as trans_count, sum(if(state&#x3D;&#39;approved&#39;,1,0)) as approved_count, sum(amount) as trans_total_amount, sum(if(state&#x3D;&#39;approved&#39;,amount,0)) as approved_total_amountfrom Transactions tgroup by date_format(trans_date,&#39;%Y-%m&#39;), country; 需求二：编写一个 SQL 查询，以查找每个月和每个国家/地区的已批准交易的数量及其总金额、退单的数量及其总金额。 展示效果： month country approved_count approved_amount chargeback_count chargeback_amount 2018-12 US 1 1000 0 0 2019-01 DE 1 2000 0 0 2019-01 US 1 2000 0 0 2019-05 US 1 1000 1 2000 2019-06 US 2 8000 1 1000 2019-09 US 0 0 1 1000 最终SQL: Code1234567891011121314151617181920212223242526272829303132SELECT month as MONTH, country as COUNTRY, SUM(IF(type &#x3D; &#39;approved&#39;, 1, 0)) AS APPROVED_COUNT, SUM(IF(type &#x3D; &#39;approved&#39;, amount, 0)) AS APPROVED_AMOUNT, SUM(IF(type &#x3D; &#39;chargeback&#39;, 1, 0)) AS CHARGEBACK_COUNT, SUM(IF(type &#x3D; &#39;chargeback&#39;, amount, 0)) AS CHARGEBACK_AMOUNTFROM (SELECT date_format(t.trans_date,&#39;%Y-%m&#39;) AS month, t.country, amount, &#39;approved&#39; AS type FROM Transactions AS t WHERE state &#x3D; &#39;approved&#39; UNION ALL SELECT date_format(c.trans_date,&#39;%Y-%m&#39;) AS month, t.country, amount, &#39;chargeback&#39; AS type FROM Transactions AS t INNER JOIN Chargebacks AS c ON t.id &#x3D; c.trans_id ) AS ttGROUP BY tt.month, tt.country; 58. 锦标赛优胜者需求一：编写一个 SQL 查询来查找每组中的获胜者。每组的获胜者是在组内得分最高的选手。如果平局，得分最低的选手获胜。 展示效果： group_id player_id 1 15 2 35 3 40 Code123456789101112131415161718Create table If Not Exists Players (player_id int, group_id int);Create table If Not Exists Matches (match_id int, first_player int, second_player int, first_score int, second_score int);Truncate table Players;insert into Players (player_id, group_id) values (10, 2);insert into Players (player_id, group_id) values (15, 1);insert into Players (player_id, group_id) values (20, 3);insert into Players (player_id, group_id) values (25, 1);insert into Players (player_id, group_id) values (30, 1);insert into Players (player_id, group_id) values (35, 2);insert into Players (player_id, group_id) values (40, 3);insert into Players (player_id, group_id) values (45, 1);insert into Players (player_id, group_id) values (50, 2);Truncate table Matches;insert into Matches (match_id, first_player, second_player, first_score, second_score) values (1, 15, 45, 3, 0);insert into Matches (match_id, first_player, second_player, first_score, second_score) values (2, 30, 25, 1, 2);insert into Matches (match_id, first_player, second_player, first_score, second_score) values (3, 30, 15, 2, 0);insert into Matches (match_id, first_player, second_player, first_score, second_score) values (4, 40, 20, 5, 2);insert into Matches (match_id, first_player, second_player, first_score, second_score) values (5, 35, 50, 1, 1); 最终SQL: Code123456789101112131415161718192021222324252627282930313233select group_id, player_idfrom (select group_id, player_id, sum( case when player_id &#x3D; first_player then first_score when player_id &#x3D; second_player then second_score end ) as totalScores from Players p, Matches m where p.player_id &#x3D; m.first_player or p.player_id &#x3D; m.second_player group by group_id, player_id order by group_id, totalScores desc, player_id ) as tempgroup by group_idorder by group_id, totalScores desc, player_id; 59. Last Person to Fit in the Elevator需求：Queue table is ordered by turn in the example for simplicity.In the example George Washington(id 5), John Adams(id 3) and Thomas Jefferson(id 6) will enter the elevator as their weight sum is 250 + 350 + 400 = 1000.Thomas Jefferson(id 6) is the last person to fit in the elevator because he has the last turn in these three people. 展示效果： person_name Thomas Jefferson Code12345678Create table If Not Exists Queue (person_id int, person_name varchar(30), weight int, turn int);Truncate table Queue;insert into Queue (person_id, person_name, weight, turn) values (5, &#39;George Washington&#39;, 250, 1);insert into Queue (person_id, person_name, weight, turn) values (4, &#39;Thomas Jefferson&#39;, 175, 5);insert into Queue (person_id, person_name, weight, turn) values (3, &#39;John Adams&#39;, 350, 2);insert into Queue (person_id, person_name, weight, turn) values (6, &#39;Thomas Jefferson&#39;, 400, 3);insert into Queue (person_id, person_name, weight, turn) values (1, &#39;James Elephant&#39;, 500, 6);insert into Queue (person_id, person_name, weight, turn) values (2, &#39;Will Johnliams&#39;, 200, 4); 最终SQL: Code12345678910111213select person_namefrom Queue q1where (select sum(weight) from Queue where turn &lt;&#x3D; q1.turn) &lt;&#x3D; 1000order by turn desc limit 1; 60. Queries Quality and Percentage需求：Write an SQL query to find each query_name, the quality and poor_query_percentage. 展示效果： query_name quality poor_query_percentage Dog 2.50 33.33 Cat 0.66 33.33 Code12345678Create table If Not Exists Queries (query_name varchar(30), result varchar(50), position int, rating int);Truncate table Queries;insert into Queries (query_name, result, position, rating) values (&#39;Dog&#39;, &#39;Golden Retriever&#39;, 1, 5);insert into Queries (query_name, result, position, rating) values (&#39;Dog&#39;, &#39;German Shepherd&#39;, 2, 5);insert into Queries (query_name, result, position, rating) values (&#39;Dog&#39;, &#39;Mule&#39;, &#39;200&#39;, 1);insert into Queries (query_name, result, position, rating) values (&#39;Cat&#39;, &#39;Shirazi&#39;, 5, 2);insert into Queries (query_name, result, position, rating) values (&#39;Cat&#39;, &#39;Siamese&#39;, 3, 3);insert into Queries (query_name, result, position, rating) values (&#39;Cat&#39;, &#39;Sphynx&#39;, 7, 4); 最终SQL: Code12345678select query_name, round(avg(rating&#x2F;position), 2) as quality , round((count(if(rating&lt;3, True, null)) &#x2F; count(query_name)) *100 , 2) as poor_query_percentagefrom Queriesgroup by query_name; 61. Team Scores in Football Tournament需求一：You would like to compute the scores of all teams after all matches. Points are awarded as follows:A team receives three points if they win a match (Score strictly more goals than the opponent team).A team receives one point if they draw a match (Same number of goals as the opponent team).A team receives no points if they lose a match (Score less goals than the opponent team).Write an SQL query that selects the team_id, team_name and num_points of each team in the tournament after all described matches. Result table should be ordered by num_points (decreasing order). In case of a tie, order the records by team_id (increasing order). 展示效果： team_id team_name num_points 10 Leetcode FC 7 20 NewYork FC 3 50 Toronto FC 3 30 Atlanta FC 1 40 Chicago FC 0 Code1234567891011121314Create table If Not Exists Teams (team_id int, team_name varchar(30));Create table If Not Exists Matches (match_id int, host_team int, guest_team int, host_goals int, guest_goals int);Truncate table Teams;insert into Teams (team_id, team_name) values (10, &#39;Leetcode FC&#39;);insert into Teams (team_id, team_name) values (20, &#39;NewYork FC&#39;);insert into Teams (team_id, team_name) values (30, &#39;Atlanta FC&#39;);insert into Teams (team_id, team_name) values (40, &#39;Chicago FC&#39;);insert into Teams (team_id, team_name) values (50, &#39;Toronto FC&#39;);Truncate table Matches;insert into Matches (match_id, host_team, guest_team, host_goals, guest_goals) values (1, 10, 20, 30, 0);insert into Matches (match_id, host_team, guest_team, host_goals, guest_goals) values (2, 30, 10, 2, 2);insert into Matches (match_id, host_team, guest_team, host_goals, guest_goals) values (3, 10, 50, 5, 1);insert into Matches (match_id, host_team, guest_team, host_goals, guest_goals) values (4, 20, 30, 1, 0);insert into Matches (match_id, host_team, guest_team, host_goals, guest_goals) values (5, 50, 30, 1, 0); 最终SQL: Code1234567891011121314151617181920212223242526272829303132333435SELECT *FROM (SELECT a.team_id, MAX(team_name) AS team_name, SUM( CASE WHEN a.team_id &#x3D; b.host_team THEN CASE WHEN b.host_goals &gt; b.guest_goals THEN 3 WHEN b.host_goals &#x3D; b.guest_goals THEN 1 ELSE 0 END WHEN a.team_id &#x3D; b.guest_team THEN CASE WHEN b.host_goals &lt; b.guest_goals THEN 3 WHEN b.host_goals &#x3D; b.guest_goals THEN 1 ELSE 0 END ELSE 0 END ) AS num_points FROM Teams a LEFT JOIN Matches b ON a.team_id &#x3D; b.host_team OR a.team_id &#x3D; b.guest_team GROUP BY a.team_id ) a ORDER BY a.num_points DESC, a.team_id; 62. 报告系统状态的连续日期需求：系统 每天 运行一个任务。每个任务都独立于先前的任务。任务的状态可以是失败或是成功。编写一个 SQL 查询 2019-01-01 到 2019-12-31 期间任务连续同状态 period_state 的起止日期（start_date 和 end_date）。即如果任务失败了，就是失败状态的起止日期，如果任务成功了，就是成功状态的起止日期。最后结果按照起始日期 start_date 排序 展示效果： period_state start date end date present 2019-01-01 2019-01-03 missing 2019-01-04 2019-01-05 present 2019-01-06 2019-01-06 Code1234567891011121314Create table If Not Exists Failed (fail_date date);Create table If Not Exists Succeeded (success_date date);Truncate table Failed;insert into Failed (fail_date) values (&#39;2018-12-28&#39;);insert into Failed (fail_date) values (&#39;2018-12-29&#39;);insert into Failed (fail_date) values (&#39;2019-01-04&#39;);insert into Failed (fail_date) values (&#39;2019-01-05&#39;);Truncate table Succeeded;insert into Succeeded (success_date) values (&#39;2018-12-30&#39;);insert into Succeeded (success_date) values (&#39;2018-12-31&#39;);insert into Succeeded (success_date) values (&#39;2019-01-01&#39;);insert into Succeeded (success_date) values (&#39;2019-01-02&#39;);insert into Succeeded (success_date) values (&#39;2019-01-03&#39;);insert into Succeeded (success_date) values (&#39;2019-01-06&#39;); 最终SQL: Code12345678910111213141516171819202122232425262728293031323334353637383940414243select if(str&#x3D;1,&#39;succeeded&#39;,&#39;failed&#39;) as period_state , min(date) as start_date, max(date) as end_datefrom (select @diff :&#x3D; @diff+ if(num &#x3D; 1 , 1,0) as diff, date, str from (select case when @str &#x3D; str and date_add(@pre,interval 1 day) &#x3D; date then @num :&#x3D; @num +1 when @str:&#x3D;str then @num :&#x3D; 1 else @num :&#x3D; 1 end as num, @pre :&#x3D; date, date, str from (select fail_date as date , 0 as &#39;str&#39; from Failed union select success_date, 1 from Succeeded ) s, (select @pre:&#x3D;null,@num:&#x3D;0,@str :&#x3D; null) s1 where date between &#39;2019-01-01&#39; and &#39;2019-12-31&#39; order by date ) s, (select @diff:&#x3D;0) s1 ) ysgroup by diff, str; 62. 每个帖子的评论数需求一：编写 SQL 语句以查找每个帖子的评论数。结果表应包含帖子的 post_id 和对应的评论数 number_of_comments 并且按 post_id 升序排列。Submissions 可能包含重复的评论。您应该计算每个帖子的唯一评论数。Submissions 可能包含重复的帖子。您应该将它们视为一个帖子。 展示效果： post_id number_of_comments 1 3 2 2 12 0 Code12345678910111213Create table If Not Exists Submissions (sub_id int, parent_id int);Truncate table Submissions;insert into Submissions (sub_id, parent_id) values (1, null);insert into Submissions (sub_id, parent_id) values (2, null);insert into Submissions (sub_id, parent_id) values (1, null);insert into Submissions (sub_id, parent_id) values (12, null);insert into Submissions (sub_id, parent_id) values (3, 1);insert into Submissions (sub_id, parent_id) values (5, 2);insert into Submissions (sub_id, parent_id) values (3, 1);insert into Submissions (sub_id, parent_id) values (4, 1);insert into Submissions (sub_id, parent_id) values (9, 1);insert into Submissions (sub_id, parent_id) values (10, 2);insert into Submissions (sub_id, parent_id) values (6, 7); 最终SQL: Code1234567891011121314151617SELECT post_id, COUNT( DISTINCT S2.sub_id ) AS number_of_comments FROM (SELECT DISTINCT sub_id AS post_id FROM Submissions WHERE parent_id IS NULL ) S1LEFT JOIN Submissions S2ON S1.post_id &#x3D; S2.parent_id GROUP BY S1.post_id; 63. Average Selling Price需求一：Write an SQL query to find the average selling price for each product. average_price should be rounded to 2 decimal places. The query result format is in the following example: 展示效果： product_id average_price 1 6.96 2 16.96 Code123456789101112Create table If Not Exists Prices (product_id int, start_date date, end_date date, price int);Create table If Not Exists UnitsSold (product_id int, purchase_date date, units int);Truncate table Prices;insert into Prices (product_id, start_date, end_date, price) values (1, &#39;2019-02-17&#39;, &#39;2019-02-28&#39;, 5);insert into Prices (product_id, start_date, end_date, price) values (1, &#39;2019-03-01&#39;, &#39;2019-03-22&#39;, 20);insert into Prices (product_id, start_date, end_date, price) values (2, &#39;2019-02-01&#39;, &#39;2019-02-20&#39;, 15);insert into Prices (product_id, start_date, end_date, price) values (2, &#39;2019-02-21&#39;, &#39;2019-03-31&#39;, 30);Truncate table UnitsSold;insert into UnitsSold (product_id, purchase_date, units) values (1, &#39;2019-02-25&#39;, 100);insert into UnitsSold (product_id, purchase_date, units) values (1, &#39;2019-03-01&#39;, 15);insert into UnitsSold (product_id, purchase_date, units) values (2, &#39;2019-02-10&#39;, 200);insert into UnitsSold (product_id, purchase_date, units) values (2, &#39;2019-03-22&#39;, 30); 最终SQL: Code12345678910111213141516171819select product_id, round(sum(a)&#x2F;sum(units),2) as average_pricefrom (select p.product_id as product_id, price,units, price * units as a from Prices p left join UnitsSold u on p.product_id&#x3D;u.product_id and purchase_date&lt;&#x3D;end_date and purchase_date&gt;&#x3D;start_date )tgroup by product_id; 64. Page Recommendations需求一：Write an SQL query to recommend pages to the user with user_id = 1 using the pages that your friends liked. It should not recommend pages you already liked. Return result table in any order without duplicates. 展示效果： recommended_page 23 24 56 33 77 Code1234567891011121314151617181920Create table If Not Exists Friendship (user1_id int, user2_id int);Create table If Not Exists Likes (user_id int, page_id int);Truncate table Friendship;insert into Friendship (user1_id, user2_id) values (1, 2);insert into Friendship (user1_id, user2_id) values (1, 3);insert into Friendship (user1_id, user2_id) values (1, 4);insert into Friendship (user1_id, user2_id) values (2, 3);insert into Friendship (user1_id, user2_id) values (2, 4);insert into Friendship (user1_id, user2_id) values (2, 5);insert into Friendship (user1_id, user2_id) values (6, 1);Truncate table Likes;insert into Likes (user_id, page_id) values (1, 88);insert into Likes (user_id, page_id) values (2, 23);insert into Likes (user_id, page_id) values (3, 24);insert into Likes (user_id, page_id) values (4, 56);insert into Likes (user_id, page_id) values (5, 11);insert into Likes (user_id, page_id) values (6, 33);insert into Likes (user_id, page_id) values (2, 77);insert into Likes (user_id, page_id) values (3, 77);insert into Likes (user_id, page_id) values (6, 88); 解释： User one is friend with users 2, 3, 4 and 6. Suggested pages are 23 from user 2, 24 from user 3, 56 from user 3 and 33 from user 6. Page 77 is suggested from both user 2 and user 3.Page 88 is not suggested because user 1 already likes it. 最终SQL: Code12345678910111213141516171819202122232425select distinct page_id as recommended_pagefrom Likes, friendshipwhere page_id not in(select page_id from likes where user_id&#x3D;1 ) and user_id in (select user1_id from friendship where user2_id&#x3D;1 ) or user_id in (select user2_id from friendship where user1_id&#x3D;1); 65. All People Report to the Given Manager需求一：Write an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company. The indirect relation between managers will not exceed 3 managers as the company is small. Return result table in any order without duplicates. 展示效果： employee_id 2 77 4 7 Code12345678910Create table If Not Exists Employees (employee_id int, employee_name varchar(30), manager_id int);Truncate table Employees;insert into Employees (employee_id, employee_name, manager_id) values (1, &#39;Boss&#39;, 1);insert into Employees (employee_id, employee_name, manager_id) values (3, &#39;Alice&#39;, 3);insert into Employees (employee_id, employee_name, manager_id) values (2, &#39;Bob&#39;, 1);insert into Employees (employee_id, employee_name, manager_id) values (4, &#39;Daniel&#39;, 2);insert into Employees (employee_id, employee_name, manager_id) values (7, &#39;Luis&#39;, 4);insert into Employees (employee_id, employee_name, manager_id) values (8, &#39;John&#39;, 3);insert into Employees (employee_id, employee_name, manager_id) values (9, &#39;Angela&#39;, 8);insert into Employees (employee_id, employee_name, manager_id) values (77, &#39;Robert&#39;, 1); 提示： The head of the company is the employee with employee_id 1. The employees with employee_id 2 and 77 report their work directly to the head of the company. The employee with employee_id 4 report his work indirectly to the head of the company 4 –&gt; 2 –&gt; 1. The employee with employee_id 7 report his work indirectly to the head of the company 7 –&gt; 4 –&gt; 2 –&gt; 1. The employees with employee_id 3, 8 and 9 don’t report their work to head of company directly or indirectly. 最终SQL: Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546select employee_id EMPLOYEE_IDfrom employeeswhere manager_id&#x3D;1 and employee_id!&#x3D;1unionselect a1.employee_idfrom employees a1, (select employee_id from employees where manager_id&#x3D;1 and employee_id!&#x3D;1 ) awhere manager_id&#x3D;a.employee_idunionselect a2.employee_idfrom employees a2, (select a1.employee_id employee_id from employees a1, (select employee_id from employees where manager_id&#x3D;1 and employee_id!&#x3D;1 ) a where manager_id&#x3D;a.employee_id ) a3where manager_id&#x3D;a3.employee_idorder by employee_id;","categories":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/categories/SQL/"},{"name":"MySQL","slug":"SQL/MySQL","permalink":"https://masteryang4.github.io/categories/SQL/MySQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"https://masteryang4.github.io/tags/MySQL/"}]},{"title":"kafka知识整理","slug":"kafka知识整理","date":"2020-06-18T06:33:51.000Z","updated":"2020-06-18T06:41:13.096Z","comments":true,"path":"2020/06/18/kafka知识整理/","link":"","permalink":"https://masteryang4.github.io/2020/06/18/kafka%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","excerpt":"","text":"kafka 本文转载自： https://chenhefei.github.io/2020/04/01/Kafka/Kafka-learning/ kafka的定义Kafka是一个分布式的基于发布/订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。 消息队列有什么好处Code123456789101）解耦允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。2）可恢复性系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。3）缓冲有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。4）灵活性 &amp; 峰值处理能力在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。5）异步通信很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。 消费队列的两种模式Code12345（1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后，queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。（2）发布&#x2F;订阅模式（一对多，消费者消费数据之后不会清除消息）消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。 kafka中的相关概念Code1234567891）Producer ：消息生产者，就是向kafka broker发消息的客户端；2）Consumer ：消息消费者，向kafka broker取消息的客户端；3）Consumer Group （CG）：消费者组，由多个consumer组成。消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费；消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。4）Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。5）Topic ：可以理解为一个队列，生产者和消费者面向的都是一个topic；6）Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列；7）Replica：副本，为保证集群中的某个节点发生故障时，该节点上的partition数据不丢失，且kafka仍然能够继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个leader和若干个follower。8）leader：每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader。9）follower：每个分区多个副本中的“从”，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的leader。 kafka配置文件位置 Code12[ys@hadoop102 kafka]$ cd config&#x2F;[ys@hadoop102 config]$ vi server.properties 内容 properties123456789101112131415161718192021222324#broker的全局唯一编号，不能重复broker.id=0#删除topic功能使能delete.topic.enable=true#处理网络请求的线程数量num.network.threads=3#用来处理磁盘IO的线程数量num.io.threads=8#发送套接字的缓冲区大小socket.send.buffer.bytes=102400#接收套接字的缓冲区大小socket.receive.buffer.bytes=102400#请求套接字的缓冲区大小socket.request.max.bytes=104857600#kafka运行日志存放的路径log.dirs=/opt/module/kafka/logs#topic在当前broker上的分区个数num.partitions=1#用来恢复和清理data下数据的线程数量num.recovery.threads.per.data.dir=1#segment文件保留的最长时间，超时将被删除log.retention.hours=168#配置连接Zookeeper集群地址zookeeper.connect=hadoop102:2181,hadoop103:2181,hadoop104:2181 kafka分布式的broker.id配置Code1plain修改配置文件&#x2F;opt&#x2F;module&#x2F;kafka&#x2F;config&#x2F;server.properties中的broker.id&#x3D;1、broker.id&#x3D;2注：broker.id不得重复 kafka的群起脚本shell12345for i in hadoop102 hadoop103 hadoop104doecho \"========== $i ==========\" ssh $i '/opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties'done kafka的命令行操作命令Code12345678910111213141516171819202122232425262728293031323334353637383940启动[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-server-start.sh -daemon config&#x2F;server.properties查看当前服务器中的所有topic[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-topics.sh --zookeeper hadoop102:2181 --list创建topic[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-topics.sh --zookeeper hadoop102:2181 --create --replication-factor 3 --partitions 1 --topic first选项说明：--topic 定义topic名--replication-factor 定义副本数--partitions 定义分区数删除topic[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-topics.sh --zookeeper hadoop102:2181 --delete --topic first需要server.properties中设置delete.topic.enable&#x3D;true否则只是标记删除。发送消息[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-console-producer.sh --broker-list hadoop102:9092 --topic first&gt;hello world&gt;atguigu atguigu消费消息[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-console-consumer.sh \\--zookeeper hadoop102:2181 --topic first[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-console-consumer.sh \\--zookeeper hadoop102:2181 --topic first --consumer.config config&#x2F;consumer.properties 指定消费者的配置文件(可将多个消费者放置在一个组内)[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-console-consumer.sh \\--bootstrap-server hadoop102:9092 --topic first[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-console-consumer.sh \\--bootstrap-server hadoop102:9092 --from-beginning --topic first注 : --from-beginning：会把主题中以往所有的数据都读取出来。查看某个Topic的详情[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-topics.sh --zookeeper hadoop102:2181 --describe --topic first修改分区数[atguigu@hadoop102 kafka]$ bin&#x2F;kafka-topics.sh --zookeeper hadoop102:2181 --alter --topic first --partitions 6 kafka工作流程Code12345678910111213141516Kafka中消息是以topic进行分类的，生产者生产消息，消费者消费消息，都是面向topic的。topic是逻辑上的概念，而partition是物理上的概念，每个partition对应于一个log文件，该log文件中存储的就是producer生产的数据。Producer生产的数据会被不断追加到该log文件末端，且每条数据都有自己的offset。消费者组中的每个消费者，都会实时记录自己消费到了哪个offset，以便出错恢复时，从上次的位置继续消费。由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，Kafka采取了分片和索引机制，将每个partition分为多个segment。每个segment对应两个文件——“.index”文件和“.log”文件。这些文件位于一个文件夹下，该文件夹的命名规则为：topic名称+分区序号。例如，first这个topic有三个分区，则其对应的文件夹为first-0,first-1,first-2。如下00000000000000000000.index00000000000000000000.log00000000000000170410.index00000000000000170410.log00000000000000239430.index00000000000000239430.logindex和log文件以当前segment的第一条消息的offset命名。“.index”文件存储大量的索引信息，“.log”文件存储大量的数据，索引文件中的元数据指向对应数据文件中message的物理偏移地址。 kafka生产者的分区分配策略Code1234567891）分区的原因（1）方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；（2）可以提高并发，因为可以以Partition为单位读写了。2）分区的原则我们需要将producer发送的数据封装成一个ProducerRecord对象。（1）指明 partition 的情况下，直接将指明的值直接作为 partiton 值；（2）没有指明 partition 值但有 key 的情况下，将 key 的 hash 值与 topic 的 partition 数进行取余得到 partition 值；（3）既没有 partition 值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与 topic 可用的 partition 总数取余得到 partition 值，也就是常说的 round-robin 算法。 kafka如何保证数据可靠性Code123为保证producer发送的数据能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。 都有哪些副本数据同步策略 优缺点是什么 方案 优点 缺点 半数以上完成同步，就发送ack 延迟低 选举新的leader时，容忍n台节点的故障，需要2n+1个副本 全部完成同步，才发送ack 选举新的leader时，容忍n台节点的故障，需要n+1个副本 延迟高 kafka的副本同步策略是什么 这个策略会出现什么问题Code12345Kafka选择了第二种方案，原因如下：1.同样为了容忍n台节点的故障，第一种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而Kafka的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。2.虽然第二种方案的网络延迟会比较高，但网络延迟对Kafka的影响较小。采用第二种方案之后，设想以下情景：leader收到数据，所有follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那leader就要一直等下去，直到它完成同步，才能发送ack。这个问题怎么解决呢？ kafka中的ISR是什么Code123456789Leader维护了一个动态的in-sync replica set (ISR)，意为和leader保持同步的follower集合。当ISR中的follower完成数据的同步之后，leader就会给producer发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定。Leader发生故障之后，就会从ISR中选举新的leader。 kafka中的ack应答机制是什么Code12对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等ISR中的follower全部接收成功。所以Kafka为用户提供了三种可靠性级别，用户根据对可靠性和延迟的要求进行权衡，选择以下的配置。 Code12345acks参数配置：acks：0：producer不等待broker的ack，这一操作提供了一个最低的延迟，broker一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据；1：producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会丢失数据；-1（all）：producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack。但是如果在follower同步完成后，broker发送ack之前，leader发生故障，那么会造成数据重复。 kafka如何进行故障处理Code12LEO：指的是每个副本最大的offset；HW：指的是消费者能见到的最大的offset，ISR队列中最小的LEO。 Code1234（1）follower故障follower发生故障后会被临时踢出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。等该follower的LEO大于等于该Partition的HW，即follower追上leader之后，就可以重新加入ISR了。（2）leader故障leader发生故障之后，会从ISR中选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会先将各自的log文件高于HW的部分截掉，然后从新的leader同步数据。注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。 kafka消费者的消费方式Code123consumer采用pull（拉）模式从broker中读取数据。push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka的消费者在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即为timeout。 kafka消费者的分区分配策略Code12一个consumer group中有多个consumer，一个 topic有多个partition，所以必然会涉及到partition的分配问题，即确定那个partition由哪个consumer来消费。Kafka有两种分配策略，一是RoundRobin，一是Range。 kafka消费者如何维护offsetCode1234567891011由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。Kafka 0.9版本之前，consumer默认将offset保存在Zookeeper中，从0.9版本开始，consumer默认将offset保存在Kafka一个内置的topic中，该topic为__consumer_offsets。1）修改配置文件consumer.propertiesexclude.internal.topics&#x3D;false2）读取offset0.11.0.0之前版本:bin&#x2F;kafka-console-consumer.sh --topic __consumer_offsets --zookeeper hadoop102:2181 --formatter &quot;kafka.coordinator.GroupMetadataManager\\$OffsetsMessageFormatter&quot; --consumer.config config&#x2F;consumer.properties --from-beginning0.11.0.0之后版本(含):bin&#x2F;kafka-console-consumer.sh --topic __consumer_offsets --zookeeper hadoop102:2181 --formatter &quot;kafka.coordinator.group.GroupMetadataManager\\$OffsetsMessageFormatter&quot; --consumer.config config&#x2F;consumer.properties --from-beginning kafka中的消费者组是什么Code123456789101112配置config&#x2F;consumer.properties文件中的group.id然后在启动消费者时候使用同一个配置文件 就可以让消费者在一个组内同一个消费者组中的消费者，同一时刻只能有一个消费者消费。如果消费者组中的消费者多于当前的分区数 会有警告提醒No broker partitions consumed by consumer thread ...如果停止了所有的消费者 那么offset会维护在我们选择的地方(zk中或者是本地) 再次启动消费者会根据选择的GTP(group topic partition所维护的offset位置进行继续消费)下图为zk中维护的信息 kafka为什么能够高效读写数据 分布式框架 分区 顺序写磁盘 Kafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端，为顺序写。官网有数据表明，同样的磁盘，顺序写能到600M/s，而随机写只有100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。 零复制技术 kafka的零拷贝技术如何实现kafka中的消费者在读取服务端的数据时，需要将服务端的磁盘文件通过网络发送到消费者进程，网络发送需要经过几种网络节点。如下图所示： 传统的读取文件数据并发送到网络的步骤如下：（1）操作系统将数据从磁盘文件中读取到内核空间的页面缓存；（2）应用程序将数据从内核空间读入用户空间缓冲区；（3）应用程序将读到数据写回内核空间并放入socket缓冲区；（4）操作系统将数据从socket缓冲区复制到网卡接口，此时数据才能通过网络发送。 通常情况下，Kafka的消息会有多个订阅者，生产者发布的消息会被不同的消费者多次消费，为了优化这个流程，Kafka使用了“零拷贝技术”，如下图所示： “零拷贝技术”只用将磁盘文件的数据复制到页面缓存中一次，然后将数据从页面缓存直接发送到网络中（发送给不同的订阅者时，都可以使用同一个页面缓存），避免了重复复制操作。 如果有10个消费者，传统方式下，数据复制次数为4*10=40次，而使用“零拷贝技术”只需要1+10=11次，一次为从磁盘复制到页面缓存，10次表示10个消费者各自读取一次页面缓存。 传统的文件拷贝通常需要从用户态去转到核心态，经过read buffer，然后再返回到用户态的应用层buffer，然后再从用户态把数据拷贝到核心态的socket buffer，然后发送到网卡。 传统的数据传输需要多次的用户态和核心态之间的切换，而且还要把数据复制多次，最终才打到网卡。 如果减少了用户态与核心态之间的切换，是不是就会更快了呢？ 此时我们会发现用户态“空空如也”。数据没有来到用户态，而是直接在核心态就进行了传输，但这样依然还是有多次复制。首先数据被读取到read buffer中，然后发到socket buffer，最后才发到网卡。虽然减少了用户态和核心态的切换，但依然存在多次数据复制。 如果可以进一步减少数据复制的次数，甚至没有数据复制是不是就会做到最快呢？ DMA 别急，这里我们先介绍一个新的武器:DMA。 DMA，全称叫Direct Memory Access，一种可让某些硬件子系统去直接访问系统主内存，而不用依赖CPU的计算机系统的功能。听着是不是很厉害，跳过CPU，直接访问主内存。传统的内存访问都需要通过CPU的调度来完成。如下图： 而DMA，则可以绕过CPU，硬件自己去直接访问系统主内存。如下图： 很多硬件都支持DMA，这其中就包括网卡。 零拷贝 回到本文中的文件传输，有了DMA后，就可以实现绝对的零拷贝了，因为网卡是直接去访问系统主内存的。如下图： Java的零拷贝实现 在Java中的零拷贝实现是在FileChannel中，其中有个方法transferTo(position,fsize,src)。 传统的文件传输是通过java.io.DataOutputStream，java.io.FileInputStream来实现的，然后通过while循环来读取input，然后写入到output中。 零拷贝则是通过java.nio.channels.FileChannel中的transferTo方法来实现的。transferTo方法底层是基于操作系统的sendfile这个system call来实现的（不再需要拷贝到用户态了），sendfile负责把数据从某个fd（file descriptor）传输到另一个fd。 sendfile： Java的transferTo： 传统方式与零拷贝性能对比 可以看出速度快出至少三倍多。Kafka在文件传输的过程中正是使用了零拷贝技术对文件进行拷贝。建议以后多用FileChannel的transferTo吧。 总结 传统的文件传输有多次用户态和内核态之间的切换，而且文件在多个buffer之间要复制多次最终才被发送到网卡。 DMA是一种硬件直接访问系统主内存的技术。 多种硬件都已使用了DMA技术，其中就包括网卡（NIC）。 DMA技术让CPU得到解放，让CPU可以不用一直守着来完成文件传输。 零拷贝技术减少了用户态与内核态之间的切换，让拷贝次数降到最低，从而实现高性能。 Kafka使用零拷贝技术来进行文件的传输。 zk在kafka中的作用Code12Kafka集群中有一个broker会被选举为Controller，负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。Controller的管理工作都是依赖于Zookeeper的。 Code12345每个broker都会在zk进行注册然后KafkaController会实时监听zk中的&#x2F;brokers&#x2F;ids下的节点情况[0,1,2]如果broker0宕机 ids中的节点会实时变化为[1,2]KafkaController会更新topic中的leader和isr队列KafkaController会获取当前可用的isr并从中选出新的leader kafka的消息发送流程是什么样的Code12345678910Kafka的Producer发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main线程和Sender线程，以及一个线程共享变量——RecordAccumulator(这个里面有分区)main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到Kafka broker。注意这里面 先走拦截器 再走序列化器 再走分区器达到batch.size大小或者是linger.ms时间就发到RecordAccumulator中sender线程去拉取 Code123相关参数：batch.size：只有数据积累到batch.size之后，sender才会发送数据。(默认16kb)linger.ms：如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据。 如何使用kafka API 实现异步消息发送准备知识需要用到的类： KafkaProducer：需要创建一个生产者对象，用来发送数据 ProducerConfig：获取所需的一系列配置参数 ProducerRecord：每条数据都要封装成一个ProducerRecord对象 几个比较重要的配置项 //kafka集群，broker-listprops.put(“bootstrap.servers”, “hadoop102:9092”); java1props.put(\"acks\", \"all\"); //重试次数 props.put(\"retries\", 1); //批次大小 props.put(\"batch.size\", 16384); //等待时间 props.put(\"linger.ms\", 1); //RecordAccumulator缓冲区大小 props.put(\"buffer.memory\", 33554432); props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); kafka集群位置 批次大小 批次等待时间 重试次数 缓冲区大小 序列化器(org\\apache\\kafka\\common\\serialization\\Serializer.java) properties12345678910111213141516171819202122232425262728293031323334org\\apache\\kafka\\clients\\producer\\ProducerConfig.javapublic static final String BOOTSTRAP_SERVERS_CONFIG = \"bootstrap.servers\";public static final String METADATA_MAX_AGE_CONFIG = \"metadata.max.age.ms\";public static final String BATCH_SIZE_CONFIG = \"batch.size\";public static final String ACKS_CONFIG = \"acks\";public static final String LINGER_MS_CONFIG = \"linger.ms\";public static final String CLIENT_ID_CONFIG = \"client.id\";public static final String SEND_BUFFER_CONFIG = \"send.buffer.bytes\";public static final String RECEIVE_BUFFER_CONFIG = \"receive.buffer.bytes\";public static final String MAX_REQUEST_SIZE_CONFIG = \"max.request.size\";public static final String RECONNECT_BACKOFF_MS_CONFIG = \"reconnect.backoff.ms\";public static final String RECONNECT_BACKOFF_MAX_MS_CONFIG = \"reconnect.backoff.max.ms\";public static final String MAX_BLOCK_MS_CONFIG = \"max.block.ms\";public static final String BUFFER_MEMORY_CONFIG = \"buffer.memory\";public static final String RETRY_BACKOFF_MS_CONFIG = \"retry.backoff.ms\";public static final String COMPRESSION_TYPE_CONFIG = \"compression.type\";public static final String METRICS_SAMPLE_WINDOW_MS_CONFIG = \"metrics.sample.window.ms\";public static final String METRICS_NUM_SAMPLES_CONFIG = \"metrics.num.samples\";public static final String METRICS_RECORDING_LEVEL_CONFIG = \"metrics.recording.level\";public static final String METRIC_REPORTER_CLASSES_CONFIG = \"metric.reporters\";public static final String MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION = \"max.in.flight.requests.per.connection\";public static final String RETRIES_CONFIG = \"retries\";public static final String KEY_SERIALIZER_CLASS_CONFIG = \"key.serializer\";public static final String VALUE_SERIALIZER_CLASS_CONFIG = \"value.serializer\";public static final String CONNECTIONS_MAX_IDLE_MS_CONFIG = \"connections.max.idle.ms\";public static final String PARTITIONER_CLASS_CONFIG = \"partitioner.class\";public static final String REQUEST_TIMEOUT_MS_CONFIG = \"request.timeout.ms\";public static final String INTERCEPTOR_CLASSES_CONFIG = \"interceptor.classes\";public static final String ENABLE_IDEMPOTENCE_CONFIG = \"enable.idempotence\";public static final String TRANSACTION_TIMEOUT_CONFIG = \"transaction.timeout.ms\";public static final String TRANSACTIONAL_ID_CONFIG = \"transactional.id\"; properties123456789101112131415161718192021222324252627282930313233343536373839org\\apache\\kafka\\clients\\consumer\\ConsumerConfig.javapublic static final String GROUP_ID_CONFIG = \"group.id\";public static final String MAX_POLL_RECORDS_CONFIG = \"max.poll.records\";public static final String MAX_POLL_INTERVAL_MS_CONFIG = \"max.poll.interval.ms\";public static final String SESSION_TIMEOUT_MS_CONFIG = \"session.timeout.ms\";public static final String HEARTBEAT_INTERVAL_MS_CONFIG = \"heartbeat.interval.ms\";public static final String BOOTSTRAP_SERVERS_CONFIG = \"bootstrap.servers\";public static final String ENABLE_AUTO_COMMIT_CONFIG = \"enable.auto.commit\";public static final String AUTO_COMMIT_INTERVAL_MS_CONFIG = \"auto.commit.interval.ms\";public static final String PARTITION_ASSIGNMENT_STRATEGY_CONFIG = \"partition.assignment.strategy\";public static final String AUTO_OFFSET_RESET_CONFIG = \"auto.offset.reset\";public static final String FETCH_MIN_BYTES_CONFIG = \"fetch.min.bytes\";public static final String FETCH_MAX_BYTES_CONFIG = \"fetch.max.bytes\";public static final int DEFAULT_FETCH_MAX_BYTES = 52428800;public static final String FETCH_MAX_WAIT_MS_CONFIG = \"fetch.max.wait.ms\";public static final String METADATA_MAX_AGE_CONFIG = \"metadata.max.age.ms\";public static final String MAX_PARTITION_FETCH_BYTES_CONFIG = \"max.partition.fetch.bytes\";public static final int DEFAULT_MAX_PARTITION_FETCH_BYTES = 1048576;public static final String SEND_BUFFER_CONFIG = \"send.buffer.bytes\";public static final String RECEIVE_BUFFER_CONFIG = \"receive.buffer.bytes\";public static final String CLIENT_ID_CONFIG = \"client.id\";public static final String RECONNECT_BACKOFF_MS_CONFIG = \"reconnect.backoff.ms\";public static final String RECONNECT_BACKOFF_MAX_MS_CONFIG = \"reconnect.backoff.max.ms\";public static final String RETRY_BACKOFF_MS_CONFIG = \"retry.backoff.ms\";public static final String METRICS_SAMPLE_WINDOW_MS_CONFIG = \"metrics.sample.window.ms\";public static final String METRICS_NUM_SAMPLES_CONFIG = \"metrics.num.samples\";public static final String METRICS_RECORDING_LEVEL_CONFIG = \"metrics.recording.level\";public static final String METRIC_REPORTER_CLASSES_CONFIG = \"metric.reporters\";public static final String CHECK_CRCS_CONFIG = \"check.crcs\";public static final String KEY_DESERIALIZER_CLASS_CONFIG = \"key.deserializer\";public static final String VALUE_DESERIALIZER_CLASS_CONFIG = \"value.deserializer\";public static final String CONNECTIONS_MAX_IDLE_MS_CONFIG = \"connections.max.idle.ms\";public static final String REQUEST_TIMEOUT_MS_CONFIG = \"request.timeout.ms\";public static final String INTERCEPTOR_CLASSES_CONFIG = \"interceptor.classes\";public static final String EXCLUDE_INTERNAL_TOPICS_CONFIG = \"exclude.internal.topics\";public static final boolean DEFAULT_EXCLUDE_INTERNAL_TOPICS = true;public static final String ISOLATION_LEVEL_CONFIG = \"isolation.level\";public static final String DEFAULT_ISOLATION_LEVEL; properties123456789101112131415161718org\\apache\\kafka\\clients\\CommonClientConfigs.javapublic static final String BOOTSTRAP_SERVERS_CONFIG = \"bootstrap.servers\";public static final String METADATA_MAX_AGE_CONFIG = \"metadata.max.age.ms\";public static final String SEND_BUFFER_CONFIG = \"send.buffer.bytes\";public static final String RECEIVE_BUFFER_CONFIG = \"receive.buffer.bytes\";public static final String CLIENT_ID_CONFIG = \"client.id\";public static final String RECONNECT_BACKOFF_MS_CONFIG = \"reconnect.backoff.ms\";public static final String RECONNECT_BACKOFF_MAX_MS_CONFIG = \"reconnect.backoff.max.ms\";public static final String RETRY_BACKOFF_MS_CONFIG = \"retry.backoff.ms\";public static final String METRICS_SAMPLE_WINDOW_MS_CONFIG = \"metrics.sample.window.ms\";public static final String METRICS_NUM_SAMPLES_CONFIG = \"metrics.num.samples\";public static final String METRICS_RECORDING_LEVEL_CONFIG = \"metrics.recording.level\";public static final String METRIC_REPORTER_CLASSES_CONFIG = \"metric.reporters\";public static final String SECURITY_PROTOCOL_CONFIG = \"security.protocol\";public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";public static final String CONNECTIONS_MAX_IDLE_MS_CONFIG = \"connections.max.idle.ms\";public static final String REQUEST_TIMEOUT_MS_CONFIG = \"request.timeout.ms\"; 不带回调的API java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.atguigu.kafka;import org.apache.kafka.clients.producer.*;import java.util.Properties;import java.util.concurrent.ExecutionException;public class CustomProducer &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Properties props = new Properties(); // 整个配置中的key可以使用ProducerConfig中定义的常量 //kafka集群，broker-list props.put(\"bootstrap.servers\", \"hadoop102:9092\"); props.put(\"acks\", \"all\"); //重试次数 props.put(\"retries\", 1); //批次大小 props.put(\"batch.size\", 16384); //等待时间 props.put(\"linger.ms\", 1); //RecordAccumulator缓冲区大小 props.put(\"buffer.memory\", 33554432); props.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); props.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); for (int i = 0; i &lt; 100; i++) &#123; producer.send(new ProducerRecord&lt;String, String&gt;(\"first\", Integer.toString(i), Integer.toString(i))); // 轮循 这个会用到分区器 producer.send(new ProducerRecord(\"second\",\"value++&gt;\"+i)); // 根据给的key进行hash 然后放在不同的分区 这个会使用到分区器 producer.send(new ProducerRecord(\"second\",\"key\"+i,\"value==&gt;\"+i)); // 具体指定了分区号 就不再使用到key 这个不会用到分区器 if(i&lt;5)&#123; producer.send(new ProducerRecord(\"second\",\"key\"+i,\"value**&gt;\"+i)); &#125;else&#123; producer.send(new ProducerRecord(\"second\",\"key\"+i,\"value^^&gt;\"+i)); &#125; &#125; producer.close(); &#125;&#125; java1234567891011121314151617181920212223242526272829303132// 分区器源码解读org\\apache\\kafka\\clients\\producer\\Partitioner.javapublic interface Partitioner extends Configurable, Closeable &#123; public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster); public void close();&#125;//唯一实现类org\\apache\\kafka\\clients\\producer\\internals\\DefaultPartitioner.javapublic class DefaultPartitioner implements Partitioner &#123; // 传进来的是topic key 还有序列化后的key value 序列化后的value public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123; List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic); int numPartitions = partitions.size(); //如果key是空的 后面的逻辑用了自增然后对分区取余 其实就是轮循 if (keyBytes == null) &#123; int nextValue = nextValue(topic); List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic); if (availablePartitions.size() &gt; 0) &#123; int part = Utils.toPositive(nextValue) % availablePartitions.size(); return availablePartitions.get(part).partition(); &#125; else &#123; // no partitions are available, give a non-available partition return Utils.toPositive(nextValue) % numPartitions; &#125; &#125; else &#123; // 如果key不是空的 将keyBytes传进去然后做hash murmur2是一种哈希算法 // hash the keyBytes to choose a partition return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; &#125; &#125;&#125; 带回调的API java123456跟上面不同的就是在使用send方法时候 带上一个回调函数 // 回调方法:当前消息发出后 不管是消息成功发送还是发送失败 都会执行该回调方法 // metadata 当前消息的元数据 // metadata能拿到当前分区的各种数据 如下图所示 // 偏移量 分区 主题 时间戳 等等 // exception 当消息发送失败 会返回该异常 java1234567// org\\apache\\kafka\\clients\\producer\\Callback.javapublic interface Callback &#123; public void onCompletion(RecordMetadata metadata, Exception exception);&#125;// 这是一个接口 里面有一个方法它有两个实现类 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 示例 带回调的APIpackage com.atguigu.kafka.producer;import org.apache.kafka.clients.producer.*;import java.util.Properties;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;public class MyCallBackProducer &#123; public static void main(String[] args) throws Exception &#123; //1. 创建配置对象 Properties props = new Properties(); //kafka集群的位置 props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop102:9092\"); //ack级别 props.put(ProducerConfig.ACKS_CONFIG,\"all\"); //重试次数 props.put(ProducerConfig.RETRIES_CONFIG,3); //批次大小 props.put(ProducerConfig.BATCH_SIZE_CONFIG,16384); //等待时间 props.put(ProducerConfig.LINGER_MS_CONFIG,1); //缓冲区大小 props.put(ProducerConfig.BUFFER_MEMORY_CONFIG,33554432); //k v 序列化器 props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringSerializer\"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringSerializer\"); //2. 创建生产者对象 KafkaProducer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(props); //3.生产数据 for (int i = 0; i &lt; 10000 ; i++) &#123; producer.send(new ProducerRecord&lt;&gt;(\"second\", \"atguigu@@@@@\" + i), new Callback() &#123; /** * 回调方法: 当前的消息发送出去以后，会执行回调方法。 * @param metadata 当前消息的元数据信息。 * @param exception 当发送失败，会返回异常。 */ @Override public void onCompletion(RecordMetadata metadata, Exception exception) &#123; if (exception == null) &#123; //发送成功 System.out.println(metadata.topic() + \" -- \" + metadata.partition() + \" -- \" + metadata.offset()); &#125; &#125; &#125;); &#125; // TimeUnit.MILLISECONDS.sleep(100); //关闭 producer.close(); &#125;&#125; kafka API中没有写producer.close()为什么读不到数据 也没有回调方法Code1234567891011这是因为异步发送消息的原因main线程在发送完数据之后就结束了 这个时间小于了批次拉取设置的时间1ms sender线程去拉取数据的同时需要执行main线程中的回调方法 但是现在main线程已经关闭 所以无法执行回调方法如果我们不写close方法 而是让main线程休眠100ms 这时sender就能在这个时间内拉取到数据并执行回调方法所以close方法肯定会等待sender线程拉取数据完成后再进行关闭具体实现可以看close()方法的源码 如下 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// org\\apache\\kafka\\clients\\producer\\KafkaProducer.java /** * Close this producer. This method blocks until all previously sent requests complete. * This method is equivalent to &lt;code&gt;close(Long.MAX_VALUE, TimeUnit.MILLISECONDS)&lt;/code&gt;. * &lt;p&gt; * &lt;strong&gt;If close() is called from &#123;@link Callback&#125;, a warning message will be logged and close(0, TimeUnit.MILLISECONDS) * will be called instead. We do this because the sender thread would otherwise try to join itself and * block forever.&lt;/strong&gt; * &lt;p&gt; * * @throws InterruptException If the thread is interrupted while blocked *///关闭此生产者。 此方法一直阻塞所有以前发送的请求完成。 此方法等效于close(Long.MAX_VALUE, TimeUnit.MILLISECONDS) 如果关闭（）被从调用Callback ，警告消息将被记录并关闭（0，TimeUnit.MILLISECONDS）将被代替调用。 我们这样做是因为发件人线程否则将尝试加入自己和永远阻塞。 @Override public void close() &#123; close(Long.MAX_VALUE, TimeUnit.MILLISECONDS); &#125; /** * This method waits up to &lt;code&gt;timeout&lt;/code&gt; for the producer to complete the sending of all incomplete requests. * &lt;p&gt; * If the producer is unable to complete all requests before the timeout expires, this method will fail * any unsent and unacknowledged records immediately. * &lt;p&gt; * If invoked from within a &#123;@link Callback&#125; this method will not block and will be equivalent to * &lt;code&gt;close(0, TimeUnit.MILLISECONDS)&lt;/code&gt;. This is done since no further sending will happen while * blocking the I/O thread of the producer. * * @param timeout The maximum time to wait for producer to complete any pending requests. The value should be * non-negative. Specifying a timeout of zero means do not wait for pending send requests to complete. * @param timeUnit The time unit for the &lt;code&gt;timeout&lt;/code&gt; * @throws InterruptException If the thread is interrupted while blocked * @throws IllegalArgumentException If the &lt;code&gt;timeout&lt;/code&gt; is negative. */// 这种方法最多等待timeout的生产者完成所有未完成的请求的发送。// 如果生产者是无法完成所有请求超时到期之前，此方法将立即失败任何未发送和未确认的记录。// 如果从内调用Callback此方法不会阻止和将等效于close(0, TimeUnit.MILLISECONDS) 这样做是因为同时阻断生产者的I/O线程没有进一步的发送会发生 @Override public void close(long timeout, TimeUnit timeUnit) &#123; close(timeout, timeUnit, false); &#125; private void close(long timeout, TimeUnit timeUnit, boolean swallowException) &#123; if (timeout &lt; 0) throw new IllegalArgumentException(\"The timeout cannot be negative.\"); log.info(\"Closing the Kafka producer with timeoutMillis = &#123;&#125; ms.\", timeUnit.toMillis(timeout)); // this will keep track of the first encountered exception AtomicReference&lt;Throwable&gt; firstException = new AtomicReference&lt;&gt;(); boolean invokedFromCallback = Thread.currentThread() == this.ioThread; if (timeout &gt; 0) &#123; if (invokedFromCallback) &#123; log.warn(\"Overriding close timeout &#123;&#125; ms to 0 ms in order to prevent useless blocking due to self-join. \" + \"This means you have incorrectly invoked close with a non-zero timeout from the producer call-back.\", timeout); &#125; else &#123; // Try to close gracefully. if (this.sender != null) this.sender.initiateClose(); if (this.ioThread != null) &#123; try &#123; this.ioThread.join(timeUnit.toMillis(timeout)); &#125; catch (InterruptedException t) &#123; firstException.compareAndSet(null, t); log.error(\"Interrupted while joining ioThread\", t); &#125; &#125; &#125; &#125; if (this.sender != null &amp;&amp; this.ioThread != null &amp;&amp; this.ioThread.isAlive()) &#123; log.info(\"Proceeding to force close the producer since pending requests could not be completed \" + \"within timeout &#123;&#125; ms.\", timeout); this.sender.forceClose(); // Only join the sender thread when not calling from callback. // 仅当不从回调调用时才加入发送者线程。 if (!invokedFromCallback) &#123; try &#123; this.ioThread.join(); &#125; catch (InterruptedException e) &#123; firstException.compareAndSet(null, e); &#125; &#125; &#125; ClientUtils.closeQuietly(interceptors, \"producer interceptors\", firstException); ClientUtils.closeQuietly(metrics, \"producer metrics\", firstException); ClientUtils.closeQuietly(keySerializer, \"producer keySerializer\", firstException); ClientUtils.closeQuietly(valueSerializer, \"producer valueSerializer\", firstException); ClientUtils.closeQuietly(partitioner, \"producer partitioner\", firstException); AppInfoParser.unregisterAppInfo(JMX_PREFIX, clientId); log.debug(\"The Kafka producer has closed.\"); if (firstException.get() != null &amp;&amp; !swallowException) throw new KafkaException(\"Failed to close kafka producer\", firstException.get()); &#125; 如何使用kafka API 实现同步消息发送Code12345678同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回ack。由于send方法返回的是一个Future对象，根据Futrue对象的特点，我们也可以实现同步发送的效果，只需在调用Future对象的get方法即可。区别就在于在send方法处拿到返回值future然后调用future中的get方法调用此方法就会阻塞当前线程 一直等到结果返回java\\util\\concurrent\\Future.java java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.atguigu.kafka.producer;import org.apache.kafka.clients.producer.*;import java.util.Properties;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;public class MyCallBackProducer &#123; public static void main(String[] args) throws Exception &#123; //1. 创建配置对象 Properties props = new Properties(); //kafka集群的位置 props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop102:9092\"); //ack级别 props.put(ProducerConfig.ACKS_CONFIG,\"all\"); //重试次数 props.put(ProducerConfig.RETRIES_CONFIG,3); //批次大小 props.put(ProducerConfig.BATCH_SIZE_CONFIG,16384); //等待时间 props.put(ProducerConfig.LINGER_MS_CONFIG,1); //缓冲区大小 props.put(ProducerConfig.BUFFER_MEMORY_CONFIG,33554432); //k v 序列化器 props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringSerializer\"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringSerializer\"); //2. 创建生产者对象 KafkaProducer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(props); //3.生产数据 for (int i = 0; i &lt; 10000 ; i++) &#123; Future&lt;RecordMetadata&gt; future = producer.send(new ProducerRecord&lt;&gt;(\"second\", \"atguigu@@@@@\" + i), new Callback() &#123; /** * 回调方法: 当前的消息发送出去以后，会执行回调方法。 * @param metadata 当前消息的元数据信息。 * @param exception 当发送失败，会返回异常。 */ @Override public void onCompletion(RecordMetadata metadata, Exception exception) &#123; if (exception == null) &#123; //发送成功 System.out.println(metadata.topic() + \" -- \" + metadata.partition() + \" -- \" + metadata.offset()); &#125; &#125; &#125;); // 发送一个之后阻塞线程等待返回结果才继续发送下一个 // 阻塞等待 ， 同步发送 // 此时会发现结果严格按照发送的顺序 RecordMetadata recordMetadata = future.get(); &#125; //关闭 producer.close(); &#125;&#125; kafka的分区器怎么写 如何自定义分区器 继承Partitioner 重写三个方法configure() partition() close() 可以根据传进的key分区 也可根据value分区 在定义好自己的分区器之后 还要再配置中添加分区器的全类名 否则会走默认的分区器 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051系统默认分区器public class DefaultPartitioner implements Partitioner &#123; private final ConcurrentMap&lt;String, AtomicInteger&gt; topicCounterMap = new ConcurrentHashMap&lt;&gt;(); public void configure(Map&lt;String, ?&gt; configs) &#123;&#125; /** * Compute the partition for the given record. * * @param topic The topic name * @param key The key to partition on (or null if no key) * @param keyBytes serialized key to partition on (or null if no key) * @param value The value to partition on or null * @param valueBytes serialized value to partition on or null * @param cluster The current cluster metadata */ public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123; List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic); int numPartitions = partitions.size(); if (keyBytes == null) &#123; int nextValue = nextValue(topic); List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic); if (availablePartitions.size() &gt; 0) &#123; int part = Utils.toPositive(nextValue) % availablePartitions.size(); return availablePartitions.get(part).partition(); &#125; else &#123; // no partitions are available, give a non-available partition return Utils.toPositive(nextValue) % numPartitions; &#125; &#125; else &#123; // hash the keyBytes to choose a partition return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions; &#125; &#125; private int nextValue(String topic) &#123; AtomicInteger counter = topicCounterMap.get(topic); if (null == counter) &#123; counter = new AtomicInteger(ThreadLocalRandom.current().nextInt()); AtomicInteger currentCounter = topicCounterMap.putIfAbsent(topic, counter); if (currentCounter != null) &#123; counter = currentCounter; &#125; &#125; return counter.getAndIncrement(); &#125; public void close() &#123;&#125;&#125; java1234567891011121314151617181920// 简单实现一个分区器public class MyPartitioner implements Partitioner &#123; public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123; if (key == null) &#123; // key为空 到0号分区 return 0; &#125; else &#123; // key不为空 到1号分区 return 1; &#125; &#125; public void close() &#123; &#125; public void configure(Map&lt;String, ?&gt; configs) &#123; &#125;&#125;// 如果要使用自己定义的分区器 要在配置中指定分区器并传入分区器的全类名props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,\"com.atguigu.kafka.partitioner.MyPartitioner\"); kafka的消费者需要注意的主要问题是什么Code12345Consumer消费数据时的可靠性是很容易保证的，因为数据在Kafka中是持久化的，故不用担心数据丢失问题。由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。所以offset的维护是Consumer消费数据是必须考虑的问题。 如何使用kafka API 实现消息接收(消费者)准备知识需要用到的类： KafkaConsumer：需要创建一个消费者对象，用来消费数据 ConsumerConfig：获取所需的一系列配置参数 ConsuemrRecord：每条数据都要封装成一个ConsumerRecord对象 为了使我们能够专注于自己的业务逻辑，Kafka提供了自动提交offset的功能。 自动提交offset的相关参数： enable.auto.commit：是否开启自动提交offset功能 auto.commit.interval.ms：自动提交offset的时间间隔 几个比较重要的配置项 自动提交offset功能 自动提交时间间隔 消费者组 反序列化器(对应生产者端的序列化org\\apache\\kafka\\common\\serialization\\Deserializer.java) 自动提交offsetjava123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package fun.hoffee.kafka.consumer;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;import java.util.Arrays;import java.util.Properties;/** * 消费者 */public class MyConsumer &#123; public static void main(String[] args) &#123; //1. 创建配置对象 Properties props = new Properties(); //指定kafka集群的位置 props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, \"hadoop102:9092\"); //开启自动提交offset //props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,true); //自动提交offset的间隔 props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, 1); //指定消费者组 props.put(ConsumerConfig.GROUP_ID_CONFIG, \"atguigu\"); //指定kv的反序列化器 props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringDeserializer\"); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringDeserializer\"); //2. 创建消费者对象 KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(props); //3. 订阅主题 consumer.subscribe(Arrays.asList(\"first\", \"second\", \"third\")); //4. 消费数据 while (true) &#123; ConsumerRecords&lt;String, String&gt; records = consumer.poll(1000); for (ConsumerRecord&lt;String, String&gt; record : records) &#123; System.out.println(record.topic() + \" -- \" + record.partition() + \" -- \" + record.offset() + \" -- \" + record.key() + \" -- \" + record.value()); &#125; &#125; &#125;&#125;// 此时创建的是新组 不能消费到之前的数据// 如果想要消费之前的数据 需要重置offset// 由auto.offset.rest参数(ConsumerConfig中的AUTO_OFFSET_RESET_CONFIG = \"auto.offset.reset\";)控制 默认值为latest// 可以配置为 earliest | latest | none---// 文档说明如下 :// What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server (e.g. because that data has been deleted): // earliest: automatically reset the offset to the earliest offset // latest: automatically reset the offset to the latest offset // none: throw exception to the consumer if no previous offset is found for the consumer's group // anything else: throw exception to the consumer.// 当Kafka中没有初始偏移量或服务器上不再存在当前偏移量时（例如，因为该数据已被删除），该怎么办：// 最早：自动将偏移量重置为最早的偏移量 // 最新：自动将偏移量重置为最新偏移量 // 无：如果未找到消费者组的先前偏移量，则向消费者抛出异常 // 其他：向消费者抛出异常// 人话: 如果这个是一个新的组 或者是 这个组拿了一个kafka中不存在的偏移量去消费数据时候 kafka就会自动帮忙重置offset 如果配置过这个参数 就按这个参数配置的来 如果没有配置过 默认重置为latest 重置offset 具体说明见上一节代码末尾 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.atguigu.kafka.consumer;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;import java.util.Arrays;import java.util.Properties;/** * 消费者 */public class MyConsumer &#123; public static void main(String[] args) &#123; //1. 创建配置对象 Properties props = new Properties(); //指定kafka集群的位置 props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop102:9092\"); //开启自动提交offset //props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,true); //关闭自动提交offset props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,false); //自动提交offset的间隔 props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,1); //重置offset : earliest(最早) latest(最后) //满足两个条件: // 1. 当前的消费者组在kafka没有消费过所订阅的主题 // 2.当前消费者组使用的offset在kafka集群中已经被删除 props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,\"earliest\"); //指定消费者组 props.put(ConsumerConfig.GROUP_ID_CONFIG,\"atguigu111\"); //指定kv的反序列化器 props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringDeserializer\"); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringDeserializer\"); //2. 创建消费者对象 KafkaConsumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(props); //3. 订阅主题 consumer.subscribe(Arrays.asList(\"first\",\"second\",\"third\")); //4. 消费数据 while(true)&#123; // 此处是拉取数据方法 poll中传递的参数是超时时间 当主题中没有数据时候 等待超时时间之后再进行拉取数据 // 假如某一次没有消费到数据 会等待响应的时间之后再进行拉取 单位是ms ConsumerRecords&lt;String, String&gt; records = consumer.poll(1000); for (ConsumerRecord&lt;String, String&gt; record : records) &#123; System.out.println(record.topic() + \" -- \" + record.partition() + \" -- \" + record.offset() +\" -- \" + record.key() +\" -- \" + record.value()); &#125; &#125; &#125;&#125; 手动提交offset的两种方式Code123456789101112虽然自动提交offset十分简介便利，但由于其是基于时间提交的，开发人员难以把握offset提交的时机。因此Kafka还提供了手动提交offset的API。手动提交offset的方法有两种：分别是commitSync（同步提交）和commitAsync（异步提交）。两者的相同点是，都会将本次poll的一批数据最高的偏移量提交；不同点是，commitSync阻塞当前线程，一直到提交成功，并且会自动失败重试（由不可控因素导致，也会出现提交失败）；而commitAsync则没有失败重试机制，故有可能提交失败。由于同步提交offset有失败重试机制，故更加可靠虽然同步提交offset更可靠一些，但是由于其会阻塞当前线程，直到提交成功。因此吞吐量会收到很大的影响。因此更多的情况下，会选用异步提交offset的方式。 Code12345如果关闭了提交offset 在一直没有关闭consumer的情况下 consumer能正常消费数据 因为consumer从kafka中拿到offset后会一直将offset维护在内存中但是一旦关闭 因为没有向kafka提交过offset 则offset还是之前的那么这段时间生产的数据将被重复消费 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.kafka.consumer;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;import java.util.Arrays;import java.util.Properties;/** * 消费者 */public class MyConsumer &#123; public static void main(String[] args) &#123; //1. 创建配置对象 Properties props = new Properties(); //指定kafka集群的位置 props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop102:9092\"); //开启自动提交offset //props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,true); //关闭自动提交offset props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,false); //自动提交offset的间隔 props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG,1); //重置offset : earliest(最早) latest(最后) //满足两个条件: 1. 当前的消费者组在kafka没有消费过所订阅的主题 2.当前消费者组使用的offset在kafka集群中已经被删除 props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,\"earliest\"); //指定消费者组 props.put(ConsumerConfig.GROUP_ID_CONFIG,\"atguigu111\"); //指定kv的反序列化器 props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringDeserializer\"); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringDeserializer\"); //2. 创建消费者对象 KafkaConsumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(props); //3. 订阅主题 consumer.subscribe(Arrays.asList(\"first\",\"second\",\"third\")); //4. 消费数据 while(true)&#123; // 此处是拉取数据方法 poll中传递的参数是超时时间 当主题中没有数据时候 等待超时时间之后再进行拉取数据 // 假如某一次没有消费到数据 会等待响应的时间之后再进行拉取 单位是ms ConsumerRecords&lt;String, String&gt; records = consumer.poll(1000); for (ConsumerRecord&lt;String, String&gt; record : records) &#123; System.out.println(record.topic() + \" -- \" + record.partition() + \" -- \" + record.offset() +\" -- \" + record.key() +\" -- \" + record.value()); &#125; //手动提交offset //同步提交 代码会阻塞 直到提交offset成功 才开始消费下一条数据 consumer.commitSync(); //阻塞 //异步提交 会触发提交offset的操作 但是会继续消费数据 不管offset是否提交成功 //consumer.commitAsync(); &#125; &#125;&#125; kafka中重复消费数据和漏消费数据的情况Code12345无论是同步提交还是异步提交offset，都有可能会造成数据的漏消费或者重复消费。先提交offset后消费，有可能造成数据的漏消费；而先消费后提交offset，有可能会造成数据的重复消费。 Code123456789这是offset的提交 和 消费数据 这两件事之间的先后顺序问题例1 : 消费者poll进100条数据 但是在消费到第60条时候宕机 但是offset已经提交 这时候 offset超前则后40条出现漏消费例2 :消费者poll进100条数据 但是offset在提交时候失败 但此时是先消费后提交offset的情况 这时候 offset滞后则这100条数据在下次启动时候会被重复消费 Code123456如何解决这个问题?将两件事情绑定在一起 如果失败则同时失败 如果成功则同时成功不允许出现一个失败一个成功的情况将两件事绑定为事务 kafka API 如何实现自定义存储offsetCode123456789Kafka 0.9版本之前，offset存储在zookeeper，0.9版本及之后，默认将offset存储在Kafka的一个内置的topic中。除此之外，Kafka还可以选择自定义存储offset。offset的维护是相当繁琐的，因为需要考虑到消费者的Rebalace。当有新的消费者加入消费者组、已有的消费者推出消费者组或者所订阅的主题的分区发生变化，就会触发到分区的重新分配，重新分配的过程叫做Rebalance。消费者发生Rebalance之后，每个消费者消费的分区就会发生变化。因此消费者要首先获取到自己被重新分配到的分区，并且定位到每个分区最近提交的offset位置继续消费。要实现自定义存储offset，需要借助ConsumerRebalanceListener，以下为示例代码，其中提交和获取offset的方法，需要根据所选的offset存储系统自行实现。 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.atguigu.kafka.consumer;import org.apache.kafka.clients.consumer.*;import org.apache.kafka.common.TopicPartition;import java.util.*;public class CustomConsumer &#123; private static Map&lt;TopicPartition, Long&gt; currentOffset = new HashMap&lt;&gt;();public static void main(String[] args) &#123; // 创建配置信息 Properties props = new Properties(); // Kafka集群 props.put(\"bootstrap.servers\", \"hadoop102:9092\"); // 消费者组，只要group.id相同，就属于同一个消费者组 props.put(\"group.id\", \"test\"); // 关闭自动提交offset props.put(\"enable.auto.commit\", \"false\"); // Key和Value的反序列化类 props.put(\"key.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\"); props.put(\"value.deserializer\", \"org.apache.kafka.common.serialization.StringDeserializer\"); // 创建一个消费者 KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props); // 消费者订阅主题 在订阅时候创建一个ConsumerRebalanceListener的对象实时监听 // 并重写两个方法onPartitionsRevoked 和 onPartitionsAssigned consumer.subscribe(Arrays.asList(\"first\"), new ConsumerRebalanceListener() &#123; //该方法会在Rebalance之前调用 @Override public void onPartitionsRevoked(Collection&lt;TopicPartition&gt; partitions) &#123; commitOffset(currentOffset); &#125; //该方法会在Rebalance之后调用 @Override public void onPartitionsAssigned(Collection&lt;TopicPartition&gt; partitions) &#123; currentOffset.clear(); for (TopicPartition partition : partitions) &#123; consumer.seek(partition, getOffset(partition)); //定位到最近提交的offset位置继续消费 &#125; &#125; &#125;); while (true) &#123; ConsumerRecords&lt;String, String&gt; records = consumer.poll(100); //消费者拉取数据 for (ConsumerRecord&lt;String, String&gt; record : records) &#123; System.out.printf(\"offset = %d, key = %s, value = %s%n\", record.offset(), record.key(), record.value()); currentOffset.put(new TopicPartition(record.topic(), record.partition()), record.offset()); &#125; commitOffset(currentOffset);//异步提交 &#125; &#125; //获取某分区的最新offset private static long getOffset(TopicPartition partition) &#123; return 0;// 这里是伪代码 需要根据具体存储的系统来实现 &#125; //提交该消费者所有分区的offset private static void commitOffset(Map&lt;TopicPartition, Long&gt; currentOffset) &#123; // 这里是伪代码 需要根据具体存储的系统来实现 &#125;&#125; kafka中的拦截器是如何实现的 原理是什么Code1234567891011121314Producer拦截器(interceptor)是在Kafka 0.10版本被引入的，主要用于实现clients端的定制化控制逻辑。对于producer而言，interceptor使得用户在消息发送前以及producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer允许用户指定多个interceptor按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor的实现接口是org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：（1）configure(configs)获取配置信息和初始化数据时调用。（2）onSend(ProducerRecord)：该方法封装进KafkaProducer.send方法中，即它运行在用户主线程中。Producer确保在消息被序列化以及计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区，否则会影响目标分区的计算。（3）onAcknowledgement(RecordMetadata, Exception)：该方法会在消息从RecordAccumulator成功发送到Kafka Broker之后，或者在发送过程中失败时调用。并且通常都是在producer回调逻辑触发之前。onAcknowledgement运行在producer的IO线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢producer的消息发送效率。（4）close：关闭interceptor，主要用于执行一些资源清理工作如前所述，interceptor可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外倘若指定了多个interceptor，则producer将按照指定顺序调用它们，并仅仅是捕获每个interceptor可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中要特别留意。 请实现一个kafka的拦截器需求： 实现一个简单的双interceptor组成的拦截链。第一个interceptor会在消息发送前将时间戳信息加到消息value的最前部；第二个interceptor会在消息发送后更新成功发送消息数或失败发送消息数。 分析: 时间拦截器 java12345678910111213141516171819202122232425262728293031323334353637383940package fun.hoffee.kafka.interceptor;import org.apache.kafka.clients.producer.ProducerInterceptor;import org.apache.kafka.clients.producer.ProducerRecord;import org.apache.kafka.clients.producer.RecordMetadata;import java.util.Map;/** * 在所有的消息内容前面加上时间戳 */public class TimeInterceptor implements ProducerInterceptor&lt;String, String&gt; &#123; @Override public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123; //获取当前消息的value String value = record.value(); value = System.currentTimeMillis() + \" -- \" + value; //构造一个producerRecord ProducerRecord&lt;String, String&gt; resultRecord = new ProducerRecord&lt;&gt;(record.topic(), record.partition(), record.key(), value); return resultRecord; &#125; @Override public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123; &#125; @Override public void close() &#123; &#125; @Override public void configure(Map&lt;String, ?&gt; configs) &#123; &#125;&#125; 计数拦截器 java123456789101112131415161718192021222324252627282930313233343536373839404142434445package fun.hoffee.kafka.interceptor;import org.apache.kafka.clients.producer.ProducerInterceptor;import org.apache.kafka.clients.producer.ProducerRecord;import org.apache.kafka.clients.producer.RecordMetadata;import java.util.Map;/** * 统计发送成功或失败的消息个数 */public class CountInterceptor implements ProducerInterceptor&lt;String, String&gt; &#123; private Integer success = 0; private Integer fail = 0; @Override public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123; // 相当于原路返回没有做处理 return record; &#125; @Override public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123; if (exception == null) &#123; success++; &#125; else &#123; fail++; &#125; &#125; @Override public void close() &#123; // 整个拦截器走完之后 调用该方法 System.out.println(\"Success : \" + success); System.out.println(\"Fail :\" + fail); &#125; @Override public void configure(Map&lt;String, ?&gt; configs) &#123; &#125;&#125; 在生产者的配置文件中配置拦截器(可设置多个 设置为一个list) java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package fun.hoffee.kafka.interceptor;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.ProducerConfig;import org.apache.kafka.clients.producer.ProducerRecord;import java.util.ArrayList;import java.util.List;import java.util.Properties;public class InterceptorProducer &#123; public static void main(String[] args) &#123; //1. 创建配置对象 Properties props = new Properties(); //指定kafka集群的位置，broker-list props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"hadoop102:9092\"); //指定ack的应答级别 0 1 -1(all) props.put(ProducerConfig.ACKS_CONFIG, \"all\"); //重试次数 props.put(ProducerConfig.RETRIES_CONFIG, 5); //批次大小 props.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384); // 16kb //等待时间 props.put(ProducerConfig.LINGER_MS_CONFIG, 1); //RecordAccumulator缓冲区大小 props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, 33554432); // 32M //指定kv的序列化器 props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringSerializer\"); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, \"org.apache.kafka.common.serialization.StringSerializer\"); //指定拦截器 // \"A list of classes to use as interceptors. Implementing the &lt;code&gt;ProducerInterceptor&lt;/code&gt; interface allows you to intercept (and possibly mutate) the records received by the producer before they are published to the Kafka cluster. By default, there are no interceptors.\"; List&lt;String&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.add(\"com.atguigu.kafka.interceptor.TimeInterceptor\"); interceptors.add(\"com.atguigu.kafka.interceptor.CountInterceptor\"); props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors); //2. 创建生产者对象 KafkaProducer producer = new KafkaProducer&lt;String, String&gt;(props); //3. 生产数据 for (int i = 0; i &lt; 10; i++) &#123; producer.send(new ProducerRecord(\"second\", \"shangguigu==&gt;\" + i)); &#125; //4. 关闭 producer.close(); &#125;&#125; flume如何对接kafkaCode123使用kafkasink此时kafkasink相当于kafka的生产者 它可以根据消息的标记发送给kafka中不同的topic flume官网关于kafka sink的介绍如下 这是一个Flume Sink实现，可以将数据发布到 Kafka主题。目标之一是将Flume与Kafka集成在一起，以便基于拉式的处理系统可以处理来自各种Flume来源的数据。目前，该版本支持Kafka 0.9.x系列发行版。 此版本的Flume不再支持Kafka的旧版本（0.8.x）。 必需的属性以粗体标记。 Property Name Default Description type – Must be set to org.apache.flume.sink.kafka.KafkaSink kafka.bootstrap.servers – List of brokers Kafka-Sink will connect to, to get the list of topic partitions This can be a partial list of brokers, but we recommend at least two for HA. The format is comma separated list of hostname:port Kafka-Sink将连接到的代理列表，以获取主题分区列表。这可以是部分代理列表，但是对于HA，我们建议至少两个。格式是用逗号分隔的主机名：端口列表 kafka.topic default-flume-topic The topic in Kafka to which the messages will be published. If this parameter is configured, messages will be published to this topic. If the event header contains a “topic” field, the event will be published to that topic overriding the topic configured here. Kafka中将发布消息的主题。如果配置了此参数，则消息将发布到该主题。如果事件标题包含“主题”字段，则事件将发布到该主题，并覆盖此处配置的主题。 flumeBatchSize 100 How many messages to process in one batch. Larger batches improve throughput while adding latency. 一批中要处理多少条消息。较大的批次可提高吞吐量，同时增加延迟。 kafka.producer.acks 1 How many replicas must acknowledge a message before its considered successfully written. Accepted values are 0 (Never wait for acknowledgement), 1 (wait for leader only), -1 (wait for all replicas) Set this to -1 to avoid data loss in some cases of leader failure. 在成功考虑一条消息之前，有多少个副本必须确认一条消息。接受的值为0（永远不等待确认），1（仅等待领导者），-1（等待所有副本）将其设置为-1，以避免在某些领导者失败的情况下丢失数据。 useFlumeEventFormat false By default events are put as bytes onto the Kafka topic directly from the event body. Set to true to store events as the Flume Avro binary format. Used in conjunction with the same property on the KafkaSource or with the parseAsFlumeEvent property on the Kafka Channel this will preserve any Flume headers for the producing side. 默认情况下，事件直接从事件主体作为字节放入Kafka主题。设置为true可将事件存储为Flume Avro二进制格式。与KafkaSource上的相同属性或Kafka Channel上的parseAsFlumeEvent属性结合使用，将为生产方保留任何Flume标头。 defaultPartitionId – Specifies a Kafka partition ID (integer) for all events in this channel to be sent to, unless overriden by partitionIdHeader. By default, if this property is not set, events will be distributed by the Kafka Producer’s partitioner - including by key if specified (or by a partitioner specified by kafka.partitioner.class). partitionIdHeader – When set, the sink will take the value of the field named using the value of this property from the event header and send the message to the specified partition of the topic. If the value represents an invalid partition, an EventDeliveryException will be thrown. If the header value is present then this setting overrides defaultPartitionId. kafka.producer.security.protocol PLAINTEXT Set to SASL_PLAINTEXT, SASL_SSL or SSL if writing to Kafka using some level of security. See below for additional info on secure setup. more producer security props If using SASL_PLAINTEXT, SASL_SSL or SSL refer to Kafka security for additional properties that need to be set on producer. Other Kafka Producer Properties – These properties are used to configure the Kafka Producer. Any producer property supported by Kafka can be used. The only requirement is to prepend the property name with the prefix kafka.producer. For example: kafka.producer.linger.ms The Kafka sink also provides defaults for the key.serializer(org.apache.kafka.common.serialization.StringSerializer) and value.serializer(org.apache.kafka.common.serialization.ByteArraySerializer). Modification of these parameters is not recommended. An example configuration of a Kafka sink is given below. Properties starting with the prefix kafka.producer the Kafka producer. The properties that are passed when creating the Kafka producer are not limited to the properties given in this example. Also it is possible to include your custom properties here and access them inside the preprocessor through the Flume Context object passed in as a method argument. 示例配置如下: Code12345678a1.sinks.k1.channel &#x3D; c1a1.sinks.k1.type &#x3D; org.apache.flume.sink.kafka.KafkaSinka1.sinks.k1.kafka.topic &#x3D; mytopic &#x2F;&#x2F; 指定写入topica1.sinks.k1.kafka.bootstrap.servers &#x3D; localhost:9092 &#x2F;&#x2F; kafka位置a1.sinks.k1.kafka.flumeBatchSize &#x3D; 20a1.sinks.k1.kafka.producer.acks &#x3D; 1a1.sinks.k1.kafka.producer.linger.ms &#x3D; 1a1.sinks.ki.kafka.producer.compression.type &#x3D; snappy 实现flume中不同的event发往kafka中不同的topic 如何监控kafkakafka面试题总结1.Kafka中的ISR、OSR、AR又代表什么？ ISR：与leader保持同步的follower集合AR：分区的所有副本 2.Kafka中的HW、LEO等分别代表什么？ LEO：没个副本的最后条消息的offsetHW：一个分区中所有副本最小的offset 控制整个分区中哪些数据能够暴露给消费者 3.Kafka中是怎么体现消息顺序性的？ 每个分区内，每条消息都有一个offset，故只能保证分区内有序。 4.Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？ 拦截器 -&gt; 序列化器 -&gt; 分区器 5.Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？ 6.“消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？ 正确 7.消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1？ offset+1 记录下次消费的数据的offset 8.有哪些情形会造成重复消费？ 9.有哪些情景会造成消息漏消费？ 先提交offset，后消费，有可能造成数据的重复 10.当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？ 1）会在zookeeper中的/brokers/topics节点下创建一个新的topic节点，如：/brokers/topics/first 2）触发Controller的监听程序 3）kafka Controller 负责topic的创建工作，并更新metadata cache 11.topic的分区数可不可以增加？如果可以怎么增加？如果不可以，那又是为什么？ 可以增加 bin/kafka-topics.sh –zookeeper localhost:2181/kafka –alter –topic topic-config –partitions 3 12.topic的分区数可不可以减少？如果可以怎么减少？如果不可以，那又是为什么？ 不可以减少，现有的分区数据难以处理。 13.Kafka有内部的topic吗？如果有是什么？有什么所用？ __consumer_offsets, 共有50个分区 保存消费者offset 14.Kafka分区分配的概念？ 一个topic多个分区，一个消费者组多个消费者，故需要将分区分配个消费者(roundrobin、range) 15.简述Kafka的日志目录结构？ 每个分区对应一个文件夹，文件夹的命名为topic-0，topic-1，内部为.log和.index文件 16.如果我指定了一个offset，Kafka Controller怎么查找到对应的消息？ 先通过offset比对log文件的名字 确定好后 再找到对应的index文件中offset对应的消息索引位置 最后在log文件中找到相应的消息 17.聊一聊Kafka Controller的作用？ 负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。 18.Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？ partition leader（ISR），由Controller负责 Controller（先到先得） 19.失效副本是指什么？有那些应对措施？ 不能及时与leader同步，暂时踢出ISR，等其追上leader之后再重新加入 20.Kafka的那些设计让它有如此高的性能？ 分区，顺序写磁盘，0-copy 其他kafka相关面试题搜集(一)1、请说明什么是Apache Kafka? Apache Kafka是由Apache开发的一种发布订阅消息系统，它是一个分布式的、分区的和可复制的提交日志服务。 2、说说Kafka的使用场景？ ①异步处理②应用解耦③流量削峰④日志处理⑤消息通讯等。 3、使用Kafka有什么优点和缺点？ 优点：①支持跨数据中心的消息复制；②单机吞吐量：十万级，最大的优点，就是吞吐量高;③topic数量都吞吐量的影响：topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源;④时效性：ms级;⑤可用性：非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用;⑥消息可靠性：经过参数优化配置，消息可以做到0丢失;⑦功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用。 缺点：①由于是批量发送，数据并非真正的实时； 仅支持统一分区内消息有序，无法实现全局消息有序；②有可能消息重复消费；③依赖zookeeper进行元数据管理，等等。 4、为什么说Kafka性能很好，体现在哪里？ ①顺序读写②零拷贝③分区④批量发送⑤数据压缩 5、请说明什么是传统的消息传递方法? 传统的消息传递方法包括两种：排队：在队列中，一组用户可以从服务器中读取消息，每条消息都发送给其中一个人。发布-订阅：在这个模型中，消息被广播给所有的用户。 6、请说明Kafka相对传统技术有什么优势? ①快速:单一的Kafka代理可以处理成千上万的客户端，每秒处理数兆字节的读写操作。②可伸缩:在一组机器上对数据进行分区③和简化，以支持更大的数据④持久:消息是持久性的，并在集群中进⑤行复制，以防止数据丢失。⑥设计:它提供了容错保证和持久性 7、解释Kafka的Zookeeper是什么?我们可以在没有Zookeeper的情况下使用Kafka吗? Zookeeper是一个开放源码的、高性能的协调服务，它用于Kafka的分布式应用。不，不可能越过Zookeeper，直接联系Kafka broker。一旦Zookeeper停止工作，它就不能服务客户端请求。Zookeeper主要用于在集群中不同节点之间进行通信在Kafka中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都可以从之前提交的偏移量中获取除此之外，它还执行其他活动，如: leader检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态等等。 8、解释Kafka的用户如何消费信息? 在Kafka中传递消息是通过使用sendfile API完成的。它支持将字节从套接口转移到磁盘，通过内核空间保存副本，并在内核用户之间调用内核。 9、解释如何提高远程用户的吞吐量? 如果用户位于与broker不同的数据中心，则可能需要调优套接口缓冲区大小，以对长网络延迟进行摊销。 10、解释一下，在数据制作过程中，你如何能从Kafka得到准确的信息? 在数据中，为了精确地获得Kafka的消息，你必须遵循两件事: 在数据消耗期间避免重复，在数据生产过程中避免重复。 这里有两种方法，可以在数据生成时准确地获得一个语义: 每个分区使用一个单独的写入器，每当你发现一个网络错误，检查该分区中的最后一条消息，以查看您的最后一次写入是否成功 在消息中包含一个主键(UUID或其他)，并在用户中进行反复制 11、解释如何减少ISR中的扰动?broker什么时候离开ISR? ISR是一组与leaders完全同步的消息副本，也就是说ISR中包含了所有提交的消息。ISR应该总是包含所有的副本，直到出现真正的故障。如果一个副本从leader中脱离出来，将会从ISR中删除。 12、Kafka为什么需要复制? Kafka的信息复制确保了任何已发布的消息不会丢失，并且可以在机器错误、程序错误或更常见些的软件升级中使用。 13、如果副本在ISR中停留了很长时间表明什么? 如果一个副本在ISR中保留了很长一段时间，那么它就表明，跟踪器无法像在leader收集数据那样快速地获取数据。 14、请说明如果首选的副本不在ISR中会发生什么? 如果首选的副本不在ISR中，控制器将无法将leadership转移到首选的副本。 15、有可能在生产后发生消息偏移吗? 在大多数队列系统中，作为生产者的类无法做到这一点，它的作用是触发并忘记消息。broker将完成剩下的工作，比如使用id进行适当的元数据处理、偏移量等。 作为消息的用户，你可以从Kafka broker中获得补偿。如果你注视SimpleConsumer类，你会注意到它会获取包括偏移量作为列表的MultiFetchResponse对象。此外，当你对Kafka消息进行迭代时，你会拥有包括偏移量和消息发送的MessageAndOffset对象。 16、Kafka的设计时什么样的呢？ Kafka将消息以topic为单位进行归纳 将向Kafka topic发布消息的程序成为producers. 将订阅了topics并消费消息的程序成为consumer. Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个broker. producers通过网络将消息发送到Kafka集群，集群向消费者提供消息 17、数据传输的事务定义有哪三种？ （1）最多一次:消息不会被重复发送，最多被传输一次，但也有可能一次不传输（2）最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.（3）精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被一次而且仅仅被传输一次，这是大家所期望的 18、Kafka判断一个节点是否还活着有那两个条件？ （1）节点必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个节点的连接（2）如果节点是个follower,他必须能及时的同步leader的写操作，延时不能太久 19、producer是否直接将数据发送到broker的leader(主节点)？ producer直接将数据发送到broker的leader(主节点)，不需要在多个节点进行分发，为了帮助producer做到这点，所有的Kafka节点都可以及时的告知:哪些节点是活动的，目标topic目标分区的leader在哪。这样producer就可以直接将消息发送到目的地了。 20、Kafa consumer是否可以消费指定分区消息？ Kafa consumer消费消息时，向broker发出”fetch”请求去消费特定分区的消息，consumer指定消息在日志中的偏移量（offset），就可以消费从这个位置开始的消息，customer拥有了offset的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的 21、Kafka消息是采用Pull模式，还是Push模式？ Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息一些消息系统比如Scribe和Apache Flume采用了push模式，将消息推送到下游的consumer。这样做有好处也有坏处：由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。消息系统都致力于让consumer以最大的速率最快速的消费消息，但不幸的是，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。最终Kafka还是选取了传统的pull模式 Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略 Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到t达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发 22、Kafka存储在硬盘上的消息格式是什么？ 消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和CRC32校验码。消息长度: 4 bytes (value: 1+4+n)版本号: 1 byteCRC校验码: 4 bytes具体的消息: n bytes 23、Kafka高效文件存储设计特点： (1).Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。(2).通过索引信息可以快速定位message和确定response的最大大小。(3).通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。(4).通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。 24、Kafka 与传统消息系统之间有三个关键区别 (1).Kafka 持久化日志，这些日志可以被重复读取和无限期保留(2).Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性(3).Kafka 支持实时的流式处理 25、Kafka创建Topic时如何将分区放置到不同的Broker中 副本因子不能大于 Broker 的个数；第一个分区（编号为0）的第一个副本放置位置是随机从 brokerList 选择的；其他分区的第一个副本放置位置相对于第0个分区依次往后移。也就是如果我们有5个 Broker，5个分区，假设第一个分区放在第四个 Broker 上，那么第二个分区将会放在第五个 Broker 上；第三个分区将会放在第一个 Broker 上；第四个分区将会放在第二个 Broker 上，依次类推；剩余的副本相对于第一个副本放置位置其实是由 nextReplicaShift 决定的，而这个数也是随机产生的 26、Kafka新建的分区会在哪个目录下创建 在启动 Kafka 集群之前，我们需要配置好 log.dirs 参数，其值是 Kafka 数据的存放目录，这个参数可以配置多个目录，目录之间使用逗号分隔，通常这些目录是分布在不同的磁盘上用于提高读写性能。 当然我们也可以配置 log.dir 参数，含义一样。只需要设置其中一个即可。 如果 log.dirs 参数只配置了一个目录，那么分配到各个 Broker 上的分区肯定只能在这个目录下创建文件夹用于存放数据。 但是如果 log.dirs 参数配置了多个目录，那么 Kafka 会在哪个文件夹中创建分区目录呢？答案是：Kafka 会在含有分区目录最少的文件夹中创建新的分区目录，分区目录名为 Topic名+分区ID。注意，是分区文件夹总数最少的目录，而不是磁盘使用量最少的目录！也就是说，如果你给 log.dirs 参数新增了一个新的磁盘，新的分区目录肯定是先在这个新的磁盘上创建直到这个新的磁盘目录拥有的分区目录不是最少为止。 27、partition的数据如何保存到硬盘 topic中的多个partition以文件夹的形式保存到broker，每个分区序号从0递增， 且消息有序 Partition文件下有多个segment（xxx.index，xxx.log） segment 文件里的 大小和配置文件大小一致可以根据要求修改 默认为1g 如果大小大于1g时，会滚动一个新的segment并且以上一个segment最后一条消息的偏移量命名 28、kafka的ack机制 request.required.acks有三个值 0 1 -10:生产者不会等待broker的ack，这个延迟最低但是存储的保证最弱当server挂掉的时候就会丢数据1：服务端会等待ack值 leader副本确认接收到消息后发送ack但是如果leader挂掉后他不确保是否复制完成新leader也会导致数据丢失-1：同样在1的基础上 服务端会等所有的follower的副本受到数据后才会受到leader发出的ack，这样数据不会丢失 29、Kafka的消费者如何消费数据 消费者每次消费数据的时候，消费者都会记录消费的物理偏移量（offset）的位置 等到下次消费时，他会接着上次位置继续消费。同时也可以按照指定的offset进行重新消费。 30、消费者负载均衡策略 结合consumer的加入和退出进行再平衡策略。 31、kafka消息数据是否有序？ 消费者组里某具体分区是有序的，所以要保证有序只能建一个分区，但是实际这样会存在性能问题，具体业务具体分析后确认。 32、kafaka生产数据时数据的分组策略,生产者决定数据产生到集群的哪个partition中 每一条消息都是以（key，value）格式 Key是由生产者发送数据传入 所以生产者（key）决定了数据产生到集群的哪个partition 33、kafka consumer 什么情况会触发再平衡reblance? ①一旦消费者加入或退出消费组，导致消费组成员列表发生变化，消费组中的所有消费者都要执行再平衡。②订阅主题分区发生变化，所有消费者也都要再平衡。 34、描述下kafka consumer 再平衡步骤? ①关闭数据拉取线程，清空队列和消息流，提交偏移量；②释放分区所有权，删除zk中分区和消费者的所有者关系；③将所有分区重新分配给每个消费者，每个消费者都会分到不同分区；④将分区对应的消费者所有关系写入ZK，记录分区的所有权信息；⑤重启消费者拉取线程管理器，管理每个分区的拉取线程。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"大数据/kafka","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"kafka","permalink":"https://masteryang4.github.io/tags/kafka/"}]},{"title":"spark系列之spark-sql","slug":"spark系列之spark-sql","date":"2020-06-18T04:25:47.000Z","updated":"2020-06-18T05:11:28.375Z","comments":true,"path":"2020/06/18/spark系列之spark-sql/","link":"","permalink":"https://masteryang4.github.io/2020/06/18/spark%E7%B3%BB%E5%88%97%E4%B9%8Bspark-sql/","excerpt":"","text":"SparkSQL概述简介Spark SQL是Spark用于结构化数据(structured data)处理的Spark模块 Hive与SparkSQL其中SparkSQL作为Spark生态的一员继续发展，而不再受限于Hive，只是兼容Hive； 而Hive on Spark是一个Hive的发展计划，该计划将Spark作为Hive的底层引擎之一，也就是说，Hive将不再受限于一个引擎，可以采用Map-Reduce、Tez、Spark等引擎。 Spark SQL为了简化RDD的开发，提高开发效率，提供了2个编程抽象，类似Spark Core中的RDD DataFrame DataSet DataFrame简介在Spark中，DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表格。DataFrame与RDD的主要区别在于，前者带有schema元信息，即DataFrame所表示的二维表数据集的每一列都带有名称和类型。这使得Spark SQL得以洞察更多的结构信息，从而对藏于DataFrame背后的数据源以及作用于DataFrame之上的变换进行了针对性的优化，最终达到大幅提升运行时效率的目标。反观RDD，由于无从得知所存数据元素的具体内部结构，Spark Core只能在stage层面进行简单、通用的流水线优化。 同时，与Hive类似，DataFrame也支持嵌套数据类型（struct、array和map）。从 API 易用性的角度上看，DataFrame API提供的是一套高层的关系操作，比函数式的RDD API 要更加友好，门槛更低。 上图直观地体现了DataFrame和RDD的区别。 左侧的RDD[Person]虽然以Person为类型参数，但Spark框架本身不了解Person类的内部结构。而右侧的DataFrame却提供了详细的结构信息，使得 Spark SQL 可以清楚地知道该数据集中包含哪些列，每列的名称和类型各是什么。 DataFrame是为数据提供了Schema的视图。可以把它当做数据库中的一张表来对待 DataFrame也是懒执行的，但性能上比RDD要高，主要原因：优化的执行计划，即查询计划通过Spark catalyst optimiser进行优化 DataSet简介DataSet是分布式数据集合。DataSet是Spark 1.6中添加的一个新抽象，是DataFrame的一个扩展。它提供了RDD的优势（强类型，使用强大的lambda函数的能力）以及Spark SQL优化执行引擎的优点。DataSet也可以使用功能性的转换（操作map，flatMap，filter等等）。 DataSet是DataFrame API的一个扩展，是SparkSQL最新的数据抽象 用户友好的API风格，既具有类型安全检查也具有DataFrame的查询优化特性； 用样例类来对DataSet中定义数据的结构信息，样例类中每个属性的名称直接映射到DataSet中的字段名称； DataSet是强类型的。比如可以有DataSet[Car]，DataSet[Person]。 DataFrame是DataSet的特列，DataFrame=DataSet[Row] ，所以可以通过as方法将DataFrame转换为DataSet。Row是一个类型，跟Car、Person这些的类型一样，所有的表结构信息都用Row来表示。获取数据时需要指定顺序 SparkSQL核心编程Spark Core中，如果想要执行应用程序，需要首先构建上下文环境对象SparkContext，Spark SQL其实可以理解为对Spark Core的一种封装，不仅仅在模型上进行了封装，上下文环境对象也进行了封装。 SparkSession是Spark最新的SQL查询起始点，SparkSession内部封装了SparkContext，所以计算实际上是由sparkContext完成的。 DataFrameSpark SQL的DataFrame API 允许我们使用 DataFrame 而不用必须去注册临时表或者生成 SQL 表达式。DataFrame API 既有 transformation操作也有action操作。 创建df在Spark SQL中SparkSession是创建DataFrame和执行SQL的入口，创建DataFrame有三种方式：通过Spark的数据源进行创建；从一个存在的RDD进行转换；还可以从Hive Table进行查询返回。 1、 从Spark数据源进行创建 读取json文件创建DataFrame scala12scala&gt; val df = spark.read.json(\"data/user.json\")df: org.apache.spark.sql.DataFrame = [age: bigint， username: string] 2、从RDD进行转换 3、从Hive Table进行查询返回 SQL语法SQL语法风格是指我们查询数据的时候使用SQL语句来查询，这种风格的查询必须要有临时视图或者全局视图来辅助 scala12345678910111213scala&gt; val df = spark.read.json(\"data/user.json\")df: org.apache.spark.sql.DataFrame = [age: bigint， username: string]scala&gt; df.createOrReplaceTempView(\"people\")scala&gt; val sqlDF = spark.sql(\"SELECT * FROM people\")sqlDF: org.apache.spark.sql.DataFrame = [age: bigint， name: string]scala&gt; sqlDF.show+---+--------+|age|username|+---+--------+| 20|zhangsan|| 30| lisi|| 40| wangwu|+---+--------+ 注意：普通临时表是Session范围内的，如果想应用范围内有效，可以使用全局临时表。 使用全局临时表时需要全路径访问，如：global_temp.people scala123456789101112131415161718scala&gt; df.createGlobalTempView(\"people\")scala&gt; spark.sql(\"SELECT * FROM global_temp.people\").show()+---+--------+|age|username|+---+--------+| 20|zhangsan|| 30| lisi|| 40| wangwu|+---+--------+scala&gt; spark.newSession().sql(\"SELECT * FROM global_temp.people\").show()+---+--------+|age|username|+---+--------+| 20|zhangsan|| 30| lisi|| 40| wangwu|+---+--------+ DSL语法DataFrame提供一个特定领域语言(domain-specific language, DSL)去管理结构化的数据。可以在 Scala, Java, Python 和 R 中使用 DSL，使用 DSL 语法风格不必去创建临时视图了 scala1234567891011121314151617181920212223242526272829303132333435363738394041424344scala&gt; val df = spark.read.json(\"data/user.json\")df: org.apache.spark.sql.DataFrame = [age: bigint， name: string]scala&gt; df.printSchemaroot |-- age: Long (nullable = true) |-- username: string (nullable = true)scala&gt; df.select(\"username\").show()+--------+|username|+--------+|zhangsan|| lisi|| wangwu|+--------+scala&gt; df.select($\"username\",$\"age\" + 1).showscala&gt; df.select('username, 'age + 1).show()scala&gt; df.select('username, 'age + 1 as \"newage\").show()+--------+---------+|username|(age + 1)|+--------+---------+|zhangsan| 21|| lisi| 31|| wangwu| 41|+--------+---------+scala&gt; df.filter($\"age\"&gt;30).show+---+---------+|age| username|+---+---------+| 40| wangwu|+---+---------+scala&gt; df.groupBy(\"age\").count.show+---+-----+|age|count|+---+-----+| 20| 1|| 30| 1|| 40| 1|+---+-----+ RDD转换为DataFrame在IDEA中开发程序时，如果需要RDD与DF或者DS之间互相操作，那么需要引入 import spark.implicits._ 这里的spark不是Scala中的包名，而是创建的sparkSession对象的变量名称，所以必须先创建SparkSession对象再导入。这里的spark对象不能使用var声明，因为Scala只支持val修饰的对象的引入。 scala12345678910scala&gt; val idRDD = sc.textFile(\"data/id.txt\")scala&gt; idRDD.toDF(\"id\").show+---+| id|+---+| 1|| 2|| 3|| 4|+---+ 实际开发中，一般通过样例类将RDD转换为DataFrame scala123456789scala&gt; case class User(name:String, age:Int)defined class Userscala&gt; sc.makeRDD(List((\"zhangsan\",30), (\"lisi\",40))).map(t=&gt;User(t._1, t._2)).toDF.show+--------+---+| name|age|+--------+---+|zhangsan| 30|| lisi| 40|+--------+---+ DataFrame转换为RDDDataFrame其实就是对RDD的封装，所以可以直接获取内部的RDD scala12345678scala&gt; val df = sc.makeRDD(List((\"zhangsan\",30), (\"lisi\",40))).map(t=&gt;User(t._1, t._2)).toDFdf: org.apache.spark.sql.DataFrame = [name: string, age: int]scala&gt; val rdd = df.rddrdd: org.apache.spark.rdd.RDD[org.apache.spark.sql.Row] = MapPartitionsRDD[46] at rdd at &lt;console&gt;:25scala&gt; val array = rdd.collectarray: Array[org.apache.spark.sql.Row] = Array([zhangsan,30], [lisi,40]) 注意：此时得到的RDD存储类型为Row scala123456scala&gt; array(0)res28: org.apache.spark.sql.Row = [zhangsan,30]scala&gt; array(0)(0)res29: Any = zhangsanscala&gt; array(0).getAs[String](\"name\")res30: String = zhangsan DataSetDataSet是具有强类型的数据集合，需要提供对应的类型信息。 创建DataSet1、使用样例类序列创建DataSet scala12345678910111213scala&gt; case class Person(name: String, age: Long)defined class Personscala&gt; val caseClassDS = Seq(Person(\"zhangsan\",2)).toDS()caseClassDS: org.apache.spark.sql.Dataset[Person] = [name: string, age: Long]scala&gt; caseClassDS.show+---------+---+| name|age|+---------+---+| zhangsan| 2|+---------+---+ 2、使用基本类型的序列创建DataSet scala12345678910111213scala&gt; val ds = Seq(1,2,3,4,5).toDSds: org.apache.spark.sql.Dataset[Int] = [value: int]scala&gt; ds.show+-----+|value|+-----+| 1|| 2|| 3|| 4|| 5|+-----+ 注意：在实际使用的时候，很少用到把序列转换成DataSet，更多的是通过RDD来得到DataSet RDD转换为DataSetSparkSQL能够自动将包含有case类的RDD转换成DataSet，case类定义了table的结构，case类属性通过反射变成了表的列名。Case类可以包含诸如Seq或者Array等复杂的结构。 scala12345scala&gt; case class User(name:String, age:Int)defined class Userscala&gt; sc.makeRDD(List((\"zhangsan\",30), (\"lisi\",49))).map(t=&gt;User(t._1, t._2)).toDSres11: org.apache.spark.sql.Dataset[User] = [name: string, age: int] DataSet转换为RDDDataSet其实也是对RDD的封装，所以可以直接获取内部的RDD scala1234567891011scala&gt; case class User(name:String, age:Int)defined class Userscala&gt; sc.makeRDD(List((\"zhangsan\",30), (\"lisi\",49))).map(t=&gt;User(t._1, t._2)).toDSres11: org.apache.spark.sql.Dataset[User] = [name: string, age: int]scala&gt; val rdd = res11.rddrdd: org.apache.spark.rdd.RDD[User] = MapPartitionsRDD[51] at rdd at &lt;console&gt;:25scala&gt; rdd.collectres12: Array[User] = Array(User(zhangsan,30), User(lisi,49)) DataFrame和DataSet转换DataFrame其实是DataSet的特例，所以它们之间是可以互相转换的。 DataFrame转换为DataSet scala12345678scala&gt; case class User(name:String, age:Int)defined class Userscala&gt; val df = sc.makeRDD(List((\"zhangsan\",30), (\"lisi\",49))).toDF(\"name\",\"age\")df: org.apache.spark.sql.DataFrame = [name: string, age: int]scala&gt; val ds = df.as[User]ds: org.apache.spark.sql.Dataset[User] = [name: string, age: int] DataSet转换为DataFrame scala12345scala&gt; val ds = df.as[User]ds: org.apache.spark.sql.Dataset[User] = [name: string, age: int]scala&gt; val df = ds.toDFdf: org.apache.spark.sql.DataFrame = [name: string, age: int] RDD、DataFrame、DataSet三者关系在SparkSQL中Spark为我们提供了两个新的抽象，分别是DataFrame和DataSet。他们和RDD有什么区别呢？首先从版本的产生上来看： Spark1.0 =&gt; RDD Spark1.3 =&gt; DataFrame Spark1.6 =&gt; Dataset 如果同样的数据都给到这三个数据结构，他们分别计算之后，都会给出相同的结果。不同是的他们的执行效率和执行方式。在后期的Spark版本中，DataSet有可能会逐步取代RDD和DataFrame成为唯一的API接口。 三者共性Code1234567RDD、DataFrame、DataSet全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利;三者都有惰性机制，在进行创建、转换，如map方法时，不会立即执行，只有在遇到Action如foreach时，三者才会开始遍历运算;三者有许多共同的函数，如filter，排序等;在对DataFrame和Dataset进行操作许多操作都需要这个包:import spark.implicits._（在创建好SparkSession对象后尽量直接导入）三者都会根据 Spark 的内存情况自动缓存运算，这样即使数据量很大，也不用担心会内存溢出三者都有partition的概念DataFrame和DataSet均可使用模式匹配获取各个字段的值和类型 三者区别Code12345678910111)RDD RDD一般和spark mlib同时使用 RDD不支持sparksql操作2)DataFrame 与RDD和Dataset不同，DataFrame每一行的类型固定为Row，每一列的值没法直接访问，只有通过解析才能获取各个字段的值 DataFrame与DataSet一般不与 spark mlib 同时使用 DataFrame与DataSet均支持 SparkSQL 的操作，比如select，groupby之类，还能注册临时表&#x2F;视窗，进行 sql 语句操作 DataFrame与DataSet支持一些特别方便的保存方式，比如保存成csv，可以带上表头，这样每一列的字段名一目了然(后面专门讲解)3)DataSet Dataset和DataFrame拥有完全相同的成员函数，区别只是每一行的数据类型不同。 DataFrame其实就是DataSet的一个特例 type DataFrame &#x3D; Dataset[Row] DataFrame也可以叫Dataset[Row],每一行的类型是Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用上面提到的getAS方法或者共性中的第七条提到的模式匹配拿出特定字段。而Dataset中，每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获得每一行的信息 三者的互相转换 IDEA开发SparkSQLxml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-sql_2.11&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt; scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455object SparkSQL01_Demo &#123; def main(args: Array[String]): Unit = &#123; //创建上下文环境配置对象 val conf: SparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"SparkSQL01_Demo\") //创建SparkSession对象 val spark: SparkSession = SparkSession.builder().config(conf).getOrCreate() //RDD=&gt;DataFrame=&gt;DataSet转换需要引入隐式转换规则，否则无法转换 //spark不是包名，是上下文环境对象名 import spark.implicits._ //读取json文件 创建DataFrame &#123;\"username\": \"lisi\",\"age\": 18&#125; val df: DataFrame = spark.read.json(\"D:\\\\dev\\\\workspace\\\\spark-bak\\\\spark-bak-00\\\\input\\\\test.json\") //df.show() //SQL风格语法 df.createOrReplaceTempView(\"user\") //spark.sql(\"select avg(age) from user\").show //DSL风格语法 //df.select(\"username\",\"age\").show() //*****RDD=&gt;DataFrame=&gt;DataSet***** //RDD val rdd1: RDD[(Int, String, Int)] = spark.sparkContext.makeRDD(List((1,\"qiaofeng\",30),(2,\"xuzhu\",28),(3,\"duanyu\",20))) //DataFrame val df1: DataFrame = rdd1.toDF(\"id\",\"name\",\"age\") //df1.show() //DateSet val ds1: Dataset[User] = df1.as[User] //ds1.show() //*****DataSet=&gt;DataFrame=&gt;RDD***** //DataFrame val df2: DataFrame = ds1.toDF() //RDD 返回的RDD类型为Row，里面提供的getXXX方法可以获取字段值，类似jdbc处理结果集，但是索引从0开始 val rdd2: RDD[Row] = df2.rdd //rdd2.foreach(a=&gt;println(a.getString(1))) //*****RDD=&gt;DataSet***** rdd1.map&#123; case (id,name,age)=&gt;User(id,name,age) &#125;.toDS() //*****DataSet=&gt;=&gt;RDD***** ds1.rdd //释放资源 spark.stop() &#125;&#125;case class User(id:Int,name:String,age:Int) 用户自定义函数用户可以通过spark.udf功能添加自定义函数，实现自定义功能。 UDF创建DataFrame scala12scala&gt; val df = spark.read.json(\"data/user.json\")df: org.apache.spark.sql.DataFrame = [age: bigint， username: string] 注册UDF scala12scala&gt; spark.udf.register(\"addName\",(x:String)=&gt; \"Name:\"+x)res9: org.apache.spark.sql.expressions.UserDefinedFunction = UserDefinedFunction(&lt;function1&gt;,StringType,Some(List(StringType))) 创建临时表 scala1scala&gt; df.createOrReplaceTempView(\"people\") 应用UDF scala1scala&gt; spark.sql(\"Select addName(name),age from people\").show() UDAF强类型的Dataset和弱类型的DataFrame都提供了相关的聚合函数， 如 count()，countDistinct()，avg()，max()，min()。除此之外，用户可以设定自己的自定义聚合函数。通过继承UserDefinedAggregateFunction来实现用户自定义聚合函数。 需求：实现求平均工资 1、RDD实现 scala1234567891011121314val conf: SparkConf = new SparkConf().setAppName(\"app\").setMaster(\"local[*]\")val sc: SparkContext = new SparkContext(conf)val res: (Int, Int) = sc.makeRDD(List((\"zhangsan\", 20), (\"lisi\", 30), (\"wangw\", 40))).map &#123; case (name, age) =&gt; &#123; (age, 1) &#125;&#125;.reduce &#123; (t1, t2) =&gt; &#123; (t1._1 + t2._1, t1._2 + t2._2) &#125;&#125;println(res._1/res._2)// 关闭连接sc.stop() 2、累加器实现 scala12345678910111213141516171819202122232425262728293031323334353637class MyAC extends AccumulatorV2[Int,Int]&#123; var sum:Int = 0 var count:Int = 0 override def isZero: Boolean = &#123; return sum ==0 &amp;&amp; count == 0 &#125; override def copy(): AccumulatorV2[Int, Int] = &#123; val newMyAc = new MyAC newMyAc.sum = this.sum newMyAc.count = this.count newMyAc &#125; override def reset(): Unit = &#123; sum =0 count = 0 &#125; override def add(v: Int): Unit = &#123; sum += v count += 1 &#125; override def merge(other: AccumulatorV2[Int, Int]): Unit = &#123; other match &#123; case o:MyAC=&gt;&#123; sum += o.sum count += o.count &#125; case _=&gt; &#125; &#125; override def value: Int = sum/count&#125; 3、实现方式 - UDAF - 弱类型 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*定义类继承UserDefinedAggregateFunction，并重写其中方法*/class MyAveragUDAF extends UserDefinedAggregateFunction &#123; // 聚合函数输入参数的数据类型 def inputSchema: StructType = StructType(Array(StructField(\"age\",IntegerType))) // 聚合函数缓冲区中值的数据类型(age,count) def bufferSchema: StructType = &#123; StructType(Array(StructField(\"sum\",LongType),StructField(\"count\",LongType))) &#125; // 函数返回值的数据类型 def dataType: DataType = DoubleType // 稳定性：对于相同的输入是否一直返回相同的输出。 def deterministic: Boolean = true // 函数缓冲区初始化 def initialize(buffer: MutableAggregationBuffer): Unit = &#123; // 存年龄的总和 buffer(0) = 0L // 存年龄的个数 buffer(1) = 0L &#125; // 更新缓冲区中的数据 def update(buffer: MutableAggregationBuffer,input: Row): Unit = &#123; if (!input.isNullAt(0)) &#123; buffer(0) = buffer.getLong(0) + input.getInt(0) buffer(1) = buffer.getLong(1) + 1 &#125; &#125; // 合并缓冲区 def merge(buffer1: MutableAggregationBuffer,buffer2: Row): Unit = &#123; buffer1(0) = buffer1.getLong(0) + buffer2.getLong(0) buffer1(1) = buffer1.getLong(1) + buffer2.getLong(1) &#125; // 计算最终结果 def evaluate(buffer: Row): Double = buffer.getLong(0).toDouble / buffer.getLong(1)&#125;。。。//创建聚合函数var myAverage = new MyAveragUDAF//在spark中注册聚合函数spark.udf.register(\"avgAge\",myAverage)spark.sql(\"select avgAge(age) from user\").show() 4、实现方式 - UDAF - 强类型 scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//输入数据类型case class User01(username:String,age:Long)//缓存类型case class AgeBuffer(var sum:Long,var count:Long)/** * 定义类继承org.apache.spark.sql.expressions.Aggregator * 重写类中的方法 */class MyAveragUDAF1 extends Aggregator[User01,AgeBuffer,Double]&#123; override def zero: AgeBuffer = &#123; AgeBuffer(0L,0L) &#125; override def reduce(b: AgeBuffer, a: User01): AgeBuffer = &#123; b.sum = b.sum + a.age b.count = b.count + 1 b &#125; override def merge(b1: AgeBuffer, b2: AgeBuffer): AgeBuffer = &#123; b1.sum = b1.sum + b2.sum b1.count = b1.count + b2.count b1 &#125; override def finish(buff: AgeBuffer): Double = &#123; buff.sum.toDouble/buff.count &#125; //DataSet默认额编解码器，用于序列化，固定写法 //自定义类型就是produce 自带类型根据类型选择 override def bufferEncoder: Encoder[AgeBuffer] = &#123; Encoders.product &#125; override def outputEncoder: Encoder[Double] = &#123; Encoders.scalaDouble &#125;&#125;。。。//封装为DataSetval ds: Dataset[User01] = df.as[User01]//创建聚合函数var myAgeUdaf1 = new MyAveragUDAF1//将聚合函数转换为查询的列val col: TypedColumn[User01, Double] = myAgeUdaf1.toColumn//查询ds.select(col).show() 数据的加载和保存通用的加载和保存方式SparkSQL提供了通用的保存数据和数据加载的方式。这里的通用指的是使用相同的API，根据不同的参数读取和保存不同格式的数据，SparkSQL默认读取和保存的文件格式为parquet 1) 加载数据 spark.read.load是加载数据的通用方法 scala1scala&gt; spark.read.format(\"…\")[.option(\"…\")].load(\"…\") 1)保存数据 df.write.save 是保存数据的通用方法 scala1scala&gt;df.write.format(\"…\")[.option(\"…\")].save(\"…\") ParquetSpark SQL的默认数据源为Parquet格式。 Parquet是一种能够有效存储嵌套数据的列式存储格式。 数据源为Parquet文件时，Spark SQL可以方便的执行所有的操作，不需要使用format。修改配置项spark.sql.sources.default，可修改默认数据源格式。 加载数据 scala123scala&gt; val df = spark.read.load(\"/opt/module/spark-local/examples/src/main/resources/users.parquet\")scala&gt; df.show 保存数据 scala123scala&gt; var df = spark.read.json(\"/opt/module/data/input/people.json\")//保存为parquet格式scala&gt; df.write.mode(\"append\").save(\"/opt/module/data/output\") JSON/CSV/MySQLHiveApache Hive 是 Hadoop 上的 SQL 引擎，Spark SQL编译时可以包含 Hive 支持，也可以不包含。包含 Hive 支持的 Spark SQL 可以支持 Hive 表访问、UDF (用户自定义函数)以及 Hive 查询语言(HiveQL/HQL)等。需要强调的一点是，如果要在 Spark SQL 中包含Hive 的库，并不需要事先安装 Hive。一般来说，最好还是在编译Spark SQL时引入Hive支持，这样就可以使用这些特性了。如果你下载的是二进制版本的 Spark，它应该已经在编译时添加了 Hive 支持。 若要把 Spark SQL 连接到一个部署好的 Hive 上，你必须把 hive-site.xml 复制到 Spark的配置文件目录中($SPARK_HOME/conf)。即使没有部署好 Hive，Spark SQL 也可以运行。 需要注意的是，如果你没有部署好Hive，Spark SQL 会在当前的工作目录中创建出自己的 Hive 元数据仓库，叫作 metastore_db。此外，如果你尝试使用 HiveQL 中的 CREATE TABLE (并非 CREATE EXTERNAL TABLE)语句来创建表，这些表会被放在你默认的文件系统中的 /user/hive/warehouse 目录中(如果你的 classpath 中有配好的 hdfs-site.xml，默认的文件系统就是 HDFS，否则就是本地文件系统)。 spark-shell默认是Hive支持的；代码中是默认不支持的，需要手动指定（加一个参数即可）。 1、内嵌的Hive 如果使用 Spark 内嵌的 Hive, 则什么都不用做, 直接使用即可. Hive 的元数据存储在 derby 中, 仓库地址:$SPARK_HOME/spark-warehouse scala1234567891011121314151617scala&gt; spark.sql(\"show tables\").show。。。+--------+---------+-----------+|database|tableName|isTemporary|+--------+---------+-----------++--------+---------+-----------+scala&gt; spark.sql(\"create table aa(id int)\")。。。scala&gt; spark.sql(\"show tables\").show+--------+---------+-----------+|database|tableName|isTemporary|+--------+---------+-----------+| default| aa| false|+--------+---------+-----------+ 向表加载本地数据 scala12345678910111213scala&gt; spark.sql(\"load data local inpath 'input/ids.txt' into table aa\")。。。scala&gt; spark.sql(\"select * from aa\").show+---+| id|+---+| 1|| 2|| 3|| 4|+---+ 在实际使用中, 几乎没有任何人会使用内置的 Hive 2、外部的Hive 如果想连接外部已经部署好的Hive，需要通过以下几个步骤： Spark要接管Hive需要把hive-site.xml拷贝到conf/目录下 把Mysql的驱动copy到jars/目录下 如果访问不到hdfs，则需要把core-site.xml和hdfs-site.xml拷贝到conf/目录下 scala123456789101112scala&gt; spark.sql(\"show tables\").show20/04/25 22:05:14 WARN ObjectStore: Failed to get database global_temp, returning NoSuchObjectException+--------+--------------------+-----------+|database| tableName|isTemporary|+--------+--------------------+-----------+| default| emp| false|| default|hive_hbase_emp_table| false|| default| relevance_hbase_emp| false|| default| staff_hive| false|| default| ttt| false|| default| user_visit_action| false|+--------+--------------------+-----------+ 3、运行 Spark SQL CLI Spark SQL CLI可以很方便的在本地运行Hive元数据服务以及从命令行执行查询任务。在Spark目录下执行如下命令启动Spark SQL CLI，直接执行SQL语句，类似一Hive窗口 shell1bin/spark-sql 4、代码操作Hive xml1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-hive_2.11&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-exec&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt; 将hive-site.xml文件拷贝到项目的resources目录中，代码实现 scala1234567//创建SparkSessionval spark: SparkSession = SparkSession .builder() .enableHiveSupport() .master(\"local[*]\") .appName(\"sql\") .getOrCreate() 注意：在开发工具中创建数据库默认是在本地仓库，通过参数修改数据库仓库的地址: config(“spark.sql.warehouse.dir”, “hdfs://linux1:9000/user/hive/warehouse”)","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"},{"name":"spark-sql","slug":"spark-sql","permalink":"https://masteryang4.github.io/tags/spark-sql/"}]},{"title":"spark系列之spark基础","slug":"spark系列之spark基础","date":"2020-06-17T15:44:55.000Z","updated":"2020-06-17T17:07:52.754Z","comments":true,"path":"2020/06/17/spark系列之spark基础/","link":"","permalink":"https://masteryang4.github.io/2020/06/17/spark%E7%B3%BB%E5%88%97%E4%B9%8Bspark%E5%9F%BA%E7%A1%80/","excerpt":"","text":"概述 Spark Core Spark Core中提供了Spark最基础与最核心的功能，Spark其他的功能如：Spark SQL，Spark Streaming，GraphX, MLlib都是在Spark Core的基础上进行扩展的 Spark SQL Spark SQL是Spark用来操作结构化数据的组件。通过Spark SQL，用户可以使用SQL或者Apache Hive版本的SQL方言（HQL）来查询数据。 Spark Streaming Spark Streaming是Spark平台上针对实时数据进行流式计算的组件，提供了丰富的处理数据流的API。 Spark MLlib MLlib是Spark提供的一个机器学习算法库。MLlib不仅提供了模型评估、数据导入等额外的功能，还提供了一些更底层的机器学习原语。 Spark GraphX GraphX是Spark面向图计算提供的框架与算法库。 入门xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.11&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;!-- 该插件用于将Scala代码编译成class文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 声明绑定到maven的compile阶段 --&gt; &lt;goals&gt; &lt;goal&gt;testCompile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; WordCount scala1234567891011121314151617181920212223242526// 创建Spark运行配置对象val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"WordCount\")// 创建Spark上下文环境对象（连接对象）val sc : SparkContext = new SparkContext(sparkConf)// 读取文件数据val fileRDD: RDD[String] = sc.textFile(\"input/word.txt\")// 将文件中的数据进行分词val wordRDD: RDD[String] = fileRDD.flatMap( _.split(\" \") )// 转换数据结构 word =&gt; (word, 1)val word2OneRDD: RDD[(String, Int)] = wordRDD.map((_,1))// 将转换结构后的数据按照相同的单词进行分组聚合val word2CountRDD: RDD[(String, Int)] = word2OneRDD.reduceByKey(_+_)// 将数据聚合结果采集到内存中val word2Count: Array[(String, Int)] = word2CountRDD.collect()// 打印结果word2Count.foreach(println)//关闭Spark连接sc.stop() spark运行环境local所谓的Local模式，就是不需要其他任何节点资源就可以在本地执行Spark代码的环境，一般用于教学，调试，演示等， standalonelocal本地模式毕竟只是用来进行练习演示的，真实工作中还是要将应用提交到对应的集群中去执行，这里我们来看看只使用Spark自身节点运行的集群模式，也就是我们所谓的独立部署（Standalone）模式。Spark的Standalone模式体现了经典的master-slave模式。 集群规划: Linux1 Linux2 Linux3 Spark Worker Master Worker Worker yarn独立部署（Standalone）模式由Spark自身提供计算资源，无需其他框架提供资源。这种方式降低了和其他第三方资源框架的耦合性，独立性非常强。但是你也要记住，Spark主要是计算框架，而不是资源调度框架，所以本身提供的资源调度并不是它的强项，所以还是和其他专业的资源调度框架集成会更靠谱一些。所以接下来我们来学习在强大的Yarn环境下Spark是如何工作的（其实是因为在国内工作中，Yarn使用的非常多）。 k8s &amp; MesosMesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核,在Twitter得到广泛使用,管理着Twitter超过30,0000台服务器上的应用部署，但是在国内，依然使用着传统的Hadoop大数据框架，所以国内使用Mesos框架的并不多，但是原理其实都差不多。 windows一般教学演示使用。 对比 模式 Spark安装机器数 需启动的进程 所属者 应用场景 Local 1 无 Spark 测试 Standalone 3 Master及Worker Spark 单独部署 Yarn 1 Yarn及HDFS Hadoop 混合部署 端口号 Spark查看当前Spark-shell运行任务情况端口号：4040（计算） Spark Master内部通信服务端口号：7077 Standalone模式下，Spark Master Web端口号：8080（资源） Spark历史服务器端口号：18080 Hadoop YARN任务运行情况查看端口号：8088 spark运行架构核心组件Spark框架有两个核心组件： 1、Driver Spark驱动器节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责： 将用户程序转化为作业（job） 在Executor之间调度任务(task) 跟踪Executor的执行情况 通过UI展示查询运行情况 实际上，我们无法准确地描述Driver的定义，因为在整个的编程过程中没有看到任何有关Driver的字眼。所以简单理解，所谓的Driver就是驱使整个应用运行起来的程序，也称之为Driver类。 2、Executor Spark Executor是集群中工作节点（Worker）中的一个JVM进程，负责在 Spark 作业中运行具体任务（Task），任务彼此之间相互独立。Spark 应用启动时，Executor节点被同时启动，并且始终伴随着整个 Spark 应用的生命周期而存在。如果有Executor节点发生了故障或崩溃，Spark 应用也可以继续执行，会将出错节点上的任务调度到其他Executor节点上继续运行。 Executor有两个核心功能： 负责运行组成Spark应用的任务，并将结果返回给驱动器进程 它们通过自身的块管理器（Block Manager）为用户程序中要求缓存的 RDD 提供内存式存储。RDD 是直接缓存在Executor进程内的，因此任务可以在运行时充分利用缓存数据加速运算。 3、ApplicationMaster Hadoop用户向YARN集群提交应用程序时,提交程序中应该包含ApplicationMaster，用于向资源调度器申请执行任务的资源容器Container，运行用户自己的程序任务job，监控整个任务的执行，跟踪整个任务的状态，处理任务失败等异常情况。 说的简单点就是，RM（资源）和Driver（计算）之间的解耦合靠的就是ApplicationMaster。 提交流程Spark应用程序提交到Yarn环境中执行的时候，一般会有两种部署执行的方式：Client和Cluster。 两种模式，主要区别在于：Driver程序的运行节点。 Yarn Client模式 Client模式将用于监控和调度的Driver模块在客户端执行，而不是Yarn中，所以一般用于测试。 Driver在任务提交的本地机器上运行 Driver启动后会和ResourceManager通讯申请启动ApplicationMaster ResourceManager分配container，在合适的NodeManager上启动ApplicationMaster，负责向ResourceManager申请Executor内存 ResourceManager接到ApplicationMaster的资源申请后会分配container，然后ApplicationMaster在资源分配指定的NodeManager上启动Executor进程 Executor进程启动后会向Driver反向注册，Executor全部注册完成后Driver开始执行main函数 之后执行到Action算子时，触发一个Job，并根据宽依赖开始划分stage，每个stage生成对应的TaskSet，之后将task分发到各个Executor上执行。 Yarn Cluster模式 Cluster模式将用于监控和调度的Driver模块启动在Yarn集群资源中执行。一般应用于实际生产环境。 在YARN Cluster模式下，任务提交后会和ResourceManager通讯申请启动ApplicationMaster， 随后ResourceManager分配container，在合适的NodeManager上启动ApplicationMaster，此时的ApplicationMaster就是Driver。 Driver启动后向ResourceManager申请Executor内存，ResourceManager接到ApplicationMaster的资源申请后会分配container，然后在合适的NodeManager上启动Executor进程 Executor进程启动后会向Driver反向注册，Executor全部注册完成后Driver开始执行main函数， 之后执行到Action算子时，触发一个Job，并根据宽依赖开始划分stage，每个stage生成对应的TaskSet，之后将task分发到各个Executor上执行。 spark核心编程Spark计算框架为了能够对数据进行高并发和高吞吐的处理，封装了三大数据结构，用于处理不同的应用场景。三大数据结构分别是： RDD : 弹性分布式数据集 累加器：分布式共享只写变量 广播变量：分布式共享只读变量 RDDRDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据处理模型。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。 数据集：RDD封装了计算逻辑，并不保存数据 RDD并行度与分区默认情况下，Spark可以切分任务，并将任务发送给Executor节点并行计算，而这个并行计算的任务数量我们称之为并行度。这个数量可以在构建RDD时指定。 scala12345678910111213val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"spark\")val sparkContext = new SparkContext(sparkConf)val dataRDD: RDD[Int] = sparkContext.makeRDD( List(1,2,3,4), 4)val fileRDD: RDD[String] = sparkContext.textFile( \"input\", 2)fileRDD.collect().foreach(println)sparkContext.stop() 读取内存数据时，数据可以按照并行度的设定进行数据的分区操作，数据分区规则的Spark源码如下 scala1234567def positions(length: Long, numSlices: Int): Iterator[(Int, Int)] = &#123; (0 until numSlices).iterator.map &#123; i =&gt; val start = ((i * length) / numSlices).toInt val end = (((i + 1) * length) / numSlices).toInt (start, end) &#125;&#125; 读取文件数据时，数据是按照Hadoop文件读取的规则进行切片分区，而切片规则和数据读取的规则有些差异，具体Spark源码如下 scala1234567891011121314151617181920212223242526272829303132public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException &#123; long totalSize = 0; // compute total size for (FileStatus file: files) &#123; // check we have valid files if (file.isDirectory()) &#123; throw new IOException(\"Not a file: \"+ file.getPath()); &#125; totalSize += file.getLen(); &#125; long goalSize = totalSize / (numSplits == 0 ? 1 : numSplits); long minSize = Math.max(job.getLong(org.apache.hadoop.mapreduce.lib.input. FileInputFormat.SPLIT_MINSIZE, 1), minSplitSize); ... for (FileStatus file: files) &#123; ... if (isSplitable(fs, path)) &#123; long blockSize = file.getBlockSize(); long splitSize = computeSplitSize(goalSize, minSize, blockSize); ... &#125; protected long computeSplitSize(long goalSize, long minSize, long blockSize) &#123; return Math.max(minSize, Math.min(goalSize, blockSize)); &#125; RDD创建1、从集合（内存）中创建RDD parallelize和makeRDD scala123456789101112val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"spark\")val sparkContext = new SparkContext(sparkConf)val rdd1 = sparkContext.parallelize( List(1,2,3,4))val rdd2 = sparkContext.makeRDD( List(1,2,3,4))rdd1.collect().foreach(println)rdd2.collect().foreach(println)sparkContext.stop() makeRDD方法其实就是parallelize方法 scala12345def makeRDD[T: ClassTag]( seq: Seq[T], numSlices: Int = defaultParallelism): RDD[T] = withScope &#123; parallelize(seq, numSlices)&#125; 2、从外部存储（文件）创建RDD 由外部存储系统的数据集创建RDD包括：本地的文件系统，所有Hadoop支持的数据集，比如HDFS、HBase等。 scala123456val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"spark\")val sparkContext = new SparkContext(sparkConf)val fileRDD: RDD[String] = sparkContext.textFile(\"input\")fileRDD.collect().foreach(println)sparkContext.stop() 3、从其他RDD创建 主要是通过一个RDD运算完后，再产生新的RDD。 4、直接创建RDD（new） 使用new的方式直接构造RDD 转换算子RDD整体上分为Value类型、双Value类型和Key-Value类型 value类型map mapPartitions mapPartitionsWithIndex flatMap glom 将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变 groupBy filter 将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃 sample 根据指定的规则从数据集中抽取数据 distinct coalesce 根据数据量缩减分区，用于大数据集过滤后，提高小数据集的执行效率 repartition 小问题：coalesce和repartition区别？ repartition算子其实底层调用的就是coalesce算子，只不过固定使用了shuffle的操作,可以让数据更均衡一下，可以有效防止数据倾斜问题。 如果缩减分区，一般就采用coalesce，如果想扩大分区，就采用repartition sortBy pipe 管道，针对每个分区，都调用一次shell脚本，返回输出的RDD。 双Value类型intersection 对源RDD和参数RDD求交集后返回一个新的RDD union 对源RDD和参数RDD求并集后返回一个新的RDD subtract 以一个RDD元素为主，去除两个RDD中重复元素，将其他元素保留下来。求差集 zip 将两个RDD中的元素，以键值对的形式进行合并。其中，键值对中的Key为第1个RDD中的元素，Value为第2个RDD中的元素。 Key - Value类型partitionBy 将数据按照指定Partitioner重新进行分区。Spark默认的分区器是HashPartitioner reduceByKey groupByKey reduceByKey和groupByKey的区别？ 两个算子没有使用上的区别。所以使用的时候需要根据应用场景来选择。 从性能上考虑，reduceByKey存在预聚合功能，这样，在shuffle的过程中，落盘的数据量会变少，所以读写磁盘的速度会变快。性能更高 aggregateByKey 将数据根据不同的规则进行分区内计算和分区间计算 dataRDD1.aggregateByKey(0)(_+_,_+_) foldByKey 当分区内计算规则和分区间计算规则相同时，aggregateByKey就可以简化为foldByKey dataRDD1.foldByKey(0)(_+_) combineByKey 最通用的对key-value型rdd进行聚集操作的聚集函数（aggregation function）。类似于aggregate()，combineByKey()允许用户返回值的类型与输入不一致。 reduceByKey、foldByKey、aggregateByKey、combineByKey的区别？ 从源码的角度来讲，四个算子的底层逻辑是相同的。 aggregateByKey的算子会将初始值和第一个value使用分区内的计算规则进行计算 foldByKey的算子的分区内和分区间的计算规则相同，并且初始值和第一个value使用的规则相同 combineByKey第一个参数就是对第一个value进行处理，所以无需初始值。 reduceByKey不会对第一个value进行处理，分区内和分区间计算规则相同 上面的四个算子都支持预聚合功能。所以shuffle性能比较高 上面的四个算子都可以实现WordCount sortByKey join leftOuterJoin cogroup 在类型为(K,V)和(K,W)的RDD上调用，返回一个(K,(Iterable,Iterable))类型的RDD 行动算子reduce 聚集RDD中的所有元素，先聚合分区内数据，再聚合分区间数据 collect 在驱动程序中，以数组Array的形式返回数据集的所有元素 count first take takeOrdered aggregate 分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合 fold 折叠操作，aggregate的简化版操作 countByKey save相关算子 scala12345678// 保存成Text文件rdd.saveAsTextFile(\"output\")// 序列化成对象保存到文件rdd.saveAsObjectFile(\"output1\")// 保存成Sequencefile文件rdd.map((_,1)).saveAsSequenceFile(\"output2\") foreach 分布式遍历RDD中的每一个元素，调用指定函数 RDD序列化1) 闭包检查 从计算的角度, 算子以外的代码都是在Driver端执行, 算子里面的代码都是在Executor端执行。那么在scala的函数式编程中，就会导致算子内经常会用到算子外的数据，这样就形成了闭包的效果，如果使用的算子外的数据无法序列化，就意味着无法传值给Executor端执行，就会发生错误，所以需要在执行任务计算前，检测闭包内的对象是否可以进行序列化，这个操作我们称之为闭包检测。 2) Kryo序列化框架 参考地址: https://github.com/EsotericSoftware/kryo Java的序列化能够序列化任何的类。但是比较重，序列化后，对象的提交也比较大。 Spark出于性能的考虑，Spark2.0开始支持另外一种Kryo序列化机制。Kryo速度是Serializable的10倍。当RDD在Shuffle数据的时候，简单数据类型、数组和字符串类型已经在Spark内部使用Kryo来序列化。 RDD依赖关系1、RDD血缘关系 RDD只支持粗粒度转换，即在大量记录上执行的单个操作。将创建RDD的一系列Lineage（血统）记录下来，以便恢复丢失的分区。RDD的Lineage会记录RDD的元数据信息和转换行为，当该RDD的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。 scala12345678910111213141516val fileRDD: RDD[String] = sc.textFile(\"input/1.txt\")println(fileRDD.toDebugString)println(\"----------------------\")val wordRDD: RDD[String] = fileRDD.flatMap(_.split(\" \"))println(wordRDD.toDebugString)println(\"----------------------\")val mapRDD: RDD[(String, Int)] = wordRDD.map((_,1))println(mapRDD.toDebugString)println(\"----------------------\")val resultRDD: RDD[(String, Int)] = mapRDD.reduceByKey(_+_)println(resultRDD.toDebugString)resultRDD.collect() 2、RDD依赖关系 这里所谓的依赖关系，其实就是RDD之间的关系 scala123456789101112131415161718val sc: SparkContext = new SparkContext(conf)val fileRDD: RDD[String] = sc.textFile(\"input/1.txt\")println(fileRDD.dependencies)println(\"----------------------\")val wordRDD: RDD[String] = fileRDD.flatMap(_.split(\" \"))println(wordRDD.dependencies)println(\"----------------------\")val mapRDD: RDD[(String, Int)] = wordRDD.map((_,1))println(mapRDD.dependencies)println(\"----------------------\")val resultRDD: RDD[(String, Int)] = mapRDD.reduceByKey(_+_)println(resultRDD.dependencies)resultRDD.collect() 3、RDD窄依赖 窄依赖表示每一个父RDD的Partition最多被子RDD的一个Partition使用，窄依赖我们形象的比喻为独生子女。 4、RDD宽依赖 宽依赖表示同一个父RDD的Partition被多个子RDD的Partition依赖，会引起Shuffle，总结：宽依赖我们形象的比喻为超生。 5、RDD任务划分 RDD任务切分中间分为：Application、Job、Stage和Task Application：初始化一个SparkContext即生成一个Application； Job：一个Action算子就会生成一个Job； Stage：Stage等于宽依赖(ShuffleDependency)的个数加1； Task：一个Stage阶段中，最后一个RDD的分区个数就是Task的个数。 注意：Application-&gt;Job-&gt;Stage-&gt;Task每一层都是1对n的关系。 RDD持久化1、RDD Cache缓存 RDD通过Cache或者Persist方法将前面的计算结果缓存，默认情况下会把数据以序列化的形式缓存在JVM的堆内存中。但是并不是这两个方法被调用时立即缓存，而是触发后面的action算子时，该RDD将会被缓存在计算节点的内存中，并供后面重用。 scala12345678// cache操作会增加血缘关系，不改变原有的血缘关系println(wordToOneRdd.toDebugString)// 数据缓存。wordToOneRdd.cache()// 可以更改存储级别//mapRdd.persist(StorageLevel.MEMORY_AND_DISK_2) 存储级别 scala12345678910111213object StorageLevel &#123; val NONE = new StorageLevel(false, false, false, false) val DISK_ONLY = new StorageLevel(true, false, false, false) val DISK_ONLY_2 = new StorageLevel(true, false, false, false, 2) val MEMORY_ONLY = new StorageLevel(false, true, false, true) val MEMORY_ONLY_2 = new StorageLevel(false, true, false, true, 2) val MEMORY_ONLY_SER = new StorageLevel(false, true, false, false) val MEMORY_ONLY_SER_2 = new StorageLevel(false, true, false, false, 2) val MEMORY_AND_DISK = new StorageLevel(true, true, false, true) val MEMORY_AND_DISK_2 = new StorageLevel(true, true, false, true, 2) val MEMORY_AND_DISK_SER = new StorageLevel(true, true, false, false) val MEMORY_AND_DISK_SER_2 = new StorageLevel(true, true, false, false, 2) val OFF_HEAP = new StorageLevel(true, true, true, false, 1) 缓存有可能丢失，或者存储于内存的数据由于内存不足而被删除，RDD的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于RDD的一系列转换，丢失的数据会被重算，由于RDD的各个Partition是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部Partition。 Spark会自动对一些Shuffle操作的中间数据做持久化操作(比如：reduceByKey)。这样做的目的是为了当一个节点Shuffle失败了避免重新计算整个输入。但是，在实际使用的时候，如果想重用数据，仍然建议调用persist或cache。 2、RDD CheckPoint检查点 所谓的检查点其实就是通过将RDD中间结果写入磁盘 由于血缘依赖过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果检查点之后有节点出现问题，可以从检查点开始重做血缘，减少了开销。 对RDD进行checkpoint操作并不会马上被执行，必须执行Action操作才能触发。 scala12345678910111213141516171819202122// 设置检查点路径sc.setCheckpointDir(\"./checkpoint1\")// 创建一个RDD，读取指定位置文件:hello ys ysval lineRdd: RDD[String] = sc.textFile(\"input/1.txt\")// 业务逻辑val wordRdd: RDD[String] = lineRdd.flatMap(line =&gt; line.split(\" \"))val wordToOneRdd: RDD[(String, Long)] = wordRdd.map &#123; word =&gt; &#123; (word, System.currentTimeMillis()) &#125;&#125;// 增加缓存,避免再重新跑一个job做checkpointwordToOneRdd.cache()// 数据检查点：针对wordToOneRdd做检查点计算wordToOneRdd.checkpoint()// 触发执行逻辑wordToOneRdd.collect().foreach(println) 缓存和检查点区别 Code123451）Cache缓存只是将数据保存起来，不切断血缘依赖。Checkpoint检查点切断血缘依赖。2）Cache缓存的数据通常存储在磁盘、内存等地方，可靠性低。Checkpoint的数据通常存储在HDFS等容错、高可用的文件系统，可靠性高。3）建议对checkpoint()的RDD使用Cache缓存，这样checkpoint的job只需从Cache缓存中读取数据即可，否则需要再从头计算一次RDD。 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.ysss.bigdata.spark.core.cacheimport org.apache.spark.rdd.RDDimport org.apache.spark.&#123;SparkConf, SparkContext&#125;object Spark02_Checkpoint &#123; def main(args: Array[String]): Unit = &#123; val conf: SparkConf = new SparkConf().setAppName(\"SparkCoreTest\").setMaster(\"local[*]\") val sc: SparkContext = new SparkContext(conf) // 设置检查点路径， 一般路径应该为分布式存储路径，HDFS sc.setCheckpointDir(\"cp\") val rdd: RDD[Int] = sc.makeRDD(List(1,2,3,4)) // TODO 检查点 // RDD的持久化可能会导致数据丢失，如果数据丢失，那么需要重新再次计算，性能不高 // 所以如果能够保证数据不丢，那么是一个好的选择 // 可以将数据保存到检查点中，这样是分布式存储，所以比较安全。 // 所以将数据保存到检查点前，需要设定检查点路径 val rdd1 = rdd.map( num =&gt; &#123; //println(\"num.....\") num &#125; ) // 检查点 // 检查点为了准确，需要重头再执行一遍，就等同于开启一个新的作业 // 为了提高效率，一般情况下，是先使用cache后在使用检查点 // 检查点会切断RDD的血缘关系。将当前检查点当成数据计算的起点。 // 持久化操作是不能切断血缘关系，因为一旦内存中数据丢失，无法恢复数据 val rdd2: RDD[Int] = rdd1.cache() rdd2.checkpoint() println(rdd2.toDebugString) println(rdd2.collect().mkString(\",\")) println(rdd2.toDebugString) println(\"**********************\") println(rdd2.collect().mkString(\",\")) sc.stop() &#125;&#125; RDD分区器Spark目前支持Hash分区和Range分区，和用户自定义分区。 Hash分区为当前的默认分区。 分区器直接决定了RDD中分区的个数、RDD中每条数据经过Shuffle后进入哪个分区，进而决定了Reduce的个数。 只有Key-Value类型的RDD才有分区器，非Key-Value类型的RDD分区的值是None 每个RDD的分区ID范围：0 ~ (numPartitions - 1)，决定这个值是属于那个分区的。 1) Hash分区：对于给定的key，计算其hashCode,并除以分区个数取余 2) Range分区：将一定范围内的数据映射到一个分区中，尽量保证每个分区数据均匀，而且分区间有序 文件读取与保存Spark的数据读取及数据保存可以从两个维度来作区分：文件格式以及文件系统。 文件格式分为：text文件、json文件、csv文件、sequence文件以及Object文件； 文件系统分为：本地文件系统、HDFS、HBASE以及数据库。 累加器累加器用来把Executor端变量信息聚合到Driver端。 在Driver程序中定义的变量，在Executor端的每个Task都会得到这个变量的一份新的副本，每个task更新这些副本的值后，传回Driver端进行merge。 系统累加器 scala1234567891011val rdd = sc.makeRDD(List(1,2,3,4,5))// 声明累加器var sum = sc.longAccumulator(\"sum\");rdd.foreach( num =&gt; &#123; // 使用累加器 sum.add(num) &#125;)// 获取累加器的值println(\"sum = \" + sum.value) 自定义累加器 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 自定义累加器// 1. 继承AccumulatorV2，并设定泛型// 2. 重写累加器的抽象方法class WordCountAccumulator extends AccumulatorV2[String, mutable.Map[String, Long]]&#123;var map : mutable.Map[String, Long] = mutable.Map()// 累加器是否为初始状态override def isZero: Boolean = &#123; map.isEmpty&#125;// 复制累加器override def copy(): AccumulatorV2[String, mutable.Map[String, Long]] = &#123; new WordCountAccumulator&#125;// 重置累加器override def reset(): Unit = &#123; map.clear()&#125;// 向累加器中增加数据 (In)override def add(word: String): Unit = &#123; // 查询map中是否存在相同的单词 // 如果有相同的单词，那么单词的数量加1 // 如果没有相同的单词，那么在map中增加这个单词 map(word) = map.getOrElse(word, 0L) + 1L&#125;// 合并累加器override def merge(other: AccumulatorV2[String, mutable.Map[String, Long]]): Unit = &#123; val map1 = map val map2 = other.value // 两个Map的合并 map = map1.foldLeft(map2)( ( innerMap, kv ) =&gt; &#123; innerMap(kv._1) = innerMap.getOrElse(kv._1, 0L) + kv._2 innerMap &#125; )&#125;// 返回累加器的结果 （Out）override def value: mutable.Map[String, Long] = map&#125; 广播变量广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的只读值，以供一个或多个Spark操作使用。比如，如果你的应用需要向所有节点发送一个较大的只读查询表，广播变量用起来都很顺手。在多个并行操作中使用同一个变量，但是 Spark会为每个任务分别发送。 scala1234567891011121314151617val rdd1 = sc.makeRDD(List( (\"a\",1), (\"b\", 2), (\"c\", 3), (\"d\", 4) ),4)val list = List( (\"a\",4), (\"b\", 5), (\"c\", 6), (\"d\", 7) )// 声明广播变量val broadcast: Broadcast[List[(String, Int)]] = sc.broadcast(list)val resultRDD: RDD[(String, (Int, Int))] = rdd1.map &#123; case (key, num) =&gt; &#123; var num2 = 0 // 使用广播变量 for ((k, v) &lt;- broadcast.value) &#123; if (k == key) &#123; num2 = v &#125; &#125; (key, (num, num2)) &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"}]},{"title":"sqoop常见问题汇总","slug":"sqoop常见问题汇总","date":"2020-06-17T12:14:17.000Z","updated":"2020-06-17T12:15:59.786Z","comments":true,"path":"2020/06/17/sqoop常见问题汇总/","link":"","permalink":"https://masteryang4.github.io/2020/06/17/sqoop%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"","text":"概述Sqoop是连接关系型数据库和Hadoop的桥梁，主要有两个方面(导入和导出)。 目前在我的工程实践中，一般是将MySQL数据进行导入导出 Sqoop参数shell123456789/opt/module/sqoop/bin/sqoop import \\--connect \\--username \\--password \\--target-dir \\--delete-target-dir \\--num-mappers \\--fields-terminated-by \\--query \"$2\" ' and $CONDITIONS;' Sqoop导入导出Null存储一致性问题Hive中的Null在底层是以“\\N”来存储，而MySQL中的Null在底层就是Null。为了保证数据两端的一致性。 往hive导入数据时采用--null-string和--null-non-string。 在从hive导出数据时采用--input-null-string和--input-null-non-string两个参数。 Sqoop数据导出一致性问题场景：如Sqoop在导出到Mysql时，使用4个Map任务，过程中有2个任务失败，那此时MySQL中存储了另外两个Map任务导入的数据，此时老板正好看到了这个报表数据。而开发工程师发现任务失败后，会调试问题并最终将全部数据正确的导入MySQL，那后面老板再次看报表数据，发现本次看到的数据与之前的不一致，这在生产环境是不允许的。 官网：http://sqoop.apache.org/docs/1.4.6/SqoopUserGuide.html Since Sqoop breaks down export process into multiple transactions, it is possible that a failed export job may result in partial data being committed to the database. This can further lead to subsequent jobs failing due to insert collisions in some cases, or lead to duplicated data in others. You can overcome this problem by specifying a staging table via the –staging-table option which acts as an auxiliary table that is used to stage exported data. The staged data is finally moved to the destination table in a single transaction. –staging-table方式 shell1sqoop export --connect jdbc:mysql://192.168.137.10:3306/user_behavior --username root --password 123456 --table app_cource_study_report --columns watch_video_cnt,complete_video_cnt,dt --fields-terminated-by \"\\t\" --export-dir \"/user/hive/warehouse/tmp.db/app_cource_study_analysis_$&#123;day&#125;\" --staging-table app_cource_study_report_tmp --clear-staging-table --input-null-string '\\N' Sqoop底层运行的任务是什么只有Map阶段，没有Reduce阶段的任务。 默认是4个MapTask。 Sqoop一天导入多少数据100万日活=》10万订单，1人10条，每天1g左右业务数据 Sqoop每天将1G的数据量导入到数仓。 Sqoop数据导出的时候一次执行多长时间每天晚上00:30开始执行，Sqoop任务一般情况40 -50分钟的都有。取决于数据量（11:11，6:18等活动在1个小时左右）。 Sqoop在导入数据的时候数据倾斜 https://blog.csdn.net/lizhiguo18/article/details/103969906 Sqoop 抽数的并行化主要涉及到两个参数：num-mappers：启动N个map来并行导入数据，默认4个；split-by：按照某一列来切分表的工作单元。 通过ROWNUM() 生成一个严格均匀分布的字段，然后指定为分割字段. Sqoop数据导出Parquet我在工程项目中经常遇到的问题 Ads层数据用Sqoop往MySql中导入数据的时候，如果用了orc（Parquet）不能导入，需转化成text格式 （1）创建临时表，把Parquet中表数据导入到临时表，把临时表导出到目标表用于可视化 （2）Sqoop里面有参数，可以直接把Parquet转换为text （3）ads层建表的时候就不要建Parquet表","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"sqoop","slug":"大数据/sqoop","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/sqoop/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"sqoop","slug":"sqoop","permalink":"https://masteryang4.github.io/tags/sqoop/"},{"name":"离线大数据","slug":"离线大数据","permalink":"https://masteryang4.github.io/tags/%E7%A6%BB%E7%BA%BF%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"spark系列之spark-streaming","slug":"spark系列之spark-streaming","date":"2020-06-17T08:44:51.000Z","updated":"2020-06-17T11:41:04.721Z","comments":true,"path":"2020/06/17/spark系列之spark-streaming/","link":"","permalink":"https://masteryang4.github.io/2020/06/17/spark%E7%B3%BB%E5%88%97%E4%B9%8Bspark-streaming/","excerpt":"","text":"SparkStreaming概述Spark Streaming是什么Spark Streaming用于流式数据的处理。Spark Streaming支持的数据输入源很多，例如：Kafka、Flume、Twitter、ZeroMQ和简单的TCP套接字等等。数据输入后可以用Spark的高度抽象原语如：map、reduce、join、window等进行运算。而结果也能保存在很多地方，如HDFS，数据库等。 和Spark基于RDD的概念很相似，Spark Streaming使用离散化流(discretized stream)作为抽象表示，叫作DStream。DStream 是随时间推移而收到的数据的序列。在内部，每个时间区间收到的数据都作为 RDD 存在，而DStream是由这些RDD所组成的序列(因此得名“离散化”)。 Spark Streaming架构整体架构图 spark-streaming架构图 背压机制Spark 1.5以前版本，用户如果要限制Receiver的数据接收速率，可以通过设置静态配制参数“spark.streaming.receiver.maxRate”的值来实现，此举虽然可以通过限制接收速率，来适配当前的处理能力，防止内存溢出，但也会引入其它问题。比如：producer数据生产高于maxRate，当前集群处理能力也高于maxRate，这就会造成资源利用率下降等问题。 为了更好的协调数据接收速率与资源处理能力，1.5版本开始Spark Streaming可以动态控制数据接收速率来适配集群数据处理能力。背压机制（即Spark Streaming Backpressure）: 根据JobScheduler反馈作业的执行信息来动态调整Receiver数据接收率。 通过属性spark.streaming.backpressure.enabled来控制是否启用backpressure机制，默认值false，即不启用。 DStream入门需求：使用netcat工具向9999端口不断的发送数据，通过SparkStreaming读取端口数据并统计不同单词出现的次数 maven依赖 xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming_2.11&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt; WordCount案例代码 scala123456789101112131415161718192021222324252627282930object StreamWordCount &#123; def main(args: Array[String]): Unit = &#123; //1.初始化Spark配置信息 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"StreamWordCount\") //2.初始化SparkStreamingContext val ssc = new StreamingContext(sparkConf, Seconds(3)) //3.通过监控端口创建DStream，读进来的数据为一行行 val lineStreams = ssc.socketTextStream(\"linux1\", 9999) //将每一行数据做切分，形成一个个单词 val wordStreams = lineStreams.flatMap(_.split(\" \")) //将单词映射成元组（word,1） val wordAndOneStreams = wordStreams.map((_, 1)) //将相同的单词次数做统计 val wordAndCountStreams = wordAndOneStreams.reduceByKey(_+_) //打印 wordAndCountStreams.print() //启动SparkStreamingContext ssc.start() ssc.awaitTermination() &#125;&#125; 启动程序并通过netcat发送数据： Code12nc -lk 9999hello ysss WordCount解析 Discretized Stream是Spark Streaming的基础抽象，代表持续性的数据流和经过各种Spark原语操作后的结果数据流。在内部实现上，DStream是一系列连续的RDD来表示。每个RDD含有一段时间间隔内的数据。 DStream创建/数据源RDD队列测试过程中，可以通过使用ssc.queueStream(queueOfRDDs)来创建DStream，每一个推送到这个队列中的RDD，都会作为一个DStream处理。 需求：循环创建几个RDD，将RDD放入队列。通过SparkStream创建Dstream，计算WordCount scala1234567891011121314151617181920212223242526272829303132333435363738package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.rdd.RDDimport org.apache.spark.streaming.dstream.&#123;DStream, InputDStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;import scala.collection.mutableobject SparkStreaming02_DStream_Queue &#123; def main(args: Array[String]): Unit = &#123; // TODO 配置对象 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") // TODO 环境对象 val ssc = new StreamingContext(sparkConf, Seconds(3)) // TODO 数据处理 val que = new mutable.Queue[RDD[String]]() val queDS: InputDStream[String] = ssc.queueStream(que) queDS.print() // TODO 关闭连接环境 ssc.start() println(\"queue append item\") for ( i &lt;- 1 to 5 ) &#123; val rdd = ssc.sparkContext.makeRDD(List(\"1\",\"2\")) que += rdd Thread.sleep(2000) &#125; // block ssc.awaitTermination() &#125;&#125; 结果 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445-------------------------------------------Time: 1539075280000 ms-------------------------------------------(4,60)(0,60)(6,60)(8,60)(2,60)(1,60)(3,60)(7,60)(9,60)(5,60)-------------------------------------------Time: 1539075284000 ms-------------------------------------------(4,60)(0,60)(6,60)(8,60)(2,60)(1,60)(3,60)(7,60)(9,60)(5,60)-------------------------------------------Time: 1539075288000 ms-------------------------------------------(4,30)(0,30)(6,30)(8,30)(2,30)(1,30)(3,30)(7,30)(9,30)(5,30)-------------------------------------------Time: 1539075292000 ms------------------------------------------- 扩展，从文件中读取 scala123456789101112131415161718192021222324252627282930313233package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.rdd.RDDimport org.apache.spark.streaming.dstream.&#123;DStream, InputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;import scala.collection.mutableobject SparkStreaming03_DStream_File &#123; def main(args: Array[String]): Unit = &#123; // TODO 配置对象 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") // TODO 环境对象 val ssc = new StreamingContext(sparkConf, Seconds(5)) // TODO 数据处理 // 从文件夹中读取新的文件数据，功能不稳定 ，所以不推荐使用 // flume更加专业，所以生产环境，监控文件或目录的变化，采集数据都使用flume val fileDS: DStream[String] = ssc.textFileStream(\"in\") val wordDS: DStream[String] = fileDS.flatMap(_.split(\" \")) val wordToOneDS: DStream[(String, Int)] = wordDS.map( (_, 1) ) val wordToCountDS: DStream[(String, Int)] = wordToOneDS.reduceByKey(_+_) wordToCountDS.print() // TODO 关闭连接环境 ssc.start() ssc.awaitTermination() &#125;&#125; 自定义数据源需要继承Receiver，并实现onStart、onStop方法来自定义数据源采集。 需求：自定义数据源，实现监控某个端口号，获取该端口号内容。 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.ysss.bigdata.spark.streamingimport java.io.&#123;BufferedReader, InputStreamReader&#125;import java.net.Socketimport org.apache.spark.SparkConfimport org.apache.spark.storage.StorageLevelimport org.apache.spark.streaming.dstream.DStreamimport org.apache.spark.streaming.receiver.Receiverimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming04_DStream_DIY &#123; def main(args: Array[String]): Unit = &#123; // TODO 配置对象 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") // TODO 环境对象 val ssc = new StreamingContext(sparkConf, Seconds(5)) // TODO 数据处理 // 自定义数据采集器 val myDS = ssc.receiverStream( new MyReceiver( \"localhost\", 9999 ) ) val wordDS: DStream[String] = myDS.flatMap(_.split(\" \")) val wordToOneDS: DStream[(String, Int)] = wordDS.map( (_, 1) ) val wordToCountDS: DStream[(String, Int)] = wordToOneDS.reduceByKey(_+_) wordToCountDS.print() // TODO 关闭连接环境 ssc.start() ssc.awaitTermination() &#125; /* 自定义数据采集器 模仿spark自带的socket采集器 1. 继承Receiver ,设定泛型（采集数据的类型）, 传递参数 2. 重写方法 */ // rdd cache, checkpoint class MyReceiver(host:String, port:Int) extends Receiver[String](StorageLevel.MEMORY_ONLY)&#123; private var socket: Socket = _ // 接收数据 def receive(): Unit = &#123; val reader = new BufferedReader( new InputStreamReader( socket.getInputStream, \"UTF-8\" ) ) var s : String = null // 网络编程中，获取的数据没有null的概念 // 如果网络编程中，需要明确告知服务器，客户端不再传数据，需要发送特殊的指令 // 文件读取时，如果读到结束的时候，获取的结果为null while ( (s = reader.readLine()) != null ) &#123; // 采集到数据后，进行封装(存储) if ( s != \"-END-\" ) &#123; store(s) &#125; else &#123; // stop // close // 重启 //restart(\"\") &#125; &#125; &#125; // 启动采集器 // 采集 &amp; 封装 override def onStart(): Unit = &#123; socket = new Socket(host, port) new Thread(\"Socket Receiver\") &#123; setDaemon(true) override def run() &#123; receive() &#125; &#125;.start() &#125; override def onStop(): Unit = &#123; if ( socket != null ) &#123; socket.close() &#125; &#125; &#125;&#125; kakfa数据源[重点]概述ReceiverAPI：需要一个专门的Executor去接收数据，然后发送给其他的Executor做计算。存在的问题，接收数据的Executor和计算的Executor速度会有所不同，特别在接收数据的Executor速度大于计算的Executor速度，会导致计算数据的节点内存溢出。 DirectAPI：是由计算的Executor来主动消费Kafka的数据，速度由自身控制。 kafka 0-8 Receiver 模式这种方式使用Receiver来获取数据。Receiver是使用Kafka的高层次Consumer API来实现的。receiver从Kafka中获取的数据都是存储在Spark Executor的内存中的（如果突然数据暴增，大量batch堆积，很容易出现内存溢出的问题），然后Spark Streaming启动的job会去处理那些数据。 然而，在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用Spark Streaming的预写日志机制（Write Ahead Log，WAL）。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。 xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka-0-8_2.11&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt; scala123456789101112131415161718192021222324252627282930313233343536373839404142package com.ysss.bigdata.spark.streamingimport java.io.&#123;BufferedReader, InputStreamReader&#125;import java.net.Socketimport org.apache.spark.SparkConfimport org.apache.spark.storage.StorageLevelimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.kafka.KafkaUtilsimport org.apache.spark.streaming.receiver.Receiverimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming05_DStream_Kafka &#123; def main(args: Array[String]): Unit = &#123; // TODO 配置对象 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") // TODO 环境对象 val ssc = new StreamingContext(sparkConf, Seconds(5)) // TODO 数据处理 // 使用0.8版本的kafka - 接收器方式 // 访问kakfa会有相应的工具类 val kafkaDS: ReceiverInputDStream[(String, String)] = KafkaUtils.createStream( ssc, \"linux1:2181,linux2:2181,linux3:2181\", \"ysss191125\", Map(\"ysss191125\" -&gt; 3) ) // Kafka消息传递的时候以k-v对 // k - 传值的时候提供的，默认为null,主要用于分区 // v - message kafkaDS.map(_._2).print() // TODO 关闭连接环境 ssc.start() ssc.awaitTermination() &#125;&#125; kafka 0-8 Direct 模式这种新的不基于Receiver的直接方式，是在Spark 1.3中引入的，从而能够确保更加健壮的机制。替代掉使用Receiver来接收数据后，这种方式会周期性地查询Kafka，来获得每个topic+partition的最新的offset，从而定义每个batch的offset的范围。当处理数据的job启动时，就会使用Kafka的简单consumer api来获取Kafka指定offset范围的数据。 自动维护 offset scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.ysss.bigdata.spark.streamingimport kafka.serializer.StringDecoderimport org.apache.kafka.clients.consumer.ConsumerConfigimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.InputDStreamimport org.apache.spark.streaming.kafka.KafkaUtilsimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming07_DStream_Kafka_Direct1 &#123; def main(args: Array[String]): Unit = &#123; // TODO 这种方式，可以保证数据不丢失，但是可能会出现数据重复消费 // TODO 环境对象 - 从checkpoint中读取数据偏移量 // checkpoint还保存了计算逻辑,不适合扩展功能 // checkpoint会延续计算，但是可能会压垮内存 // checkpoint一般的存储路径为HDFS，所以会导致小文件过多。性能受到影响 // 不推荐使用 val ssc: StreamingContext = StreamingContext.getActiveOrCreate(\"scp\", () =&gt; getStreamingContext) // TODO 关闭连接环境 ssc.start() ssc.awaitTermination() &#125; def getStreamingContext () = &#123; // TODO 配置对象 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) ssc.checkpoint(\"scp\") // TODO 数据处理 // 使用0.8版本的kafka - Direct方式 - 自动维护Offset // TODO 默认情况下，SparkStreaming采用checkpoint来保存kafka的数据偏移量 // 访问kakfa会有相应的工具类 val kafkaParamMap = Map( ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG -&gt; \"linux1:9092,linux2:9092,linux3:9092\", ConsumerConfig.GROUP_ID_CONFIG -&gt; \"ysss191125new\" ) val kafkaDS: InputDStream[(String, String)] = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder]( ssc, kafkaParamMap, Set(\"ysss191125new\") ) kafkaDS.map(_._2).print() kafkaDS.print() ssc &#125;&#125; 手动维护 offset scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.ysss.bigdata.spark.streamingimport kafka.common.TopicAndPartitionimport kafka.message.MessageAndMetadataimport kafka.serializer.StringDecoderimport org.apache.kafka.clients.consumer.ConsumerConfigimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.InputDStreamimport org.apache.spark.streaming.kafka.&#123;HasOffsetRanges, KafkaUtils, OffsetRange&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming08_DStream_Kafka_Direc2 &#123; def main(args: Array[String]): Unit = &#123; // TODO 配置对象 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) // TODO 数据处理 // 使用0.8版本的kafka - Direct方式 - 手动维护Offset // 所谓的手动维护，其实就是开发人员自己获取偏移量，并进行保存处理。 // 通过保存的偏移量，可以动态获取kafka中指定位置的数据 // offset会保存到kakfa集群的系统主题中__consumer_offsets val kafkaMap = Map( ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG -&gt; \"linux1:9092,linux2:9092,linux3:9092\", ConsumerConfig.GROUP_ID_CONFIG -&gt; \"ysss191125123\" ) val fromOffsets = Map( (TopicAndPartition(\"ysss191125new\", 0), 0L), (TopicAndPartition(\"ysss191125new\", 1), 1L), (TopicAndPartition(\"ysss191125new\", 2), 2L) ) // TODO 从kafka中获取指定topic中指定offset的数据 val kafkaDS: InputDStream[String] = KafkaUtils.createDirectStream[String, String, StringDecoder, StringDecoder, String]( ssc, kafkaMap, fromOffsets, (m:MessageAndMetadata[String, String]) =&gt; m.message() ) var offsetRanges = Array.empty[OffsetRange] // 转换 // 获取偏移量，一定要在最初的逻辑中获取，防止数据处理完毕后，无偏移量信息 kafkaDS.transform(rdd =&gt; &#123; // 获取RDD中的偏移量范围 // 默认Spark中的RDD是没有offsetRanges方法，所以必须转换类型后才能使用 // RDD 和 HasOffsetRanges有关系 offsetRanges = rdd.asInstanceOf[HasOffsetRanges].offsetRanges rdd &#125;).foreachRDD(rdd=&gt;&#123; for (o &lt;- offsetRanges) &#123; println(s\"$&#123;o.topic&#125; $&#123;o.partition&#125; $&#123;o.fromOffset&#125; $&#123;o.untilOffset&#125;\") &#125; rdd.foreach(println) &#125;) ssc.start() ssc.awaitTermination() &#125;&#125; kafka 0-10 Direct 模式xml12345&lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-streaming-kafka-0-10_2.11&lt;/artifactId&gt; &lt;version&gt;2.4.5&lt;/version&gt;&lt;/dependency&gt; scala1234567891011121314151617181920212223242526272829303132333435363738394041package com.ysss.bigdata.spark.streamingimport org.apache.kafka.clients.consumer.&#123;ConsumerConfig, ConsumerRecord&#125;import org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.InputDStreamimport org.apache.spark.streaming.kafka010.&#123;ConsumerStrategies, KafkaUtils, LocationStrategies&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming08_DStream_Kafka_Direc2 &#123; def main(args: Array[String]): Unit = &#123; // TODO 配置对象 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) // TODO 数据处理 // 使用0.10版本的kafka - Direct方式 - 自动维护Offset // LocationStrategy : 位置策略 // ConsumerStrategies : 消费策略 // TODO sealed : 用于修饰类的关键字，表示密封类 // 要求子类如果是样例类，必须全部在同一个源码文件中 val kafkaMap = Map( ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG -&gt; \"linux1:9092,linux2:9092,linux3:9092\", ConsumerConfig.GROUP_ID_CONFIG -&gt; \"ysss191125123\", ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG -&gt; \"org.apache.kafka.common.serialization.StringDeserializer\", ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG -&gt; \"org.apache.kafka.common.serialization.StringDeserializer\" ) val kafkaDS: InputDStream[ConsumerRecord[String, String]] = KafkaUtils.createDirectStream[String, String]( ssc, LocationStrategies.PreferConsistent, ConsumerStrategies.Subscribe[String, String]( Set(\"ysss191125new\"), kafkaMap ) ) kafkaDS.map(_.value()).print() ssc.start() ssc.awaitTermination() &#125;&#125; 手动维护可参考官网，和0-8手动维护类似。 spark-streaming如何保证数据精准一次性处理呢？ scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ysss.bigdata.spark.streamingimport kafka.common.TopicAndPartitionimport kafka.message.MessageAndMetadataimport kafka.serializer.StringDecoderimport org.apache.kafka.clients.consumer.ConsumerConfigimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.InputDStreamimport org.apache.spark.streaming.kafka.&#123;HasOffsetRanges, KafkaUtils, OffsetRange&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming09_DStream_Kafka_Direc3 &#123; def main(args: Array[String]): Unit = &#123; // TODO 配置对象 val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) // TODO 数据处理 // SparkStreaming消费Kafka数据时，手动维护offset的思路 // TODO 1. 从指定的位置获取当前业务中保存的数据偏移量 // mysql =&gt; message offset =&gt; 5 // TODO 2. 从kafka中对应的分区里根据偏移量获取数据 // topicAndPartition =&gt; topic : xxx, partition : 0, offset : 5 // TODO 3. 消费数据时，需要将消费数据的偏移量拿到。 // KafkaRDD =&gt; offsetRange =&gt; (5, 100) // TODO 4. 执行业务操作。要求，偏移量的更新和业务要求在同一个事务中 // Tx start // service // commit - offset -&gt; mysql // Tx commit // TODO 4.1 如果不使用事务，那么可能业务成功，但是offset提交失败 // 会导致数据重复消费 // TODO 4.2 如果不使用事务，那么可能offset提交成功，但是业务失败 // 会导致数据丢失 // TODO 4.3 分布式事务， 如果中间出现shuffle，怎么办？ // 所以需要将数据拉取到driver端进行事务操作，保证数据不会出现问题。 // 这样会导致driver的性能下降，所以其实不是一个好的选择。 // SparkStreaming =&gt; 基本要求： 不丢失数据 // Flink =&gt; 数据精准一次性处理。 ssc.start() ssc.awaitTermination() &#125;&#125; 消费kafka数据模式总结Code123456789101112131415161718192021- 0-8 ReceiverAPI: 1) 专门的Executor读取数据，速度不统一 2) 跨机器传输数据 3) Executor读取数据通过多个线程的方式，想要增加并行度，则需要多个流union 4) offset存储在zookeeper中- 0-8 DirectAPI: 1) Executor读取数据并计算 2) 增加Executor个数来增加消费的并行度 3) offset存储 a. CheckPoint(getActiveOrCreate方式创建StreamingContext) b. 手动维护(有事务的存储系统) 4) 获取offset必须在第一个调用的算子中： offsetRanges &#x3D; rdd.asInstanceOf[HasOffsetRanges].offsetRanges- 0-10 DirectAPI: 1) Executor读取数据并计算 2) 增加Executor个数来增加消费的并行度 3) offset存储 a. __consumer_offsets系统主题中 b. 手动维护(有事务的存储系统) DStream转换DStream上的操作与RDD的类似，分为Transformations（转换）和Output Operations（输出）两种，此外转换操作中还有一些比较特殊的原语，如：updateStateByKey()、transform()以及各种Window相关的原语。 无状态转化操作无状态转化操作就是把简单的RDD转化操作应用到每个批次上，也就是转化DStream中的每一个RDD。部分无状态转化操作列在了下表中。注意，针对键值对的DStream转化操作(比如 reduceByKey())要添加import StreamingContext._才能在Scala中使用。 需要记住的是，尽管这些函数看起来像作用在整个流上一样，但事实上每个DStream在内部是由许多RDD（批次）组成，且无状态转化操作是分别应用到每个RDD上的。 例如：reduceByKey()会归约每个时间区间中的数据，但不会归约不同区间之间的数据。 transformtransform允许DStream上执行任意的RDD-to-RDD函数。即使这些函数并没有在DStream的API中暴露出来，通过该函数可以方便的扩展Spark API。该函数每一批次调度一次。其实也就是对DStream中的RDD应用转换。 scala12345678910111213141516171819202122232425262728293031package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming10_DStream_WordCount &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) val socketDS: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999) // TODO 可以将DStream转换为RDD进行操作。 // DStream =&gt; old RDD =&gt; new RDD =&gt; new DStream val resultDS: DStream[(String, Int)] = socketDS.transform( rdd =&gt; &#123; val flatRDD = rdd.flatMap(_.split(\" \")) val mapRDD = flatRDD.map((_, 1)) val reduceRDD = mapRDD.reduceByKey(_ + _) reduceRDD &#125; ) resultDS.print() ssc.start() ssc.awaitTermination() &#125;&#125; 相比直接在DStream上进行操作，transform的优势 scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming11_DStream_Transform &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) val socketDS: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999) // TODO transform可以获取底层的RDD进行处理 // TODO transform可以周期性的执行driver的代码逻辑 // Code =&gt; Driver// val newDS: DStream[String] = socketDS.map(// dataString =&gt; &#123;// // Code = Executor// \"string : \" + dataString// &#125;// ) // Code = Driver // JDBC.getData(); val newDS1: DStream[String] = socketDS.transform( rdd =&gt; &#123; // Code = Driver // JDBC.getData(); println(Thread.currentThread().getName) rdd.map( dataString =&gt; &#123; // Code = Executor \"string : \" + dataString // JDBC.updateData(); &#125; ) &#125; ) newDS1.print() ssc.start() ssc.awaitTermination() &#125;&#125; join两个流之间的join需要两个流的批次大小一致，这样才能做到同时触发计算。计算过程就是对当前批次的两个流中各自的RDD进行join，与两个RDD的join效果相同。 scala123456789101112131415161718192021222324252627package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming12_DStream_Join &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) val socketDS1: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999) val socketDS2: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 8888) val ds1: DStream[(String, Int)] = socketDS1.map((_,1)) val ds2: DStream[(String, Int)] = socketDS2.map((_,1)) val joinDS: DStream[(String, (Int, Int))] = ds1.join(ds2) joinDS.print() ssc.start() ssc.awaitTermination() &#125;&#125; 有状态转化操作UpdateStateByKeyUpdateStateByKey原语用于记录历史记录，有时，我们需要在DStream中跨批次维护状态(例如流计算中累加wordcount)。针对这种情况，updateStateByKey()为我们提供了对一个状态变量的访问，用于键值对形式的DStream。给定一个由(键，事件)对构成的 DStream，并传递一个指定如何根据新的事件更新每个键对应状态的函数，它可以构建出一个新的 DStream，其内部数据为(键，状态) 对。 updateStateByKey() 的结果会是一个新的DStream，其内部的RDD 序列是由每个时间区间对应的(键，状态)对组成的。 updateStateByKey操作使得我们可以在用新信息进行更新时保持任意的状态。为使用这个功能，需要做下面两步： 定义状态，状态可以是一个任意的数据类型。 定义状态更新函数，用此函数阐明如何使用之前的状态和来自输入流的新值对状态进行更新。 使用updateStateByKey需要对检查点目录进行配置，会使用检查点来保存状态。 scala1234567891011121314151617181920212223242526272829303132333435363738package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming13_DStream_State &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) ssc.checkpoint(\"scp\") val socketDS = ssc.socketTextStream(\"localhost\", 9999) val wordDS: DStream[String] = socketDS.flatMap(_.split(\" \")) val wordToOneDS: DStream[(String, Int)] = wordDS.map((_,1)) // TODO 使用有状态操作updateStateByKey保存数据 // SparkStreaming的状态保存依赖的是checkpoint,所以需要设定相关路径 val wordToCountDS: DStream[(String, Long)] = wordToOneDS.updateStateByKey[Long]( // 累加器 = 6 // UDAF = 8 // TODO 第一个参数表示相同key的value数据集合 // TODO 第二个参数表示相同key的缓冲区的数据 (seq: Seq[Int], buffer: Option[Long]) =&gt; &#123; // TODO 返回值表示更新后的缓冲区的值 val newBufferValue = buffer.getOrElse(0L) + seq.sum Option(newBufferValue) &#125; ) wordToCountDS.print() ssc.start() ssc.awaitTermination() &#125;&#125; WindowOperationsWindow Operations可以设置窗口的大小和滑动窗口的间隔来动态的获取当前Steaming的允许状态。所有基于窗口的操作都需要两个参数，分别为窗口时长以及滑动步长。 窗口时长：计算内容的时间范围； 滑动步长：隔多久触发一次计算。 注意：这两者都必须为采集周期大小的整数倍。 【回顾】scala语言中的window scala123456789101112131415161718192021222324package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.DStreamimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming14_DStream_Window &#123; def main(args: Array[String]): Unit = &#123; val list = List(1,2,3,4,5,6,7,8) // overflow : 滚动 -&gt; StackOverflowError -&gt; 栈溢出 // 滑动 // flatMap =&gt; 整体-&gt;个体 // sliding =&gt; 整体连续部分（3） -&gt; 整体 // 将sliding中的范围称之为窗口，其中的数据就称之为窗口数据 // 窗口可以动态调整，向后滑动。 val iterator: Iterator[List[Int]] = list.sliding(3, 2) while ( iterator.hasNext ) &#123; println(iterator.next()) &#125; &#125;&#125; window(windowLength, slideInterval): 基于对源DStream窗化的批次进行计算返回一个新的Dstream； scala12345678910111213141516171819202122232425262728293031323334package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming15_DStream_Window1 &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(3)) // 滑窗 val socketDS: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999) // 设定窗口。将2个采集周期的数据当成一个整体进行处理 // 默认窗口是可以滑动的。滑动的幅度为一个采集周期 // 可以动态改变滑动幅度 // 如果两个窗口移动过程中，没有重合的数据，称之为滚动窗口 // window方法的第一个参数表示窗口的范围大小，以采集周期为单位 // window方法的第二个参数表示窗口的滑动幅度，也表示计算的周期 val windowDS: DStream[String] = socketDS.window( Seconds(6), Seconds(3)) windowDS .flatMap(_.split(\" \")) .map((_,1)) .reduceByKey(_+_) .print() ssc.start() ssc.awaitTermination() &#125;&#125; reduceByKeyAndWindow(func, windowLength, slideInterval, [numTasks]): 当在一个(K,V)对的DStream上调用此函数，会返回一个新(K,V)对的DStream，此处通过对滑动窗口中批次数据使用reduce函数来整合每个key的value值。 scala123456789101112131415161718192021222324252627package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming17_DStream_Window3 &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(3)) // 滑窗 val socketDS: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999) val wordToOneDS: DStream[(String, Int)] = socketDS .flatMap(_.split(\" \")) .map((_, 1)) val windowDS: DStream[(String, Int)] = wordToOneDS.reduceByKeyAndWindow( (x: Int, y: Int) =&gt; x + y, Seconds(6), Seconds(3) ) windowDS.print() ssc.start() ssc.awaitTermination() &#125;&#125; reduceByKeyAndWindow(func, invFunc, windowLength, slideInterval, [numTasks]): 这个函数是上述函数的变化版本，每个窗口的reduce值都是通过用前一个窗的reduce值来递增计算。通过reduce进入到滑动窗口数据并”反向reduce”离开窗口的旧数据来实现这个操作。一个例子是随着窗口滑动对keys的“加”“减”计数。通过前边介绍可以想到，这个函数只适用于”可逆的reduce函数”，也就是这些reduce函数有相应的”反reduce”函数(以参数invFunc形式传入)。如前述函数，reduce任务的数量通过可选参数来配置。 scala1234567891011121314151617181920212223242526272829303132333435package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming19_DStream_Window5 &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(3)) ssc.checkpoint(\"scp\") // 滑窗 val socketDS: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999) val wordToOneDS: DStream[(String, Int)] = socketDS.map(num=&gt;(\"a\", 1)) val windowDS: DStream[(String, Int)] = wordToOneDS.reduceByKeyAndWindow( (x: Int, y: Int) =&gt; &#123; val sum = x + y println( sum + \"=\" + x + \"+\" + y ) sum &#125;, (x:Int, y:Int) =&gt; &#123; val diff = x - y println( diff + \"=\" + x + \"-\" + y ) diff &#125;, Seconds(6), Seconds(3) ) windowDS.print() ssc.start() ssc.awaitTermination() &#125;&#125; countByWindow(windowLength, slideInterval): 返回一个滑动窗口计数流中的元素个数； scala1234567891011121314151617181920212223242526package com.ysss.bigdata.spark.streamingimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming18_DStream_Window4 &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(3)) ssc.checkpoint(\"scp\") // 滑窗 val socketDS: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999) // 对窗口的数据进行计数，会使用checkpoint进行保存 val countDS: DStream[Long] = socketDS.countByWindow(Seconds(6), Seconds(3)) countDS.print() ssc.start() ssc.awaitTermination() &#125;&#125; DStream输出输出操作指定了对流数据经转化操作得到的数据所要执行的操作(例如把结果推入外部数据库或输出到屏幕上)。与RDD中的惰性求值类似，如果一个DStream及其派生出的DStream都没有被执行输出操作，那么这些DStream就都不会被求值。如果StreamingContext中没有设定输出操作，整个context就都不会启动。 输出操作如下： print()：在运行流程序的驱动结点上打印DStream中每一批次数据的最开始10个元素。这用于开发和调试。在Python API中，同样的操作叫print()。 saveAsTextFiles(prefix, [suffix])：以text文件形式存储这个DStream的内容。每一批次的存储文件名基于参数中的prefix和suffix。”prefix-Time_IN_MS[.suffix]”。 saveAsObjectFiles(prefix, [suffix])：以Java对象序列化的方式将Stream中的数据保存为 SequenceFiles . 每一批次的存储文件名基于参数中的为”prefix-TIME_IN_MS[.suffix]”. Python中目前不可用。 saveAsHadoopFiles(prefix, [suffix])：将Stream中的数据保存为 Hadoop files. 每一批次的存储文件名基于参数中的为”prefix-TIME_IN_MS[.suffix]”。Python API 中目前不可用。 foreachRDD(func)：这是最通用的输出操作，即将函数 func 用于产生于 stream的每一个RDD。其中参数传入的函数func应该实现将每一个RDD中数据推送到外部系统，如将RDD存入文件或者通过网络将其写入数据库。 通用的输出操作foreachRDD()，它用来对DStream中的RDD运行任意计算。这和transform() 有些类似，都可以让我们访问任意RDD。在foreachRDD()中，可以重用我们在Spark中实现的所有行动操作。比如，常见的用例之一是把数据写到诸如MySQL的外部数据库中。 注意： 1) 连接不能写在driver层面（序列化） 2) 如果写在foreach则每个RDD中的每一条数据都创建，得不偿失； 3) 增加foreachPartition，在分区创建（获取）。 方法一：性能低，每个RDD要连接一次 scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.ysss.bigdata.spark.streamingimport java.sql.&#123;DriverManager, PreparedStatement&#125;import org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming20_DStream_Output &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) val socketDS = ssc.socketTextStream(\"localhost\", 9999) // 将数据保存到MySQL数据库中 // id, name, age socketDS.foreachRDD(rdd=&gt;&#123; rdd.foreach(data=&gt;&#123; // 解决性能问题 val datas = data.split(\",\") val id = datas(0).toInt val name = datas(1) val age = datas(2).toInt // TODO 加载数据库驱动 Class.forName(\"com.mysql.jdbc.Driver\") // TODO 建立链接和操作对象 val conn = DriverManager.getConnection( \"jdbc:mysql://linux1:3306/rdd\", \"root\",\"000000\") val sql = \"insert into user (id ,name, age) values (?, ?, ?)\" val statement: PreparedStatement = conn.prepareStatement(sql) statement.setInt(1, id) statement.setString(2, name) statement.setInt(3, age) // TODO 操作数据 statement.executeUpdate() // TODO 关闭连接 statement.close() conn.close() println(\"数据保存成功！！！\") &#125;) &#125;) ssc.start() ssc.awaitTermination() &#125;&#125; 方法二：把连接放到foreachRDD外面，但是根本执行不了，因为所有的连接对象都不支持序列化操作 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.ysss.bigdata.spark.streamingimport java.sql.&#123;DriverManager, PreparedStatement&#125;import org.apache.spark.SparkConfimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming21_DStream_Output1 &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) val socketDS = ssc.socketTextStream(\"localhost\", 9999) // 将数据保存到MySQL数据库中 // id, name, age // TODO 加载数据库驱动 Class.forName(\"com.mysql.jdbc.Driver\") // TODO 建立链接和操作对象 // TODO 所有的连接对象都不支持序列化操作 val conn = DriverManager.getConnection( \"jdbc:mysql://linux1:3306/rdd\", \"root\",\"000000\") val sql = \"insert into user (id ,name, age) values (?, ?, ?)\" val statement: PreparedStatement = conn.prepareStatement(sql) socketDS.foreachRDD(rdd=&gt;&#123; // TODO RDD的方法称之为算子，存在分布式计算，需要进行闭包检测 rdd.foreach(data=&gt;&#123; // 解决性能问题 val datas = data.split(\",\") val id = datas(0).toInt val name = datas(1) val age = datas(2).toInt statement.setInt(1, id) statement.setString(2, name) statement.setInt(3, age) // TODO 操作数据 //statement.addBatch() //statement.executeBatch() statement.executeUpdate() println(\"数据保存成功！！！\") &#125;) &#125;) // SparkException : Task not serializable // TODO 关闭连接 statement.close() conn.close() ssc.start() ssc.awaitTermination() &#125;&#125; 方法三：rdd.foreachPartition,以分区为单位进行遍历 scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.ysss.bigdata.spark.streamingimport java.sql.&#123;DriverManager, PreparedStatement&#125;import org.apache.spark.SparkConfimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;object SparkStreaming22_DStream_Output2 &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") val ssc = new StreamingContext(sparkConf, Seconds(5)) val socketDS = ssc.socketTextStream(\"localhost\", 9999) // 将数据保存到MySQL数据库中 // id, name, age socketDS.foreachRDD(rdd=&gt;&#123; //【注意】mapPartitions和foreachPartition的区别： // 以分区为单位进行转换 =&gt; 返回 //rdd.mapPartitions() // 以分区为单位进行遍历 =&gt; 不需要返回 rdd.foreachPartition( datas =&gt; &#123; // TODO 加载数据库驱动 Class.forName(\"com.mysql.jdbc.Driver\") // TODO 建立链接和操作对象 // TODO 所有的连接对象都不支持序列化操作 val conn = DriverManager.getConnection( \"jdbc:mysql://linux1:3306/rdd\", \"root\",\"000000\") val sql = \"insert into user (id ,name, age) values (?, ?, ?)\" val statement: PreparedStatement = conn.prepareStatement(sql) // datas 其实是scala的集合，所以不存在分布式计算的概念 datas.foreach( data =&gt; &#123; // 解决性能问题 val datas = data.split(\",\") val id = datas(0).toInt val name = datas(1) val age = datas(2).toInt statement.setInt(1, id) statement.setString(2, name) statement.setInt(3, age) // TODO 操作数据 //statement.addBatch() //statement.executeBatch() statement.executeUpdate() println(\"数据保存成功！！！\") &#125; ) // TODO 关闭连接 statement.close() conn.close() &#125; ) &#125;) ssc.start() ssc.awaitTermination() &#125;&#125; 优雅关闭流式任务需要7*24小时执行，但是有时涉及到升级代码需要主动停止程序，但是分布式程序，没办法做到一个个进程去杀死，所有配置优雅的关闭就显得至关重要了。 使用外部文件系统来控制内部程序关闭。 把spark.streaming.stopGracefullyOnShutdown参数设置成ture,Spark会在JVM关闭时正常关闭StreamingContext,而不是立马关闭 scala1sparkConf.set(\"spark.streaming.stopGracefullyOnShutdown\", \"true\") 案例： scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.ysss.bigdata.spark.streamingimport java.sql.&#123;DriverManager, PreparedStatement, ResultSet&#125;import org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.&#123;DStream, ReceiverInputDStream&#125;import org.apache.spark.streaming.&#123;Seconds, StreamingContext, StreamingContextState&#125;object SparkStreaming23_Stop &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"wordcount\") // TODO 配置优雅地关闭 sparkConf.set(\"spark.streaming.stopGracefullyOnShutdown\", \"true\") val ssc = new StreamingContext(sparkConf, Seconds(5)) val socketDS: ReceiverInputDStream[String] = ssc.socketTextStream(\"localhost\", 9999) val wordDS: DStream[String] = socketDS.flatMap(_.split(\" \")) val wordToOneDS: DStream[(String, Int)] = wordDS.map( (_, 1) ) val wordToCountDS: DStream[(String, Int)] = wordToOneDS.reduceByKey(_+_) wordToCountDS.print() ssc.start() new Thread( new Runnable &#123; override def run(): Unit = &#123; // TODO SparkStreaming是可以停止。但是停止的逻辑代码的位置？ // TODO stop方法不能放置在driver的主线程中。 // TODO 直接调用ssc的stop方法是不可以的。需要循环判断sparkStreaming是否应该关闭 while ( true ) &#123; // TODO 在Driver端应该设置标记，让当前关闭线程可以访问。可以动态改变状态。 // TODO 但是Driver端的标记何时更新，由谁更新都是不确定的。 // TODO 所以一般标记不是放置在Driver端，而是在第三方软件中：redis,zk,mysql,hdfs Class.forName(\"com.mysql.jdbc.Driver\") // TODO 建立链接和操作对象 // TODO 所有的连接对象都不支持序列化操作 val conn = DriverManager.getConnection( \"jdbc:mysql://linux1:3306/rdd\", \"root\",\"000000\") val sql = \"select age from user where id = 1\" val statement: PreparedStatement = conn.prepareStatement(sql) val rs: ResultSet = statement.executeQuery() rs.next() val age: Int = rs.getInt(1) if ( age &lt;= 20 ) &#123; // TODO 判断SSC的状态 val state: StreamingContextState = ssc.getState() if ( state == StreamingContextState.ACTIVE ) &#123; println(\"SparkStreaming的环境准备关闭...\") // TODO 优雅地关闭SSC // 将现有的数据处理完再关闭就是优雅地关闭 ssc.stop(true, true) System.exit(0) &#125; &#125; Thread.sleep(1000 * 5) &#125; &#125; &#125; ).start() ssc.awaitTermination() // TODO Thread 线程停止的方式？run方法执行完毕 // 为什么不调用stop方法停止线程？因为会出现数据安全问题 // i++ =&gt; 1), 2) // new Thread().stop() &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"},{"name":"spark-streaming","slug":"spark-streaming","permalink":"https://masteryang4.github.io/tags/spark-streaming/"},{"name":"实时大数据","slug":"实时大数据","permalink":"https://masteryang4.github.io/tags/%E5%AE%9E%E6%97%B6%E5%A4%A7%E6%95%B0%E6%8D%AE/"}]},{"title":"redis为什么那么快","slug":"redis为什么那么快","date":"2020-06-16T15:55:38.000Z","updated":"2020-06-16T15:57:31.422Z","comments":true,"path":"2020/06/16/redis为什么那么快/","link":"","permalink":"https://masteryang4.github.io/2020/06/16/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB/","excerpt":"","text":"redis是单线程的，为什么那么快 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗 使用多路I/O复用模型，非阻塞IO 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Redis","slug":"大数据/Redis","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Redis/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"数据库","slug":"数据库","permalink":"https://masteryang4.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"缓存","slug":"缓存","permalink":"https://masteryang4.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://masteryang4.github.io/tags/JavaWeb/"}]},{"title":"Spark的WordCount到底有几个RDD","slug":"Spark的WordCount到底有几个RDD","date":"2020-06-16T05:54:59.000Z","updated":"2020-06-16T05:57:32.010Z","comments":true,"path":"2020/06/16/Spark的WordCount到底有几个RDD/","link":"","permalink":"https://masteryang4.github.io/2020/06/16/Spark%E7%9A%84WordCount%E5%88%B0%E5%BA%95%E6%9C%89%E5%87%A0%E4%B8%AARDD/","excerpt":"","text":"简介 本文转载自 https://blog.csdn.net/zhongqi2513/article/details/81513587 这样的一句标准的sparkcore的wordcount的代码到底能要产生几个RDD呢。相信大家对于一个标准的WordCount的代码一定不陌生： scala12345sc.textFile(\"hdfs://myha01/wc/input/words.txt\") .flatMap(_.split(\" \")) .map((_,1)) .reduceByKey(_+_) .saveAsTextFile(\"hdfs://myha01/wc/output/\") 这局代码： 1、开始使用了一个textFile用来读取数据的方法 2、中间使用了三个标准的RDD的操作算子： flatMap(_.split(&quot; &quot;)) 负责把由每一行组成的RDD按照空格切开压平成标准的由单词组成的RDD map((_,1))负责把每个单词word变成（word,1）每个单词出现一次 reduceByKey(_+_)负责把按照key相同也就是单词相同的key-value划分成一组，然后每一组做count聚合，最终就得出了输入文件中，每个单词出现了多少次。 3、最后，使用了一个saveAsTextFile的方法来存储数据 那到底这句代码中执行过程中，是不是刚好每个算子生成一个RDD呢？ 很不幸，不是的。如果需要知晓答案，最好的方式，就是翻阅参与运算的每个算子到底做了什么事情。 解析接下来是详细分析： 1、首先看sc.textFile(“hdfs://myha01/wc/input/words.txt”)：textFile方法在SparkContext类中 接着看textFile中的hadoopFile方法的实现： 通过这个代码可以得知，在hadoopFile的内部产生了第一个RDD：HadoopRDD 接着回到textFile方法： 发现，其实返回的HadoopRDD又调用了map算子，看map算子的实现： map算子的内部实现中，又创建了一个RDD，这就是第二个RDD： MapPartitionsRDD 那也就是说，textFile算子的最终返回值就是第二个RDD：MapPartitionsRDD 接着看：flatMap(_.split(“ “))算子的操作实现：flatMap算子在RDD中 所以flatMap(_.split(“ “))算子操作产生了第三个RDD：MapPartitionsRDD 接着看map((_,1))算子操作：map算子在RDD类中 map((_,1))算子的具体实现依然是简单的new MapPartitionRDD的方式生成第四个RDD：MapPartitionsRDD 接着看：reduceByKey(+)算子的具体实现：reduceByKey在PairRDDFunctions类中 跳到： 跳到： 到这个地方说明：reduceByKey算子的返回值其实是创建了第五个RDD：ShuffledRDD 接着看：saveAsTextFile(“hdfs://myha01/wc/output/“)算子的具体实现：saveAsTextFile算子在RDD类中 this.mapPartitions这句代码在调用的时候，在mapPartitions的内部，其实又创建了第六个RDD：MapPartitionRDD 接着回到：saveAsTextFile方法的实现，其实返现，最后一句话在调用中，也会生成一个RDD 这就是第七个RDD：MapPartitionRDD 到底为止，其他的地方，是没有再产生RDD的。 所以按照刚才的分析得出的最终结论是： Code1234567第一个RDD：HadoopRDD第二个RDD：MapPartitionsRDD第三个RDD：MapPartitionsRDD第四个RDD：MapPartitionsRDD第五个RDD：ShuffledRDD第六个RDD：MapPartitionRDD第七个RDD：MapPartitionRDD 其实，在执行saveAsTextFile之前，我们可以通过RDD提供的toDebugString看到这些个算子在调用的时候到底产生了多少个RDD: 望各位仁兄牢记。如果不记得，请翻阅源码。本篇文章是基于最新的Spark-2.3.1的版本 小结7个RDD，2+1+1+1+2 scala12345sc.textFile(\"hdfs://myha01/wc/input/words.txt\") .flatMap(_.split(\" \")) .map((_,1)) .reduceByKey(_+_) .saveAsTextFile(\"hdfs://myha01/wc/output/\") 算子 产生的RDD sc.textFile(&quot;hdfs://myha01/wc/input/words.txt&quot;) 第一个RDD：HadoopRDD第二个RDD：MapPartitionsRDD .flatMap(_.split(&quot; &quot;)) 第三个RDD：MapPartitionsRDD .map((_,1)) 第四个RDD：MapPartitionsRDD .reduceByKey(_+_) 第五个RDD：ShuffledRDD .saveAsTextFile(&quot;hdfs://myha01/wc/output/&quot;) 第六个RDD：MapPartitionRDD第七个RDD：MapPartitionRDD","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"},{"name":"spark-core","slug":"spark-core","permalink":"https://masteryang4.github.io/tags/spark-core/"}]},{"title":"常用排序算法总结","slug":"常用排序算法总结","date":"2020-06-15T09:31:13.000Z","updated":"2020-06-15T09:35:34.260Z","comments":true,"path":"2020/06/15/常用排序算法总结/","link":"","permalink":"https://masteryang4.github.io/2020/06/15/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"冒泡排序java1234567891011121314151617181920212223242526272829303132333435363738394041/** * 冒泡排序 时间复杂度 O(n^2) 空间复杂度O(1) */public class BubbleSort &#123; public static void bubbleSort(int[] data) &#123; System.out.println(\"开始排序\"); int arrayLength = data.length; for (int i = 0; i &lt; arrayLength - 1; i++) &#123; boolean flag = false; for (int j = 0; j &lt; arrayLength - 1 - i; j++) &#123; if(data[j] &gt; data[j + 1])&#123; int temp = data[j + 1]; data[j + 1] = data[j]; data[j] = temp; flag = true; &#125; &#125; System.out.println(java.util.Arrays.toString(data)); if (!flag) break; &#125; &#125; public static void main(String[] args) &#123; int[] data = &#123; 9, -16, 21, 23, -30, -49, 21, 30, 30 &#125;; System.out.println(\"排序之前：\\n\" + java.util.Arrays.toString(data)); bubbleSort(data); System.out.println(\"排序之后：\\n\" + java.util.Arrays.toString(data)); &#125;&#125; 快速排序java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ys.shuzu;/** * 标准快排 * 【注意】 * 最左边为基准数（flag）的时候，从右开始往前遍历。 */public class Kuaisupaixu &#123; public static void quicksort(int[] arr, int left, int right) &#123; if (left &gt; right) &#123; return; &#125; int flag = arr[left]; int l = left; int r = right; int temp; while (l != r) &#123; while (arr[r] &gt;= flag &amp;&amp; l &lt; r) &#123; //【重点】 r -= 1; &#125; while (arr[l] &lt;= flag &amp;&amp; l &lt; r) &#123; l += 1; &#125; temp = arr[r]; arr[r] = arr[l]; arr[l] = temp; &#125; arr[left] = arr[l]; arr[l] = flag; quicksort(arr, left, l - 1); quicksort(arr, l + 1, right); &#125; public static void main(String[] args) &#123; int[] a = &#123;9, 2, 1, 5, 4, 8, 7, 6, 1, 0&#125;; quicksort(a, 0, a.length - 1); for (int i : a) &#123; System.out.print(i + \" \"); &#125; &#125;&#125; scala123456789101112/** * 快排 * 时间复杂度:平均时间复杂度为O(nlogn) * 空间复杂度:O(logn)，因为递归栈空间的使用问题 */def quickSort(list: List[Int]): List[Int] = list match &#123; case Nil =&gt; Nil case List() =&gt; List() case head :: tail =&gt; val (left, right) = tail.partition(_ &lt; head) quickSort(left) ::: head :: quickSort(right) &#125; 归并排序核心思想：不断的将大的数组分成两个小数组，直到不能拆分为止，即形成了单个值。此时使用合并的排序思想对已经有序的数组进行合并，合并为一个大的数据，不断重复此过程，直到最终所有数据合并到一个数组为止。 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package com.ys.shuzu;import java.util.Arrays;/** * 【归并排序】 * 时间复杂度nlogn（平均，最好，最坏都是这个值） * 空间复杂度n（用空间换时间，时间上和快排差不多） */public class MergeSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; // int temp[] = new int[arr.length]; //归并排序需要一个额外空间 mergeSort(arr, 0, arr.length - 1, temp); System.out.println(\"归并排序后=\" + Arrays.toString(arr)); &#125; //分+合方法 public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; //中间索引 //向左递归进行分解 mergeSort(arr, left, mid, temp); //向右递归进行分解 mergeSort(arr, mid + 1, right, temp); //合并 merge(arr, left, mid, right, temp); &#125; &#125; //合并的方法 /** * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; // 初始化i, 左边有序序列的初始索引 int j = mid + 1; //初始化j, 右边有序序列的初始索引 int t = 0; // 指向temp数组的当前索引 //(一) //先把左右两边(有序)的数据按照规则填充到temp数组 //直到左右两边的有序序列，有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;//继续 //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 //即将左边的当前元素，填充到 temp数组 //然后 t++, i++ if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; //反之,将右边有序序列的当前元素，填充到temp数组 temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; //(二) //把有剩余数据的一边的数据依次全部填充到temp while (i &lt;= mid) &#123; //左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t += 1; i += 1; &#125; while (j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[j]; t += 1; j += 1; &#125; //(三) //将temp数组的元素拷贝到arr //注意，并不是每次都拷贝所有 t = 0; int tempLeft = left; // //第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tL=0 ri=3 //最后一次 tempLeft = 0 right = 7 while (tempLeft &lt;= right) &#123; arr[tempLeft] = temp[t]; t += 1; tempLeft += 1; &#125; &#125;&#125; scala123456789101112/** * 快排 * 时间复杂度:O(nlogn) * 空间复杂度:O(n) */def merge(left: List[Int], right: List[Int]): List[Int] = (left, right) match &#123; case (Nil, _) =&gt; right case (_, Nil) =&gt; left case (x :: xTail, y :: yTail) =&gt; if (x &lt;= y) x :: merge(xTail, right) else y :: merge(left, yTail) &#125; 二分查找scala12345678910111213141516171819/** * 二分查找 时间复杂度O(log2n);空间复杂度O(1) */ def binarySearch(arr:Array[Int],left:Int,right:Int,findVal:Int): Int=&#123; if(left&gt;right)&#123;//递归退出条件，找不到，返回-1 -1 &#125; val midIndex = (left+right)/2 if (findVal &lt; arr(midIndex))&#123;//向左递归查找 binarySearch(arr,left,midIndex-1,findVal) &#125;else if(findVal &gt; arr(midIndex))&#123;//向右递归查找 binarySearch(arr,midIndex+1,right,findVal) &#125;else&#123;//查找到，返回下标 midIndex &#125;&#125; java12345678910111213141516171819202122232425262728293031323334353637package com.ys.chazhao;/** 查找数目超过半数的值并打印，如果没有就打印0** 方法二：快速排序，中间的值就是数量为半数的值。*///&#123;1,2,3,2,2,2,5,4,2&#125;public class Banshuchazhao &#123; public static int MoreThanHalfNum_Solution(int[] array) &#123; int res = array[0], count = 1; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] == res) count++; else &#123; count--; &#125; if (count == 0) &#123; res = array[i]; count = 1; &#125; &#125; // 验证 count = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == res) count++; &#125; return count &gt; array.length / 2 ? res : 0; &#125; public static void main(String[] args) &#123; int i = MoreThanHalfNum_Solution(new int[]&#123;1, 2, 3, 2, 2, 2, 5, 4, 2&#125;); System.out.println(i); &#125;&#125; 拓展需求：当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到。 代码实现如下： scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000. //分析 1. 返回的结果是一个可变数组 ArrayBuffer 2. 在找到结果时，向左边扫描，向右边扫描 [条件] 3. 找到结果后，就加入到ArrayBuffer */ def binarySearch2(arr: Array[Int], l: Int, r: Int, findVal: Int): ArrayBuffer[Int] = &#123; //找不到条件? if (l &gt; r) &#123; return ArrayBuffer() &#125; val midIndex = (l + r) / 2 val midVal = arr(midIndex) if (midVal &gt; findVal) &#123; //向左进行递归查找 binarySearch2(arr, l, midIndex - 1, findVal) &#125; else if (midVal &lt; findVal) &#123; //向右进行递归查找 binarySearch2(arr, midIndex + 1, r, findVal) &#125; else &#123; println(\"midIndex=\" + midIndex) //定义一个可变数组 val resArr = ArrayBuffer[Int]() //向左边扫描 var temp = midIndex - 1 breakable &#123; while (true) &#123; if (temp &lt; 0 || arr(temp) != findVal) &#123; break() &#125; if (arr(temp) == findVal) &#123; resArr.append(temp) &#125; temp -= 1 &#125; &#125; //将中间这个索引加入 resArr.append(midIndex) //向右边扫描 temp = midIndex + 1 breakable &#123; while (true) &#123; if (temp &gt; arr.length - 1 || arr(temp) != findVal) &#123; break() &#125; if (arr(temp) == findVal) &#123; resArr.append(temp) &#125; temp += 1 &#125; &#125; return resArr &#125; 二叉树相关二叉树的特点 （1）树执行查找、删除、插入的时间复杂度都是O(logN) （2）遍历二叉树的方法包括前序、中序、后序 （3）非平衡树指的是根的左右两边的子节点的数量不一致 （4）在非空二叉树中，第i层的结点总数不超过 , i&gt;=1； （5）深度为h的二叉树最多有个结点(h&gt;=1)，最少有h个结点； （6）对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1； 定义节点以及前序、中序、后序遍历 scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147class TreeNode(treeNo:Int)&#123; val no = treeNo var left:TreeNode = null var right:TreeNode = null //后序遍历 def postOrder():Unit=&#123; //向左递归输出左子树 if(this.left != null)&#123; this.left.postOrder &#125; //向右递归输出右子树 if (this.right != null) &#123; this.right.postOrder &#125; //输出当前节点值 printf(\"节点信息 no=%d \\n\",no) &#125; //中序遍历 def infixOrder():Unit=&#123; //向左递归输出左子树 if(this.left != null)&#123; this.left.infixOrder() &#125; //输出当前节点值 printf(\"节点信息 no=%d \\n\",no) //向右递归输出右子树 if (this.right != null) &#123; this.right.infixOrder() &#125; &#125; //前序遍历 def preOrder():Unit=&#123; //输出当前节点值 printf(\"节点信息 no=%d \\n\",no) //向左递归输出左子树 if(this.left != null)&#123; this.left.postOrder() &#125; //向右递归输出右子树 if (this.right != null) &#123; this.right.preOrder() &#125; &#125; //后序遍历查找 def postOrderSearch(no:Int): TreeNode = &#123; //向左递归输出左子树 var resNode:TreeNode = null if (this.left != null) &#123; resNode = this.left.postOrderSearch(no) &#125; if (resNode != null) &#123; return resNode &#125; if (this.right != null) &#123; resNode = this.right.postOrderSearch(no) &#125; if (resNode != null) &#123; return resNode &#125; println(\"ttt~~\") if (this.no == no) &#123; return this &#125; resNode &#125; //中序遍历查找 def infixOrderSearch(no:Int): TreeNode = &#123; var resNode : TreeNode = null //先向左递归查找 if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no) &#125; if (resNode != null) &#123; return resNode &#125; println(\"yyy~~\") if (no == this.no) &#123; return this &#125; //向右递归查找 if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no) &#125; return resNode &#125; //前序查找 def preOrderSearch(no:Int): TreeNode = &#123; if (no == this.no) &#123; return this &#125; //向左递归查找 var resNode : TreeNode = null if (this.left != null) &#123; resNode = this.left.preOrderSearch(no) &#125; if (resNode != null)&#123; return resNode &#125; //向右边递归查找 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no) &#125; return resNode &#125; //删除节点 //删除节点规则 //1如果删除的节点是叶子节点，则删除该节点 //2如果删除的节点是非叶子节点，则删除该子树 def delNode(no:Int): Unit = &#123; //首先比较当前节点的左子节点是否为要删除的节点 if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null return &#125; //比较当前节点的右子节点是否为要删除的节点 if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null return &#125; //向左递归删除 if (this.left != null) &#123; this.left.delNode(no) &#125; //向右递归删除 if (this.right != null) &#123; this.right.delNode(no) &#125; &#125;&#125; 定义二叉树，前序、中序、后序遍历，前序、中序、后序查找，删除节点 scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class BinaryTree&#123; var root:TreeNode = null //后序遍历 def postOrder(): Unit = &#123; if (root != null)&#123; root.postOrder() &#125;else &#123; println(\"当前二叉树为空，不能遍历\")&#125;&#125; //中序遍历 def infixOrder(): Unit = &#123; if (root != null)&#123; root.infixOrder() &#125;else &#123; println(\"当前二叉树为空，不能遍历\") &#125; &#125; //前序遍历 def preOrder(): Unit = &#123; if (root != null)&#123; root.preOrder() &#125;else &#123; println(\"当前二叉树为空，不能遍历\") &#125; &#125; //后序遍历查找 def postOrderSearch(no:Int): TreeNode = &#123; if (root != null) &#123; root.postOrderSearch(no) &#125;else&#123; null &#125; &#125; //中序遍历查找 def infixOrderSeacher(no:Int): TreeNode = &#123; if (root != null) &#123; return root.infixOrderSearch(no) &#125;else &#123; return null &#125; &#125; //前序查找 def preOrderSearch(no:Int): TreeNode = &#123; if (root != null) &#123; return root.preOrderSearch(no) &#125;else&#123; //println(\"当前二叉树为空，不能查找\") return null &#125; &#125;//删除节点 def delNode(no:Int): Unit = &#123; if (root != null) &#123; //先处理一下root是不是要删除的 if (root.no == no)&#123; root = null &#125;else &#123; root.delNode(no) &#125; &#125; &#125;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"springboot精简教程","slug":"springboot精简教程","date":"2020-06-14T14:55:58.000Z","updated":"2020-06-14T15:02:26.437Z","comments":true,"path":"2020/06/14/springboot精简教程/","link":"","permalink":"https://masteryang4.github.io/2020/06/14/springboot%E7%B2%BE%E7%AE%80%E6%95%99%E7%A8%8B/","excerpt":"","text":"SpringBoot2.1 Spring分布式架构 2.2 SpringBoot 概述Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。 该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 2.3 为什么要使用SpringBoot说到为什么使用Spring Boot, 就不得不提到Spring框架的前世今生 Spring框架由于其繁琐的配置，一度被人认为“配置地狱”，各种XML、Annotation配置混合使用，让人眼花缭乱，而且如果出错了也很难找出原因。 通过SpringMVC框架部署和发布web程序，需要和系统外服务器进行关联，操作繁琐不方便。 Spring Boot是由Spring官方推出的一个新框架，对Spring进行了高度封装，是Spring未来的发展方向。使用SpringBoot框架后，可以帮助开发者快速搭建Spring框架，也可以帮助开发者快速启动一个Web服务，无须依赖外部Servlet容器，使编码变得简单，使配置变得简单，使部署变得简单，使监控变得简单。 2.4 Spring 前世今生1) Spring1.x 时代 在Spring1.x时代，都是通过xml文件配置bean 随着项目的不断扩大，需要将xml配置分放到不同的配置文件中 需要频繁的在java类和xml配置文件中切换。 2) Spring2.x时代 随着JDK 1.5带来的注解支持，Spring2.x可以使用注解对Bean进行申明和注入，大大的减少了xml配置文件，同时也大大简化了项目的开发。 那么，问题来了，究竟是应该使用xml还是注解呢？ 最佳实践： 应用的基本配置用xml，比如：数据源、资源文件等； 业务开发用注解，比如：Service中注入bean等； 3) Spring3.x到Spring4.x 从Spring3.x开始提供了Java配置方式，使用Java配置方式可以更好的理解你配置的Bean，现在我们就处于这个时代，并且Spring4.x和Springboot都推荐使用java配置的式。 java1234567891011121314151617181920212223//Spring 1.X//使用基本的框架类及配置文件（.xml）实现对象的声明及对象关系的整合。org.springframework.core.io.ClassPathResourceorg.springframework.beans.factory.xml.XmlBeanFactoryorg.springframework.context.support.ClassPathXmlApplicationContext //Spring 2.X//使用注解代替配置文件中对象的声明。简化配置。org.springframework.stereotype.@Componentorg.springframework.stereotype.@Controllerorg.springframework.stereotype.@Serviceorg.springframework.stereotype.@Repositoryorg.springframework.stereotype.@Scopeorg.springframework.beans.factory.annotation.@Autowired //Spring 3.X//使用更强大的注解完全代替配置文件。org.springframework.context.annotation.AnnotationConfigApplicationContextorg.springframework.context.annotation.@Configurationorg.springframework.context.annotation.@Beanorg.springframework.context.annotation.@Valueorg.springframework.context.annotation.@Import //Spring 4.X//使用条件注解强化之前版本的注解。org.springframework.context.annotation.@Conditional 2.5 自动创建一个SpringBoot项目1) 在Idea中new→Module→Spring Initializr 2) 给工程命名、设置包名等，其他默认即可 3) 选择工程的版本 4) 点击Next ，给工程命名，然后点击Finish 2.6 手动创建一个SpringBoot 项目2.6.1 创建Maven项目2.6.2 集成Spring Boot框架 修改pom.xml文件，增加Spring Boot框架的依赖关系及对Web环境的支持。 xml12345678910111213141516&lt;project&gt; ... &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;/parent&gt; ... &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ...&lt;/project&gt; Spring Boot版本为官方最新正式版2.2.2.RELEASE 以往的项目中，所有类库的依赖关系都需要我们自己导入到pom.xml文件中，但是SpringBoot项目增加spring-boot-starter-web依赖后，会自动加载web环境配置相关依赖(SpringMVC,Tomcat)，简化了我们的操作。 spring-boot-starter-parent：继承Spring Boot的相关参数 spring-boot-starter-xxx：代表一个Spring Boot模块 spring-boot-starter-web：代表Web模块，在这个模块中包含了许多依赖的JAR包 扩展:修改一下Maven编译插件的版本 xml12345&lt;properties&gt; &lt;!-- 设置Maven编译插件的版本 SpringBoot高版本用的Maven插件版本比较 高，STS没支持到，需手动指定 --&gt; &lt;maven-jar-plugin.version&gt;3.1.1&lt;/maven-jar-plugin.version&gt;&lt;/properties&gt; 2.6.3 增加程序代码 在src/main/java目录中增加类com.atguigu.springboot.SpringBootSelfApplication，并增加相应代码。 java1234567891011package com.atguigu.springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringBootSelfApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSelfApplication.class, args); &#125;&#125; SpringBoot项目中都会有一个以Application结尾的应用类，然后有一个标准的Java入口方法main方法。通过这个方法启动SpringBoot项目，方法中无需放入任何业务逻辑。 @SpringBootApplication注解是Spring Boot核心注解 右键点击项目或项目中的SpringBootSelfApplication类, 选择菜单Run as Spring BootApp，启动SpringBoot项目. 2.6.4 集成Tomcat服务器 SpringBoot内置了Tomcat，当增加Web依赖后执行main方法，等同于启动Tomcat服务器,默认端口号为8080。如果想具体指定,通过server.port来指定 默认情况下SpringBoot启动后，默认的context-path的值为/，从浏览器端访问项目时，,不需要加项目名，直接通过http://localhost:8080/请求名 来访问，如果想具体指定，通过server.servlet.context-path来指定 例如:在src/main/resources/目录中增加application.properties文件。 properties12server.servlet.context-path=/server.port=80 SpringBoot会自动读取src/main/resources/路径或着src/main/resources/config路径中的application.properties文件或application.yml文件。 2.6.5 为什么还会有配置文件Spring Boot我们称之为微框架，这里的“微”不是小和少的意思，而是“简”的意思，简单，简洁。 项目中大部分的基础配置由Spring Boot框架帮我们自动集成，简化了我们的配置，但是框架自身为了扩展性，依然需要提供配置文件。 上面的代码中只是简单的应用了Spring Boot框架，但是我们真正要做的是将SpringBoot应用到项目中，所以接下来我们增加对SpringMVC框架，Mybatis框架的集成。 2.7 SpringBoot 集成 Spring &amp; Spring Web MVC 基本的Spring Boot环境已经构建好了，现在需要配置Spring框架及SpringMVC框架的业务环境 2.7.1 @ComponentScan注解 通过@ComponentScan注解指定扫描的包 java1234567891011121314package com.atguigu.springboot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.ComponentScan;@ComponentScan(basePackages=\"com.atguigu\")@SpringBootApplicationpublic class SpringBootSelfApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSelfApplication.class, args); &#125;&#125; 默认扫描 默认扫描当前包com.atguigu.springboot和子包com.atguigu.springboot.* 如果还需要扫描其他的包，那么需要增加@ComponentScan注解,指定包名进行扫描。 2.7.2 增加控制器代码在src/main/java目录中增加类com.atguigu.springboot.controller.UserController，并增加相应代码。 java1234567891011121314151617181920package com.atguigu.springboot.controller;import java.util.HashMap;import java.util.Map;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class UserController &#123; @ResponseBody //返回Json数据 @RequestMapping(\"/getAllUser\") //指定请求URL public Object getAllUser() &#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"username\", \"张三\"); return map; &#125;&#125; 2.7.3 执行main方法启动应用访问路径http://localhost:8080[/应用路径名称]/ getAllUser页面打印JSON字符串即可 2.7.4 @Controller和@RestController区别@RestController等同于@Controller + @ResponseBody，所以上面的代码可以变为： java1234567891011121314151617181920package com.atguigu.springboot.controller;import java.util.HashMap;import java.util.Map;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123; @RequestMapping(\"/getAllUser\") //指定请求URL public Object getAllUser() &#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"username\", \"张三\"); return map; &#125;&#125; 2.7.5 页面跳转[了解]1) 如果需要转发跳转Jsp页面,可参考如下步骤 在pom.xml中加入如下依赖 xml12345678&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt; 将jsp页面存放在src/main/webapp目录下,Springboot默认从该目录下查找jsp页面 在application.properties文件中配置： properties12spring.mvc.view.prefix=/ spring.mvc.view.suffix=.jsp 2) 如需要进行重定向，可参考如下步骤 在请求处理方法中的返回值前面加上”redirect:” 重定向的页面同样存放在src/main/webapp下 2.8 SpringBoot集成通用Mapper2.8.1 通用Mapper简介通用mapper可以极大的方便开发人员进行CRUD操作，提供极其方便的单表增删改查。 一句话简单说，它就是个辅助mybatis极简单表开发的组件。它不是为了替代mybatis，而是让mybatis的开发更方便。 2.8.2 集成通用Mapper1) 在pom.xml中加入通用Mapper的starter xml12345678910&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2) 添加持久层代码 通用Mapper提供了Mapper接口，该接口中提供了常用的CRUD方法. 用户可以自己定义自己的Mapper接口，继承通用Mapper提供的Mapper接口， java1234567package com.atguigu.springboot.mapper;import com.atguigu.springboot.beans.User;import tk.mybatis.mapper.common.Mapper;public interface UserMapper extends Mapper&lt;User&gt; &#123;&#125; 3) 在src/main/resources下创建application.yml文件,配置数据源 yml1234567# jdbc配置spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/bigdata?serverTimezone=UTC username: root password: 1234 2.9 整合测试2.9.1 增加业务层代码1) 增加业务层接口 java123456789101112package com.atguigu.springboot.service;import java.util.List;import com.atguigu.springboot.beans.User;public interface UserService &#123; /** * 查询所有的用户 */ public List&lt;User&gt; selectAllUser();&#125; 2) 增加业务层实现类 java123456789101112131415161718192021package com.atguigu.springboot.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.atguigu.springboot.beans.User;import com.atguigu.springboot.mapper.UserMapper;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; selectAllUser() &#123; return userMapper.selectAll(); &#125;&#125; 2.9.2 增加控制层方法java1234567891011121314151617181920package com.atguigu.springboot.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.atguigu.springboot.service.UserService;@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @RequestMapping(\"/getAllUser\") //指定请求URL public Object getAllUser() &#123; return userService.selectAllUser(); &#125;&#125; 2.9.3 扫描Mapperjava1234567@MapperScan(basePackages = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBootSelfApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSelfApplication.class, args); &#125;&#125; 2.9.4 测试访问路径http://localhost:8080[/应用路径名称]/ getAllUser页面打印JSON字符串即可 2.10 Restful风格URL2.10.1 REST 简介REST（Representational State Transfer）又被称作表现层状态转换。它涉及到三个重要名词： 资源 所谓资源简单讲就是服务所能提供的数据，可以是实体数据也可是媒体类型，图片、PDF、文本等 表现层 何为变现层？简单说就是将数据以某种方式展现给用户，或者给客户返回一张图片等等动作称之为表现，通常是已JSON或XML形式展现数据 状态转换 状态转换就是对数据进行一系列的操作，因为资源本身并非一尘不变，随着需求的变化而变化。一个资源可能会随着需求的变化而经历一个资源创建、修改、查询、删除等过程，REST风格正是基于HTTP协议运行的，HTTP协议又被称为无状态协议，所以资源的变化需要在服务端完成， 简单用一句话概括就是：REST风格使用URL定位资源，用HTTP动词（GET,POST,DELETE,PUT）描述操作。 2.10.1 REST 规定 GET请求 获取资源 例如：/emp/1 获取id=1的员工信息 POST请求 添加资源 例如：/emp 添加员工信息 PUT请求 更新资源 例如：/emp/1 更新id=1的员工信息 DELETE请求 删除资源 例如：/emp/1 删除id=1的员工信息 2.10.2 Resulful风格URL 和普通URL对比普通URL:localhost:8888/SpringBootSelf/selectUser?id=1001&amp;username=zhangsan Restful: localhost:8888/SpringBootSelf/selectUser/1001/zhangsan 2.10.3 如何在后台处理Restful风格URL中的参数 客户端的URL:localhost:8888/SpringBootSelf/selectUser/1001 在@RequestMapping注解中使用 {} 占位符对应实际URL中的参数 java1234@RequestMapping(\"/selectUser/&#123;ids&#125;\")public User selectUser(@PathVariable(\"ids\") Integer id ) &#123; return userService.doSelectUser(id); &#125; 在方法中使用@PathVariable注解指定将占位符对应的URL中的参数值赋值给方法的形参. java1234@RequestMapping(\"/selectUser/&#123;ids&#125;\")public User selectUser(@PathVariable(\"ids\") Integer id ) &#123; return userService.doSelectUser(id); &#125; 2.10.4 转换PUT请求和DELETE请求[了解] PUT请求和DELETE请求需要通过POST请求来转换 发送POST请求我们需要在form表单中发送，所以我们需要使用SpringBoot的模板 转换的步骤： 1、添加Thymeleaf模块 xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 添加该模块后在main/resources目录下创建templates目录 2、在templates目录下创建index.html页面，添加form表单，请求方式设置为post，表单中设置一个隐藏域，name属性值为_method,value值为put（转换为PUT请求时的值）或delete（转换为DELETE请求时的值） html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"/getEmp/1\"&gt;获取员工&lt;/a&gt; &lt;form action=\"/emp/4\" method=\"post\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"删除员工\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 3、配置过滤器 创建一个类继承HiddenHttpMethodFilter 在类上添加@WebFilter java1234567import org.springframework.web.filter.HiddenHttpMethodFilter;import javax.servlet.annotation.WebFilter;@WebFilterpublic class MyFilter extends HiddenHttpMethodFilter &#123;&#125; 4、在启动类上添加@ServletComponentScan注解 java12345678@ServletComponentScan@MapperScan(basePackages = \"com.atguigu.springboot.mapper\")@SpringBootApplicationpublic class SpringBootSelfApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootSelfApplication.class, args); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://masteryang4.github.io/categories/JavaWeb/"},{"name":"springboot","slug":"JavaWeb/springboot","permalink":"https://masteryang4.github.io/categories/JavaWeb/springboot/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://masteryang4.github.io/tags/JavaWeb/"},{"name":"springboot","slug":"springboot","permalink":"https://masteryang4.github.io/tags/springboot/"}]},{"title":"spring精简教程","slug":"spring精简教程","date":"2020-06-14T14:55:47.000Z","updated":"2020-06-14T15:01:10.279Z","comments":true,"path":"2020/06/14/spring精简教程/","link":"","permalink":"https://masteryang4.github.io/2020/06/14/spring%E7%B2%BE%E7%AE%80%E6%95%99%E7%A8%8B/","excerpt":"","text":"简单了解框架框架，即framework。其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。 框架是对特定应用领域中的应用系统的部分设计和实现的整体结构。 因为软件系统发展到今天已经很复杂了，特别是服务器端软件，涉及到的知识，内容，问题太多。在某些方面使用别人成熟的框架，就相当于让别人帮你完成一些基础工作，你只需要集中精力完成系统的业务逻辑设计。而且框架一般是成熟，稳健的，他可以处理系统很多细节问题，比如，事务处理，安全性，数据流控制等问题。还有框架一般都经过很多人使用，所以结构很好，所以扩展性也很好，而且它是不断升级的，你可以直接享受别人升级代码带来的好处。 第1章 Spring1.1 Spring 概述1) Spring是一个开源框架 2) Spring为简化企业级开发而生，使用Spring，JavaBean就可以实现很多以前要靠EJB才能实现的功能。同样的功能，在EJB中要通过繁琐的配置和复杂的代码才能够实现，而在Spring中却非常的优雅和简洁。 3) Spring是一个IOC(DI)和AOP容器框架。 4) Spring的优良特性 ① 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API ② 依赖注入：DI——Dependency Injection，反转控制(IOC)最经典的实现。 ③ 面向切面编程：Aspect Oriented Programming——AOP ④ 容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期 ⑤ 组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。 ⑥ 一站式：在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了表述层的SpringMVC和持久层的Spring JDBC）。 5) Spring模块 1.2 Spring HelloWorld1) 创建一个Maven版的Java工程 2) 在pom.xml中加入对Spring的依赖 xml12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 3) 创建Spring的核心配置文件 File-&gt;New-&gt;Spring Bean Configuration File 为文件取名字 例如：applicationContext.xml xml1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 4) 编写组件 创建控制层组件 java12345678910package com.ys.spring.controller;/** * 控制层组件 处理客户端的请求，给客户端响应 */import com.ys.spring.service.UserService;public class UserController &#123; public void listAllUsers() &#123; &#125;&#125; 创建业务层组件接口 java1234567package com.ys.spring.service;/** * 业务层组件 处理业务逻辑 */public interface UserService &#123; public void doGetAllUser();&#125; 创建业务层组件实现类 java12345678910package com.ys.spring.service;import com.ys.spring.dao.UserDao;public class UserServiceImpl implements UserService&#123; @Override public void doGetAllUser() &#123; &#125;&#125; 创建持久层组件接口 java123456789package com.ys.spring.dao;/** * 持久层组件 负责数据库的CRUD操作 * */public interface UserDao &#123; public void selectAllUsers();&#125; 创建持久层组件实现类 java123456789package com.ys.spring.dao;public class UserDaoJdbcImpl implements UserDao &#123; @Override public void selectAllUsers() &#123; System.out.println(\"UserDaoJdbcImpl selectAllUsers Success .....\"); &#125;&#125; 在spring的核心配置文件中管理Bean xml123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 管理组件 --&gt; &lt;!-- bean: 对应一个被Spring管理的组件对象 id: bean的唯一标识 class: 组件对象对应的类的全类名 --&gt; &lt;bean id=\"userController\" class=\"com.ys.spring.controller.UserController\"&gt; &lt;/bean&gt; &lt;bean id=\"userServiceImpl\" class=\"com.ys.spring.service.UserServiceImpl\"&gt; &lt;/bean&gt; &lt;bean id=\"userDaoJdbcImpl\" class=\"com.ys.spring.dao.UserDaoJdbcImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 编写测试类 java123456789101112131415161718192021222324252627package com.ys.spring.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.ys.spring.controller.UserController;import com.ys.spring.dao.UserDao;import com.ys.spring.service.UserService;public class TestSpring &#123; @Test public void testSpringXML() &#123; //1. 先创建Spring的容器对象 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2. 从Spring的容器中获取Bean对象 UserController uc = ctx.getBean(\"userController\", UserController.class); System.out.println(\"uc:\" + uc); UserService us = ctx.getBean(\"userServiceImpl\",UserService.class); System.out.println(\"us:\" + us ); UserDao ud = ctx.getBean(\"userDaoJdbcImpl\",UserDao.class); System.out.println(\"ud:\" + ud ); &#125;&#125; 5) 组件装配 在控制层组件中定义业务层组件类型的属性 java123456789101112131415161718package com.ys.spring.controller;/** * 控制层组件 处理客户端的请求，给客户端响应 */import com.ys.spring.service.UserService;public class UserController &#123; private UserService userService ; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void listAllUsers() &#123; userService.doGetAllUser(); &#125;&#125; 在业务层组件中定义持久层组件类型的属性 java12345678910111213141516package com.ys.spring.service;import com.ys.spring.dao.UserDao;public class UserServiceImpl implements UserService&#123; private UserDao userDao ; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void doGetAllUser() &#123; userDao.selectAllUsers(); &#125;&#125; 在Spring的核心配置文件中完成组件装配 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 管理组件 --&gt; &lt;!-- bean: 对应一个被Spring管理的组件对象 id: bean的唯一标识 class: 组件对象对应的类的全类名 --&gt; &lt;bean id=\"userController\" class=\"com.ys.spring.controller.UserController\"&gt; &lt;!-- 给属性注入值 --&gt; &lt;property name=\"userService\" ref=\"userServiceImpl\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"userServiceImpl\" class=\"com.ys.spring.service.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"userDaoJdbcImpl\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"userDaoJdbcImpl\" class=\"com.ys.spring.dao.UserDaoJdbcImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 测试控制层 业务层 持久层的调用 java1234567891011121314151617181920212223242526272829package com.ys.spring.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.ys.spring.controller.UserController;import com.ys.spring.dao.UserDao;import com.ys.spring.service.UserService;public class TestSpring &#123; @Test public void testSpringXML() &#123; //1. 先创建Spring的容器对象 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2. 从Spring的容器中获取Bean对象 UserController uc = ctx.getBean(\"userController\", UserController.class); System.out.println(\"uc:\" + uc); UserService us = ctx.getBean(\"userServiceImpl\",UserService.class); System.out.println(\"us:\" + us ); UserDao ud = ctx.getBean(\"userDaoJdbcImpl\",UserDao.class); System.out.println(\"ud:\" + ud ); uc.listAllUsers(); &#125;&#125; 1.3 基于注解开发Spring应用1.3.1 常用注解标识组件1) 普通组件： @Component 标识一个受Spring IOC容器管理的组件 2) 持久化层组件： @Repository 标识一个受Spring IOC容器管理的持久化层组件 3) 业务逻辑层组件： @Service 标识一个受Spring IOC容器管理的业务逻辑层组件 4) 表述层控制器组件： @Controller 标识一个受Spring IOC容器管理的表述层控制器组件 1.3.2 组件命名规则1) 默认情况：使用组件的简单类名首字母小写后得到的字符串作为bean的id 2) 使用组件注解的value属性指定bean的id 3) 注意：事实上Spring并没有能力识别一个组件到底是不是它所标记的类型，即使将@Respository注解用在一个表述层控制器组件上面也不会产生任何错误，所以@Respository、@Service、@Controller这几个注解仅仅是为了让开发人员自己 明确当前的组件扮演的角色。 1.3.3 Spring HelloWorld 注解版1) 在控制层 业务层 持久层组件标注对应的注解 在控制层组件标注注解 java123@Controllerpublic class UserController &#123;&#125; 在业务层组件标注注解 java123@Servicepublic class UserServiceImpl implements UserService&#123;&#125; 在持久层组件标注注解 java123@Repositorypublic class UserDaoJdbcImpl implements UserDao &#123;&#125; 2) 在Spring的核心配置文件中开启组件扫描 首先在xml文件中的namespace视图下勾选context名称空间 在Spring的核心配置文件中开启组件扫描 xml12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 组件扫描 base-package: 基本包 Spring会扫描通过base-package指定的包下以及子包下的组件，将带有Spring相关 注解的类管理到IOC容器中。 --&gt; &lt;context:component-scan base-package=\"com.ys.spring\"&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 3) 编写测试类 java1234567891011121314151617181920212223242526package com.ys.spring.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.ys.spring.controller.UserController;import com.ys.spring.dao.UserDao;import com.ys.spring.service.UserService;public class TestSpring &#123; @Test public void testSpringXML() &#123; //1. 先创建Spring的容器对象 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2. 从Spring的容器中获取Bean对象 UserController uc = ctx.getBean(\"userController\", UserController.class); System.out.println(\"uc:\" + uc); UserService us = ctx.getBean(\"userServiceImpl\",UserService.class); System.out.println(\"us:\" + us ); UserDao ud = ctx.getBean(\"userDaoJdbcImpl\",UserDao.class); System.out.println(\"ud:\" + ud ); &#125;&#125; 1.3.4 @Autowired注解1) @Autowired的工作机制 首先会通过当前被装配的属性的类型到IOC容器中去匹配对应的Bean对象,如果能唯一确定一个bean对象，则装配成功 当通过当前被装配的属性的类型匹配在IOC容器中匹配到多个对应的Bean对象时，会再使用当前被装配的属性的名字与匹配到的Bean对象的id值再进行唯一确定，如果能确定唯一一个，则装配成功，否则，抛出异常 expected single matching bean but found 2:userDaoJdbcImpl,userDaoMyBatisImpl 如果被装配的属性在IOC容器中匹配不到任何一个Bean对象，也会抛出异常 expected at least 1 bean which qualifies as autowire candidate forthis dependency. Dependency annotations: @org.springframework.beans.factory.annotation.Autowired(required=true)} 如果匹配到多个Bean的情况，并且通过属性名也无法唯一确定一个Bean的时候，可以手动通过@Qualifier注解来具体指定装配哪个Bean对象. @Autowired 注解中required的属性默认是true，表示属性必须被装配，可以改为false，表示可选.也就是有就装配，没有就不装配. @Autowired 和 @Qualifier 注解可以加在属性上，也可以加在方法上。 1.3.5 基于注解装配1) 在 控制层 和 业务层分别定义需要被装配的组件类型的属性,并在属性上标注注解 在控制层中定义业务层类型的属性 和 相关方法 java123456789@Controllerpublic class UserController &#123; @Autowired private UserService userService ; public void listAllUsers() &#123; userService.doGetAllUser(); &#125;&#125; 在业务层中定义持久层类型的属性 和相关方法 java123456789101112131415161718package com.ys.spring.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import com.ys.spring.dao.UserDao;@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired private UserDao userDao ; @Override public void doGetAllUser() &#123; userDao.selectAllUsers(); &#125;&#125; 在持久层中定义相关方法 java12345678@Repositorypublic class UserDaoJdbcImpl implements UserDao &#123; @Override public void selectAllUsers() &#123; System.out.println(\"UserDaoJdbcImpl selectAllUsers Success .....\"); &#125;&#125; 2) 在测试方法中测试 控制层 业务层 持久层的调用 java12345678910111213141516171819202122232425262728package com.ys.spring.test;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.ys.spring.controller.UserController;import com.ys.spring.dao.UserDao;import com.ys.spring.service.UserService;public class TestSpring &#123; @Test public void testSpringXML() &#123; //1. 先创建Spring的容器对象 ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2. 从Spring的容器中获取Bean对象 UserController uc = ctx.getBean(\"userController\", UserController.class); System.out.println(\"uc:\" + uc); UserService us = ctx.getBean(\"userServiceImpl\",UserService.class); System.out.println(\"us:\" + us ); UserDao ud = ctx.getBean(\"userDaoJdbcImpl\",UserDao.class); System.out.println(\"ud:\" + ud ); uc.listAllUsers(); //【注意】id首字母要小写 &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://masteryang4.github.io/categories/JavaWeb/"},{"name":"spring","slug":"JavaWeb/spring","permalink":"https://masteryang4.github.io/categories/JavaWeb/spring/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://masteryang4.github.io/tags/JavaWeb/"},{"name":"spring","slug":"spring","permalink":"https://masteryang4.github.io/tags/spring/"}]},{"title":"解决Github连不上、ping不通的问题","slug":"解决Github连不上、ping不通的问题","date":"2020-06-07T15:59:15.000Z","updated":"2020-06-07T16:10:43.018Z","comments":true,"path":"2020/06/07/解决Github连不上、ping不通的问题/","link":"","permalink":"https://masteryang4.github.io/2020/06/07/%E8%A7%A3%E5%86%B3Github%E8%BF%9E%E4%B8%8D%E4%B8%8A%E3%80%81ping%E4%B8%8D%E9%80%9A%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"修改host即可Github连不上、ping不通、git clone特别慢等现象，通常是因为github.global.ssl.fastly.net域名被限制了。 因此，只要找到你当前线路最快的ip，修改一下host就能提速。 步骤一、在网站 https://www.ipaddress.com 分别找这两个域名所对应的最快的ip地址 Code12github.global.ssl.fastly.netgithub.com 二、在C:\\Windows\\System32\\drivers\\etc\\hosts里面做映射 注意要以自己查到的这两个域名所对应的最快IP地址为准。 在hosts文件最下方添加即可。 示例： Code12199.232.69.194 github.global.ssl.fastly.net140.82.114.4 github.com 保存修改后，再登陆一般就木有问题了。","categories":[{"name":"Git&Github","slug":"Git-Github","permalink":"https://masteryang4.github.io/categories/Git-Github/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Git&Github","slug":"Git-Github","permalink":"https://masteryang4.github.io/tags/Git-Github/"},{"name":"bug解决","slug":"bug解决","permalink":"https://masteryang4.github.io/tags/bug%E8%A7%A3%E5%86%B3/"}]},{"title":"Redis常见问题及扩展","slug":"Redis常见问题及扩展","date":"2020-06-07T15:04:34.000Z","updated":"2020-06-07T15:08:37.885Z","comments":true,"path":"2020/06/07/Redis常见问题及扩展/","link":"","permalink":"https://masteryang4.github.io/2020/06/07/Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E6%89%A9%E5%B1%95/","excerpt":"","text":"缓存穿透、缓存雪崩、缓存击穿1、缓存穿透是指查询一个一定不存在的数据。由于缓存命不中时会去查询数据库，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。 解决方案： 是将空对象也缓存起来，并给它设置一个很短的过期时间，最长不超过5分钟 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力 布隆过滤器(bloom filter)： https://zhuanlan.zhihu.com/p/72378274 2、如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就会造成缓存雪崩。 解决方案： 尽量让失效的时间点不分布在同一个时间点 3、缓存击穿，是指一个key非常热点，在不停的扛着大并发，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。 解决方案： 可以设置key永不过期 哨兵模式主从复制中反客为主的自动版，如果主机Down掉，哨兵会从从机中选择一台作为主机，并将它设置为其他从机的主机，而且如果原来的主机再次启动的话也会成为从机。 数据类型 类型 描述 string 字符串 list 可以重复的集合 set 不可以重复的集合 hash 类似于Map&lt;String,String&gt; zset(sorted set） 带分数的set 持久化1、RDB持久化： 在指定的时间间隔内持久化 服务shutdown会自动持久化 输入bgsave也会持久化 2、AOF : 以日志形式记录每个更新操作 Redis重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。 保存策略： 推荐（并且也是默认）的措施为每秒持久化一次，这种策略可以兼顾速度和安全性。 缺点： 比起RDB占用更多的磁盘空间 恢复备份速度要慢 每次读写都同步的话，有一定的性能压力 存在个别Bug，造成恢复不能 选择策略： 官方推荐： 如果对数据不敏感，可以选单独用RDB；不建议单独用AOF，因为可能出现Bug;如果只是做纯内存缓存，可以都不用。 悲观锁、乐观锁悲观锁： 执行操作前假设当前的操作肯定（或有很大几率）会被打断（悲观）。基于这个假设，我们在做操作前就会把相关资源锁定，不允许自己执行期间有其他操作干扰。 乐观锁： 执行操作前假设当前操作不会被打断（乐观）。基于这个假设，我们在做操作前不会锁定资源，万一发生了其他操作的干扰，那么本次操作将被放弃。 Redis使用的就是乐观锁。 推荐参考： https://zhuanlan.zhihu.com/p/89620471","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Redis","slug":"大数据/Redis","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Redis/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Redis","slug":"Redis","permalink":"https://masteryang4.github.io/tags/Redis/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"https://masteryang4.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"name":"缓存","slug":"缓存","permalink":"https://masteryang4.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"大数据常用框架源码编译","slug":"大数据常用框架源码编译","date":"2020-06-07T12:28:17.000Z","updated":"2020-06-07T12:33:39.199Z","comments":true,"path":"2020/06/07/大数据常用框架源码编译/","link":"","permalink":"https://masteryang4.github.io/2020/06/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/","excerpt":"","text":"源码编译通用步骤一、搭建编译环境一般编译环境为Linux + JDK + Maven，有些框架可能需要别的环境支持，一般都会注明，在后面细说。以下教程都是基于Linux + JDK8环境编译。 Linux和JDK环境这里不再赘述 MAVEN环境搭建 bash123456789101112#1. 从apache网站拉取tar包并解压MVNTAR=$(curl http://maven.apache.org/download.cgi | grep -E \"&gt;apache-maven-.*bin\\.tar\\.gz&lt;\" | sed 's/.*a href=\"\\(.*\\)\".*/\\1/g')curl $MVNTAR | tar zxC /opt/modulemv /opt/module/$(basename $MVNTAR | cut -d - -f 1,2,3) /opt/module/maven#2. 配置环境变量vim /etc/profile.d/my_env.sh#添加如下内容并保存退出export M2_HOME=/opt/module/mavenexport MAVEN_HOME=/opt/module/mavenexport PATH=$&#123;MAVEN_HOME&#125;/bin:$&#123;PATH&#125; 完成后重启Xshell会话 二、下载源码下载你想要编译的框架的源码。一般源码下载有两种方式： 想编译的版本已经发布release版，但是由于兼容性原因需要重新编译。这种情况直接从框架官网下载源码包并解压即可。 想测试框架还没发布的最新功能。此时从git托管服务器拉取最新源码，这时，我们需要git环境 Git环境搭建 bash12sudo yum install -y epel-releasesudo yum install -y git 到 https://git-wip-us.apache.org/repos/asf 查看想要编译的框架的git服务器，拉取源码(以Hive为例) bash123456#新建源码存储目录mkdir -p /opt/software/sourcecd /opt/software/source#拉取源码git clone https://git-wip-us.apache.org/repos/asf/hive.git 进入拉取的源码目录，切换到自己想要的分支 bash123456#查看所有本地和远程分支，这里也可以切换到之前版本的分支cd hivegit branch -a#新建本地分支同步远程分支git checkout -b 3.1 origin/branch-3.1 如果想切换到特定release的源码，使用git tag命令 bash12345#查看所有taggit tag#切换到想要的tag，这里以release-3.1.2为例git checkout rel/release-3.1.2 三、查看编译说明一般来说，源码根目录都会有building.txt之类的文件作为编译说明，如果没有找到，也可以去官网查看编译说明。说明里一般都会注明前置要求，例如一些额外的编译环境要求等。 Hive没有前置要求，我们直接进入第四步 四、对源码做必要修改一般我们只有在框架不兼容的情况下我们需要重新编译，不兼容一般是由于框架依赖版本不一致造成的，一般我们只需要编辑框架的pom.xml文件修改依赖版本即可。但是有些依赖新版本和旧版本不兼容，此时我们就需要对源码进行更多的修改。这些修改最好在IDE中进行。 Hive的guava版本和Hadoop 3.1.3的不兼容，我们修改其为27.0-jre xml1234将&lt;guava.version&gt;19.0&lt;/guava.version&gt;修改为&lt;guava.version&gt;27.0-jre&lt;/guava.version&gt; 这个依赖新老版本就不兼容，修改版本后我们需要对源码进行必要修改。详细修改步骤会在另外一篇教程中讲述 五、编译准备工作全部做完，最后我们开始编译。一般的编译命令为： bash1mvn clean package -Pdist -DskipTests -Dmaven.javadoc.skip=true 然后静待编译完成。这个过程会比较久，而且会从maven官网拉取大量jar包，所以要保证网络状况良好。 编译完成的Tar包的位置，各个框架都不一样，我们可以用下面的命令查找 bash1find ./ -name *.tar.gz Hive编译 拉取源码 bash12cd /opt/software/sourcegit clone https://git-wip-us.apache.org/repos/asf/hive.git 修改pom.xml，将guava的版本改为如下版本 Code1&lt;guava.version&gt;27.0-jre&lt;&#x2F;guava.version&gt; 修改以下文件中关于 com.google.common.util.concurrent.Futures#addCallback 的调用 src\\java\\org\\apache\\hadoop\\hive\\llap\\AsyncPbRpcProxy.java java123456789101112131415161718192021//173行Futures.addCallback( future, new ResponseCallback&lt;U&gt;( request.getCallback(), nodeId, this) ,executor);//278行Futures.addCallback(requestManagerFuture, new FutureCallback&lt;Void&gt;() &#123; @Override public void onSuccess(Void result) &#123; LOG.info(\"RequestManager shutdown\"); &#125; @Override public void onFailure(Throwable t) &#123; if (!(t instanceof CancellationException)) &#123; LOG.warn(\"RequestManager shutdown with error\", t); &#125; &#125;&#125;, requestManagerExecutor); src\\java\\org\\apache\\hadoop\\hive\\llap\\daemon\\impl\\AMReporter.java java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//162行Futures.addCallback(queueLookupFuture, new FutureCallback&lt;Void&gt;() &#123; @Override public void onSuccess(Void result) &#123; LOG.info(\"AMReporter QueueDrainer exited\"); &#125; @Override public void onFailure(Throwable t) &#123; if (t instanceof CancellationException &amp;&amp; isShutdown.get()) &#123; LOG.info(\"AMReporter QueueDrainer exited as a result of a cancellation after shutdown\"); &#125; else &#123; LOG.error(\"AMReporter QueueDrainer exited with error\", t); Thread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), t); &#125; &#125;&#125;, queueLookupExecutor);//266行Futures.addCallback(future, new FutureCallback&lt;Void&gt;() &#123; @Override public void onSuccess(Void result) &#123; LOG.info(\"Sent taskKilled for &#123;&#125;\", taskAttemptId); &#125; @Override public void onFailure(Throwable t) &#123; LOG.warn(\"Failed to send taskKilled for &#123;&#125;. The attempt will likely time out.\", taskAttemptId); &#125;&#125;, executor);//331行Futures.addCallback(future, new FutureCallback&lt;Void&gt;() &#123; @Override public void onSuccess(Void result) &#123; // Nothing to do. &#125; @Override public void onFailure(Throwable t) &#123; QueryIdentifier currentQueryIdentifier = amNodeInfo.getQueryIdentifier(); amNodeInfo.setAmFailed(true); LOG.warn(\"Heartbeat failed to AM &#123;&#125;. Marking query as failed. query=&#123;&#125;\", amNodeInfo.amNodeId, currentQueryIdentifier, t); queryFailedHandler.queryFailed(currentQueryIdentifier); &#125;&#125;, executor); src\\java\\org\\apache\\hadoop\\hive\\llap\\daemon\\impl\\LlapTaskReporter.java java12//131行Futures.addCallback(future, new HeartbeatCallback(errorReporter), heartbeatExecutor); src\\java\\org\\apache\\hadoop\\hive\\llap\\daemon\\impl\\TaskExecutorService.java java12345//178行Futures.addCallback(future, new WaitQueueWorkerCallback(), executionCompletionExecutorServiceRaw);//692行Futures.addCallback(future, wrappedCallback, executionCompletionExecutorService); src\\java\\org\\apache\\hadoop\\hive\\llap\\tezplugins\\LlapTaskSchedulerService.java java123456789//747行Futures.addCallback(nodeEnablerFuture, new LoggingFutureCallback(\"NodeEnablerThread\", LOG),nodeEnabledExecutor);//751行Futures.addCallback(delayedTaskSchedulerFuture, new LoggingFutureCallback(\"DelayedTaskSchedulerThread\", LOG),delayedTaskSchedulerExecutor);//755行Futures.addCallback(schedulerFuture, new LoggingFutureCallback(\"SchedulerThread\", LOG),schedulerExecutor); src\\java\\org\\apache\\hadoop\\hive\\ql\\exec\\tez\\WorkloadManager.java java12345678//1089行Futures.addCallback(future, FATAL_ERROR_CALLBACK, timeoutPool);//1923行Futures.addCallback(getFuture, this,timeoutPool);//1977行Futures.addCallback(waitFuture, this, timeoutPool); src\\test\\org\\apache\\hadoop\\hive\\ql\\exec\\tez\\SampleTezSessionState.java java123456789101112//121行Futures.addCallback(waitForAmRegFuture, new FutureCallback&lt;Boolean&gt;() &#123; @Override public void onSuccess(Boolean result) &#123; future.set(session); &#125; @Override public void onFailure(Throwable t) &#123; future.setException(t); &#125;&#125;,timeoutPool); 编译 bash1mvn clean package -Pdist -DskipTests -Dmaven.javadoc.skip=true Tez编译 拉取源码 bash12cd /opt/software/sourcegit clone https://git-wip-us.apache.org/repos/asf/tez.git 安装Tez必要环境 bash1sudo yum install -y protobuf protobuf-static protobuf-devel 编译 查看编译说明，按照编译说明用下列命令编译 bash12cd tezmvn clean package -Dhadoop.version=3.1.3 -Phadoop28 -P\\!hadoop27 -DskipTests -Dmaven.javadoc.skip=true Phoenix编译 拉取源码 bash12cd /opt/software/sourcegit clone https://git-wip-us.apache.org/repos/asf/phoenix.git 编译 bash12cd phoenixmvn clean package -DskipTests -Dhbase.profile=2.2 -Dhbase.version=2.2.4 Spark编译 去spark官网下载源码，解压到/opt/software/source 进入该目录，编译 bash1./dev/make-distribution.sh --name without-hive --tgz -Pyarn -Phadoop-3.1 -Dhadoop.version=3.1.3 -Pparquet-provided -Porc-provided -Phadoop-provided","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"源码编译","slug":"大数据/源码编译","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hive","slug":"hive","permalink":"https://masteryang4.github.io/tags/hive/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"},{"name":"源码编译","slug":"源码编译","permalink":"https://masteryang4.github.io/tags/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"},{"name":"phoenix","slug":"phoenix","permalink":"https://masteryang4.github.io/tags/phoenix/"},{"name":"tez","slug":"tez","permalink":"https://masteryang4.github.io/tags/tez/"}]},{"title":"HiveSQL之常用查询函数case","slug":"HiveSQL之常用查询函数case","date":"2020-05-26T15:53:58.000Z","updated":"2020-05-26T16:18:08.383Z","comments":true,"path":"2020/05/26/HiveSQL之常用查询函数case/","link":"","permalink":"https://masteryang4.github.io/2020/05/26/HiveSQL%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0case/","excerpt":"","text":"关键词：CASE WHEN THEN ELSE END数据准备 name dept_id sex 悟空 A 男 大海 A 男 宋宋 B 男 凤姐 A 女 婷姐 B 女 婷婷 B 女 需求求出不同部门男女各多少人。结果如下： Code12A 2 1B 1 2 创建本地emp_sex.txt，导入数据Code1234567[ys@hadoop102 datas]$ vim emp_sex.txt悟空 A 男大海 A 男宋宋 B 男凤姐 A 女婷姐 B 女婷婷 B 女 创建hive表并导入数据sql123456create table emp_sex(name string, dept_id string, sex string) row format delimited fields terminated by \"\\t\";load data local inpath '/opt/module/datas/emp_sex.txt' into table emp_sex; 查询数据sql12345678select dept_id, sum(case sex when '男' then 1 else 0 end) male_count, sum(case sex when '女' then 1 else 0 end) female_countfrom emp_sexgroup by dept_id; 首先注意CASE WHEN THEN ELSE END的缺一不可 也要注意sum函数的用法，sum(条件)是经常会用到的方法！！！ 比如sum(if XXX)就常在HiveSQL里面使用。 例如：sum(if(dt=&#39;2020-05-27&#39;, order_count,0 )) order_count，本质其实是一样的。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hive","slug":"大数据/hive","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/hive/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"hive","slug":"hive","permalink":"https://masteryang4.github.io/tags/hive/"},{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/tags/SQL/"},{"name":"hivesql","slug":"hivesql","permalink":"https://masteryang4.github.io/tags/hivesql/"}]},{"title":"一段有趣的spark_aggregate代码","slug":"一段有趣的spark-aggregate代码","date":"2020-05-26T14:18:30.000Z","updated":"2020-05-29T14:14:17.186Z","comments":true,"path":"2020/05/26/一段有趣的spark-aggregate代码/","link":"","permalink":"https://masteryang4.github.io/2020/05/26/%E4%B8%80%E6%AE%B5%E6%9C%89%E8%B6%A3%E7%9A%84spark-aggregate%E4%BB%A3%E7%A0%81/","excerpt":"","text":"看到了一段非常有趣的关于spark中aggregate算子的代码，需要很细心才能给出正确答案。 在这里和大家分享。 代码示例scala12345678910111213141516import org.apache.spark.&#123;SparkConf, SparkContext&#125;object TrySpark &#123; def main(args: Array[String]): Unit = &#123; val conf: SparkConf = new SparkConf().setAppName(\"aggTest\").setMaster(\"local[*]\") val sc = new SparkContext(conf) val rdd = sc.makeRDD(Array(\"12\", \"234\", \"345\", \"4567\"), 2) val str: String = rdd.aggregate(\"0\")((a, b) =&gt; Math.max(a.length, b.length).toString, (x, y) =&gt; x + y) println(str) val str1: String = rdd.aggregate(\"\")((a, b) =&gt; Math.min(a.length, b.length).toString, (x, y) =&gt; x + y) println(str1) &#125;&#125; 前方高能输出结果1 Code1204311 输出结果2 Code1203411 惊不惊喜，刺不刺激（手动狗头）。 解析aggregate：行动算子，意为【聚合】 函数签名 def aggregate[U: ClassTag](zeroValue: U)(seqOp: (U, T) =&gt; U, combOp: (U, U) =&gt; U): U 函数说明 分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合 第一个括号内的参数为初始值 第二个括号中 第一个参数为分区内要执行的函数，初始值和分区内元素依次聚合 第二个参数为分区间要执行的函数，初始值和分区间元素依次聚合 代码详解： scala1val rdd = sc.makeRDD(Array(\"12\", \"234\", \"345\", \"4567\"), 2) scala1rdd.aggregate(\"0\")((a, b) =&gt; Math.max(a.length, b.length).toString, (x, y) =&gt; x + y) 首先注意rdd是两个分区，”12”, “234”一个分区，”345”, “4567”一个分区 执行分区内函数Math.max(a.length, b.length).toString 分区一 “0”，“12”执行函数，输出“2”，【注意：函数后面有个toString】【聚合：上一步输出作为下一步输入】 “2”，”234”执行函数，最终输出“3” 分区二 “0”，“345” =&gt; “3” “3”，”4567” =&gt; 最终 “4” 执行分区间函数(x, y) =&gt; x + y，其实就是一个字符串拼接，但是因为分区的原因 不一定哪个分区先执行完，所以会出现两种情况的字符串拼接：“034” or “043” scala1rdd.aggregate(\"\")((a, b) =&gt; Math.min(a.length, b.length).toString, (x, y) =&gt; x + y) rdd是两个分区，”12”, “234”一个分区，”345”, “4567”一个分区 执行分区内函数Math.min(a.length, b.length).toString 分区一 “”，“12”执行函数，输出“0”，【注意：函数后面有个toString】【聚合：上一步输出作为下一步输入】 “0”，”234”执行函数，最终输出“1”，【注意：“0”的长度是1】 分区二 “”，“345” =&gt; “0” “0”，”4567” =&gt; 最终 “1” 执行分区间函数(x, y) =&gt; x + y，字符串拼接，“”+“1”+“1” =&gt; “11”","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"}]},{"title":"spark常用算子join","slug":"spark常用算子join","date":"2020-05-25T11:52:38.000Z","updated":"2020-05-25T12:12:02.270Z","comments":true,"path":"2020/05/25/spark常用算子join/","link":"","permalink":"https://masteryang4.github.io/2020/05/25/spark%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90join/","excerpt":"","text":"简述JOIN函数签名 def join[W](other: RDD[(K, W)]): RDD[(K, (V, W))] 函数说明 spark RDD 转换算子 (对照函数签名)在类型为(K,V)和(K,W)的RDD上调用，返回一个相同key对应的所有元素连接在一起的(K,(V,W))的RDD 重点示例 join leftOuterJoin rightOuterJoin fullOuterJoin scala1234567891011121314151617181920212223242526272829303132333435363738import org.apache.spark.rdd.RDDimport org.apache.spark.&#123;SparkConf, SparkContext&#125;object JoinTest &#123; def main(args: Array[String]): Unit = &#123; //1.创建SparkConf val sparkConf: SparkConf = new SparkConf().setAppName(\"JoinTest\").setMaster(\"local[*]\") //2.创建SparkContext val sc = new SparkContext(sparkConf) //3.创建两个RDD val rdd1: RDD[(String, Int)] = sc.makeRDD(Array((\"a\", 1), (\"a\", 2), (\"b\", 1), (\"c\", 1))) val rdd2: RDD[(String, Int)] = sc.makeRDD(Array((\"a\", 1), (\"b\", 1), (\"b\", 2), (\"d\", 1))) //4.测试各种JOIN【 注意返回值 】 val result1: RDD[(String, (Int, Int))] = rdd1.join(rdd2) val result2: RDD[(String, (Int, Option[Int]))] = rdd1.leftOuterJoin(rdd2) val result3: RDD[(String, (Option[Int], Int))] = rdd1.rightOuterJoin(rdd2) val result4: RDD[(String, (Option[Int], Option[Int]))] = rdd1.fullOuterJoin(rdd2) //5.打印 result1.foreach(println) println(\"======================&gt;&gt;&gt;\") result2.foreach(println) println(\"======================&gt;&gt;&gt;\") result3.foreach(println) println(\"======================&gt;&gt;&gt;\") result4.foreach(println) //6.关闭连接 sc.stop() &#125;&#125; 输出结果： Code1234567891011121314151617181920212223(b,(1,1))(a,(1,1))(a,(2,1))(b,(1,2))&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;(c,(1,None))(a,(1,Some(1)))(a,(2,Some(1)))(b,(1,Some(1)))(b,(1,Some(2)))&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;(d,(None,1))(a,(Some(1),1))(a,(Some(2),1))(b,(Some(1),1))(b,(Some(1),2))&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;(d,(None,Some(1)))(c,(Some(1),None))(a,(Some(1),Some(1)))(a,(Some(2),Some(1)))(b,(Some(1),Some(1)))(b,(Some(1),Some(2)))","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"}]},{"title":"scala样例类转换成为JSON字符串","slug":"scala样例类转换成为JSON字符串","date":"2020-05-25T11:08:21.000Z","updated":"2020-05-26T01:01:19.891Z","comments":true,"path":"2020/05/25/scala样例类转换成为JSON字符串/","link":"","permalink":"https://masteryang4.github.io/2020/05/25/scala%E6%A0%B7%E4%BE%8B%E7%B1%BB%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BAJSON%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"JSON常用方法Java中并没有内置JSON的解析，因此使用JSON需要借助第三方类库。 几个常用的 JSON 解析类库： Gson: 谷歌开发的 JSON 库，功能十分全面。 FastJson: 阿里巴巴开发的 JSON 库，性能十分优秀。 Jackson: 社区十分活跃且更新速度很快。 maven依赖： xml12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt; JSON 对象与字符串的相互转化 方法 作用 JSON.parseObject() 从字符串解析 JSON 对象 JSON.parseArray() 从字符串解析 JSON 数组 JSON.toJSONString(obj/array) 将 JSON 对象或 JSON 数组转化为字符串 示例： java1234567891011121314import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;public class JSONTest &#123; public static void main(String[] args) &#123; //从字符串解析JSON对象 JSONObject obj = JSON.parseObject(\"&#123;\\\"name\\\":\\\"ys\\\"&#125;\"); System.out.println(obj); //&#123;\"name\":\"ys\"&#125; //将JSON对象转化为字符串 String objStr = JSON.toJSONString(obj); System.out.println(objStr); //&#123;\"name\":\"ys\"&#125; &#125;&#125; Scala样例类转换成JSON字符串将Scala样例类转换成为JSON字符串，JSON.toJSONString(obj)会失效，所以使用如下方法： maven依赖（json4s —&gt; json for scala）： xml12345&lt;dependency&gt; &lt;groupId&gt;org.json4s&lt;/groupId&gt; &lt;artifactId&gt;json4s-native_2.11&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt;&lt;/dependency&gt; scala1234import org.json4s.native.Serializationimplicit val formats=org.json4s.DefaultFormats //隐式转换val orderInfoJson: String = Serialization.write(orderInfo) 示例 scala123456789101112131415161718192021222324import com.alibaba.fastjson.&#123;JSON, JSONObject&#125;import com.atguigu.bean.UserInfoimport org.json4s.native.Serializationobject JsonStrTest &#123; def main(args: Array[String]): Unit = &#123; val userInfo = UserInfo(\"1001\",\"name1\",\"5\",\"2020-05-25\",\"male\") implicit val formats = org.json4s.DefaultFormats //println(JSON.toJSONString(userInfo)) //报错 val str = Serialization.write(userInfo) println(str) // &#123;\"id\":\"1001\",\"login_name\":\"name1\",\"user_level\":\"5\",\"birthday\":\"2020-05-25\",\"gender\":\"male\"&#125; val nObject: JSONObject = JSON.parseObject(str) //正常解析 println(nObject) // &#123;\"birthday\":\"2020-05-25\",\"login_name\":\"name1\",\"gender\":\"male\",\"user_level\":\"5\",\"id\":\"1001\"&#125; &#125;&#125; UserInfo.scala scala12345case class UserInfo(id:String, login_name:String, user_level:String, birthday:String, gender:String)","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"scala","slug":"大数据/scala","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"scala","slug":"scala","permalink":"https://masteryang4.github.io/tags/scala/"}]},{"title":"[精]ElasticSearch总结与思考","slug":"ElasticSearch总结与思考","date":"2020-05-18T14:05:34.000Z","updated":"2020-06-09T15:22:04.442Z","comments":true,"path":"2020/05/18/ElasticSearch总结与思考/","link":"","permalink":"https://masteryang4.github.io/2020/05/18/ElasticSearch%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"简介概述 Elasticsearch，基于Lucene，隐藏复杂性，提供简单易用的RestfulAPI接口、JavaAPI接口（还有其他语言的API接口）。 Elasticsearch是一个实时分布式搜索和分析引擎。它用于全文搜索、结构化搜索、分析。 全文检索：将非结构化数据中的一部分信息提取出来,重新组织,使其变得有一定结构,然后对此有一定结构的数据进行搜索,从而达到搜索相对较快的目的。 倒排索引：简单举例：根据关键词找包含其的文章（正常思维：在文章中找关键词）。 结构化检索：我想搜索商品分类为日化用品的商品都有哪些，select * from products where category_id=’日化用品’。 数据分析：电商网站，最近7天牙膏这种商品销量排名前10的商家有哪些；新闻网站，最近1个月访问量排名前3的新闻版块是哪些。 可以作为一个大型分布式集群（数百台服务器）技术，处理PB级数据，服务大公司；也可以运行在单机上，服务小公司. 使用场景 维基百科，类似百度百科，牙膏，牙膏的维基百科，全文检索，高亮，搜索推荐。 The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+ 社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）。 Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案。 GitHub（开源代码管理），搜索上千亿行代码。 国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景）。 核心概念ElasticSearch与数据库类比 关系型数据库（如Mysql） 非关系型数据库（Elasticsearch） 数据库Database 索引Index 表Table 类型Type(6.0版本之后在一个索引下面只能有一个，7.0版本之后取消了Type) 数据行Row 文档Document(JSON格式) 数据列Column 字段Field 约束 Schema 映射Mapping 安装1）解压elasticsearch-6.6.0.tar.gz到/opt/module目录下 Code1[ys@hadoop102 software]$ tar -zxvf elasticsearch-6.6.0.tar.gz -C &#x2F;opt&#x2F;module&#x2F; 2）在/opt/module/elasticsearch-6.6.0路径下创建data文件夹 Code1[ys@hadoop102 elasticsearch-6.6.0]$ mkdir data 3）修改配置文件/opt/module/elasticsearch-6.6.0/config/elasticsearch.yml Code123[ys@hadoop102 config]$ pwd&#x2F;opt&#x2F;module&#x2F;elasticsearch-6.6.0&#x2F;config[ys@hadoop102 config]$ vim elasticsearch.yml yml1234567891011121314#-----------------------Cluster-----------------------cluster.name: my-application#-----------------------Node-----------------------node.name: node-102#-----------------------Paths-----------------------path.data: /opt/module/elasticsearch-6.6.0/datapath.logs: /opt/module/elasticsearch-6.6.0/logs#-----------------------Memory-----------------------bootstrap.memory_lock: falsebootstrap.system_call_filter: false#-----------------------Network-----------------------network.host: 192.168.9.102 #-----------------------Discovery-----------------------discovery.zen.ping.unicast.hosts: [\"192.168.9.102\"] （1）cluster.name 如果要配置集群需要两个节点上的elasticsearch配置的cluster.name相同，都启动可以自动组成集群，这里如果不改cluster.name则默认是cluster.name=my-application， （2）nodename随意取但是集群内的各节点不能相同 （3）修改后的每行前面不能有空格，修改后的“：”后面必须有一个空格 4）分发至hadoop103以及hadoop104，分发之后修改： Code1234567[ys@hadoop102 module]$ xsync elasticsearch-6.6.0&#x2F;node.name: node-103network.host: 192.168.9.103node.name: node-104network.host: 192.168.9.104 5）此时启动会报错，要配置linux系统环境（参考：http://blog.csdn.net/satiling/article/details/59697916） 6）启动Elasticsearch Code1[ys@hadoop102 elasticsearch-6.6.0]$ bin&#x2F;elasticsearch 7）测试elasticsearch Code12345678910111213141516171819[ys@hadoop102 elasticsearch-6.6.0]$ curl http:&#x2F;&#x2F;hadoop102:9200&#123; &quot;name&quot; : &quot;node-102&quot;, &quot;cluster_name&quot; : &quot;my-application&quot;, &quot;cluster_uuid&quot; : &quot;KOpuhMgVRzW_9OTjMsHf2Q&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;6.6.0&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;eb782d0&quot;, &quot;build_date&quot; : &quot;2018-06-29T21:59:26.107521Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;7.3.1&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 8）停止集群 Code1kill -9 进程号 9）群起脚本 Code1[ys@hadoop102 bin]$ vi es.sh shell123456789101112131415161718#!/bin/bashes_home=/opt/module/elasticsearchcase $1 in \"start\") &#123; for i in hadoop102 hadoop103 hadoop104 do echo \"==============$i==============\" ssh $i \"source /etc/profile;$&#123;es_home&#125;/bin/elasticsearch &gt;/dev/null 2&gt;&amp;1 &amp;\" done&#125;;;\"stop\") &#123; for i in hadoop102 hadoop103 hadoop104 do echo \"==============$i==============\" ssh $i \"ps -ef|grep $es_home |grep -v grep|awk '&#123;print \\$2&#125;'|xargs kill\" &gt;/dev/null 2&gt;&amp;1 done&#125;;;esac 可视化工具KibanaKibana的安装 1、将kibana压缩包上传到虚拟机指定目录 Code1[ys@hadoop102 software]$ tar -zxvf kibana-6.6.0-linux-x86_64.tar.gz -C &#x2F;opt&#x2F;module&#x2F; 2、修改相关配置，连接Elasticsearch Code1[ys@hadoop102 kibana]$ vim config&#x2F;kibana.yml yml12345678910# Kibana is served by a back end server. This setting specifies the port to use.server.port: 5601# Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.# The default is 'localhost', which usually means remote machines will not be able to connect.# To allow connections from remote users, set this parameter to a non-loopback address.server.host: \"192.168.9.102\"... ...... ...# The URL of the Elasticsearch instance to use for all your queries.elasticsearch.url: \"http://192.168.9.102:9200\" 3、启动Kibana Code1[ys@hadoop102 kibana]$ bin&#x2F;kibana 4、浏览器访问：hadoop102:5601 即可操作 操作命令行操作核心数据类型 字符串型：text(分词)、keyword(不分词) 数值型：long、integer、short、byte、double、float、half_float、scaled_float 日期类型：date Mapping1、手动创建 创建mapping Code1234567891011121314151617PUT my_index1&#123; &quot;mappings&quot;: &#123; &quot;_doc&quot;:&#123; &quot;properties&quot;:&#123; &quot;username&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;pinyin&quot;:&#123; &quot;type&quot;: &quot;text&quot; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 创建文档 Code1234PUT my_index1&#x2F;_doc&#x2F;1&#123; &quot;username&quot;:&quot;haha heihei&quot;&#125; 查询 Code12345678GET my_index1&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;username.pinyin&quot;: &quot;haha&quot; &#125; &#125;&#125; 2、自动创建 直接插入文档 Code123456PUT &#x2F;test_index&#x2F;_doc&#x2F;1&#123; &quot;username&quot;:&quot;alfred&quot;, &quot;age&quot;:1, &quot;birth&quot;:&quot;1991-12-15&quot;&#125; 查看mapping Code123456789101112131415161718192021222324252627GET &#x2F;test_index&#x2F;doc&#x2F;_mapping&#123; &quot;test_index&quot;: &#123; &quot;mappings&quot;: &#123; &quot;doc&quot;: &#123; &quot;properties&quot;: &#123; &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;birth&quot;: &#123; &quot;type&quot;: &quot;date&quot; &#125;, &quot;username&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; IK分词器分词器主要应用在中文上，在ES中字符串类型有keyword和text两种。keyword默认不进行分词，而text是将每一个汉字拆开称为独立的词，这两种都是不适用于生产环境。 keyword分词 Code1234GET _analyze&#123; &quot;keyword&quot;:&quot;我是程序员&quot;&#125; 结果展示（会报错error） text类型的分词 Code1234GET _analyze&#123; &quot;text&quot;:&quot;我是程序员&quot;&#125; 结果展示： Code123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;我&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;是&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;程&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 3, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;序&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;员&quot;, &quot;start_offset&quot;: 4, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;, &quot;position&quot;: 4 &#125; ]&#125; IK分词器安装1）下载与安装的ES相对应的版本 2）解压elasticsearch-analysis-ik-6.6.0.zip，将解压后的IK文件夹拷贝到ES安装目录下的plugins目录下，并重命名文件夹为ik（什么名称都OK） Code1[ys@hadoop102 plugins]$ mkdir ik Code1[ys@hadoop102 software]$ unzip elasticsearch-analysis-ik-6.6.0.zip -d &#x2F;opt&#x2F;module&#x2F;elasticsearch-6.6.0&#x2F;plugins&#x2F;ik&#x2F; 3）分发分词器目录 Code1[ys@hadoop102 elasticsearch-6.6.0]$ xsync plugins&#x2F; 4）重新启动Elasticsearch，即可加载IK分词器 5）IK测试 ik_smart ：最少切分 ik_max_word：最细粒度划分 Code12345get _analyze&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;:&quot;我是程序员&quot;&#125; Code12345678910111213141516171819202122232425&#123; &quot;tokens&quot; : [ &#123; &quot;token&quot; : &quot;我&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 1, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 0 &#125;, &#123; &quot;token&quot; : &quot;是&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_CHAR&quot;, &quot;position&quot; : 1 &#125;, &#123; &quot;token&quot; : &quot;程序员&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 5, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 &#125; ]&#125; ik_max_word Code1&quot;我&quot;,&quot;是&quot;,&quot;程序员&quot;,&quot;程序&quot;,&quot;员&quot; 检索文档【重点】向Elasticsearch增加数据 Code12345678PUT &#x2F;atguigu&#x2F;doc&#x2F;1&#123; &quot;first_name&quot; : &quot;John&quot;, &quot;last_name&quot; : &quot;Smith&quot;, &quot;age&quot; : 25, &quot;about&quot; : &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [&quot;sports&quot;, &quot;music&quot;]&#125; 查询数据 Code12# 协议方法 索引&#x2F;类型&#x2F;文档编号GET &#x2F;atguigu&#x2F;doc&#x2F;1 响应 Code1234567891011121314151617&#123; &quot;_index&quot;: &quot;atguigu&quot;, &quot;_type&quot;: &quot;doc&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &#x2F;&#x2F; 文档的原始数据JSON数据 &quot;first_name&quot;: &quot;John&quot;, &quot;last_name&quot;: &quot;Smith&quot;, &quot;age&quot;: 25, &quot;about&quot;: &quot;I love to go rock climbing&quot;, &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ] &#125;&#125; 元数据查询Code1GET _cat&#x2F;indices 全文档检索Code12# 协议方法 索引&#x2F;类型&#x2F;_searchGET &#x2F;atguigu&#x2F;_doc&#x2F;_search 字段全值匹配检索[filter]Code123456789101112GET atguigu&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;about&quot;: &quot;I love to go rock climbing&quot; &#125; &#125; &#125; &#125;&#125; 字段分词匹配检索[match]Code12345678GET atguigu&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;about&quot;: &quot;I&quot; &#125; &#125;&#125; 字段模糊匹配检索[fuzzy]Code12345678910GET test&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;fuzzy&quot;: &#123; &quot;aa&quot;: &#123; &quot;value&quot;: &quot;我是程序&quot; &#125; &#125; &#125;&#125; 聚合检索Code1234567891011GET test&#x2F;_search&#123; &quot;aggs&quot;: &#123; &quot;groupby_aa&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;aa&quot;, &quot;size&quot;: 10 &#125; &#125; &#125;&#125; 分页检索Code123456GET movie_index&#x2F;movie&#x2F;_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 1, &quot;size&quot;: 1&#125; 索引别名 _aliases索引别名就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何一个需要索引名的API来使用。别名带给我们极大的灵活性，允许我们做下面这些： 1）给多个索引分组 (例如， last_three_months) 2）给索引的一个子集创建视图 3）在运行的集群中可以无缝的从一个索引切换到另一个索引 说白了就是功能更强大的视图 创建索引别名 建表时直接声明 Code12345678910111213141516171819202122232425262728293031PUT movie_chn_2020&#123; &quot;aliases&quot;: &#123; &quot;movie_chn_2020-query&quot;: &#123;&#125; &#125;, &quot;mappings&quot;: &#123; &quot;movie&quot;:&#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;: &quot;text&quot; , &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;doubanScore&quot;:&#123; &quot;type&quot;: &quot;double&quot; &#125;, &quot;actorList&quot;:&#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;:&quot;long&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 为已存在的索引增加别名 Code123456POST _aliases&#123; &quot;actions&quot;: [ &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;movie_chn_xxxx&quot;, &quot;alias&quot;: &quot;movie_chn_2020-query&quot; &#125;&#125; ]&#125; 也可以通过加过滤条件缩小查询范围，建立一个子集视图 Code1234567891011121314POST _aliases&#123; &quot;actions&quot;: [ &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;movie_chn_xxxx&quot;, &quot;alias&quot;: &quot;movie_chn0919-query-zhhy&quot;, &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;actorList.id&quot;: &quot;3&quot; &#125; &#125; &#125; &#125; ]&#125; 查询别名：与使用普通索引没有区别 Code1GET movie_chn_2020-query&#x2F;_search 删除某个索引的别名 Code123456POST _aliases&#123; &quot;actions&quot;: [ &#123; &quot;remove&quot;: &#123; &quot;index&quot;: &quot;movie_chn_xxxx&quot;, &quot;alias&quot;: &quot;movie_chn_2020-query&quot; &#125;&#125; ]&#125; 为某个别名进行无缝切换 Code1234567POST &#x2F;_aliases&#123; &quot;actions&quot;: [ &#123; &quot;remove&quot;: &#123; &quot;index&quot;: &quot;movie_chn_xxxx&quot;, &quot;alias&quot;: &quot;movie_chn_2020-query&quot; &#125;&#125;, &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;movie_chn_yyyy&quot;, &quot;alias&quot;: &quot;movie_chn_2020-query&quot; &#125;&#125; ]&#125; 查询别名列表 Code1GET _cat&#x2F;aliases?v 索引模板Index Template 索引模板，顾名思义，就是创建索引的模具，其中可以定义一系列规则来帮助我们构建符合特定业务需求的索引的mappings和 settings，通过使用 Index Template 可以让我们的索引具备可预知的一致性。 常见的场景: 分割索引 分割索引就是根据时间间隔把一个业务索引切分成多个索引。比如把order_info 变成 order_info_20200101,order_info_20200102 ….. 这样做的好处有两个： 1、结构变化的灵活性：因为elasticsearch不允许对数据结构进行修改。但是实际使用中索引的结构和配置难免变化，那么只要对下一个间隔的索引进行修改，原来的索引位置原状。这样就有了一定的灵活性。 2、查询范围优化：因为一般情况并不会查询全部时间周期的数据，那么通过切分索引，物理上减少了扫描数据的范围，也是对性能的优化。 创建模板 Code123456789101112131415161718192021222324PUT _template&#x2F;template_movie2020&#123; &quot;index_patterns&quot;: [&quot;movie_test*&quot;], &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1 &#125;, &quot;aliases&quot; : &#123; &quot;&#123;index&#125;-query&quot;: &#123;&#125;, &quot;movie_test-query&quot;:&#123;&#125; &#125;, &quot;mappings&quot;: &#123; &quot;_doc&quot;: &#123; &quot;properties&quot;: &#123; &quot;id&quot;: &#123; &quot;type&quot;: &quot;keyword&quot; &#125;, &quot;movie_name&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot; &#125; &#125; &#125; &#125;&#125; 其中 “index_patterns”: [“movie_test*”], 的含义就是凡是往movie_test开头的索引写入数据时，如果索引不存在，那么es会根据此模板自动建立索引。 在 “aliases” 中用{index}表示，获得真正的创建的索引名。 测试： Code12345POST movie_test_2020xxxx&#x2F;_doc&#123; &quot;id&quot;:&quot;333&quot;, &quot;name&quot;:&quot;zhang3&quot;&#125; 查看系统中已有的模板清单 Code1GET _cat&#x2F;templates 查看某个模板详情 Code123GET _template&#x2F;template_movie2020或者GET _template&#x2F;template_movie* JavaAPI操作maven依赖: xml1234567891011121314151617181920212223242526272829303132333435&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt; &lt;version&gt;4.3.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.janino&lt;/groupId&gt; &lt;artifactId&gt;commons-compiler&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;versison&gt;6.6.0&lt;/version&gt;&lt;/dependency&gt; 单条写入数据 java1234567891011121314151617181920212223242526272829303132333435363738394041import com.ys.bean.Stu;import io.searchbox.client.JestClient;import io.searchbox.client.JestClientFactory;import io.searchbox.client.config.HttpClientConfig;import io.searchbox.core.Index;import java.io.IOException;public class ESWriter &#123; public static void main(String[] args) throws IOException &#123; //一、创建ES客户端对象 //1.1 创建ES客户端的工厂对象 JestClientFactory jestClientFactory = new JestClientFactory(); //1.2 创建配置信息 HttpClientConfig config = new HttpClientConfig.Builder(\"http://hadoop102:9200\").build(); jestClientFactory.setHttpClientConfig(config); //1.3 获取客户端对象 JestClient jestClient = jestClientFactory.getObject(); //二、写入数据 //2.1 创建Action对象 --&gt; Index Stu stu = new Stu(\"004\", \"少爷\"); Index index = new Index.Builder(stu) .index(\"stu_temp_01\") .type(\"_doc\") .id(\"1004\") .build(); //2.2 执行写入数据操作 jestClient.execute(index); //三、关闭资源 jestClient.shutdownClient(); &#125;&#125; 批量写入数据 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.ys.bean.Stu;import io.searchbox.client.JestClient;import io.searchbox.client.JestClientFactory;import io.searchbox.client.config.HttpClientConfig;import io.searchbox.core.Bulk;import io.searchbox.core.Index;import java.io.IOException;public class ESWriterByBulk &#123; public static void main(String[] args) throws IOException &#123; //一、创建ES客户端对象 //1.1 创建ES客户端的工厂对象 JestClientFactory jestClientFactory = new JestClientFactory(); //1.2 创建配置信息 HttpClientConfig config = new HttpClientConfig.Builder(\"http://hadoop102:9200\").build(); jestClientFactory.setHttpClientConfig(config); //1.3 获取客户端对象 JestClient jestClient = jestClientFactory.getObject(); //二、批量写入 //2.1 准备数据 Stu stu1 = new Stu(\"008\", \"麻瓜\"); Stu stu2 = new Stu(\"009\", \"海格\"); //2.2 创建Bulk.Builder对象 Bulk.Builder builder = new Bulk.Builder(); //2.3 创建Index对象 Index index1 = new Index.Builder(stu1).id(\"1008\").build(); Index index2 = new Index.Builder(stu2).id(\"1009\").build(); //2.4 赋值默认的索引名称及类型名 builder.defaultIndex(\"stu_temp_01\"); builder.defaultType(\"_doc\"); //2.5 添加Index之Bulk builder.addAction(index1); builder.addAction(index2); //2.6 真正构建Bulk对象 Bulk bulk = builder.build(); //2.7 执行批量写入数据操作 jestClient.execute(bulk); //3.关闭连接 jestClient.shutdownClient(); &#125;&#125; 读取数据（这里不使用json串，可读性不好） java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import io.searchbox.client.JestClient;import io.searchbox.client.JestClientFactory;import io.searchbox.client.config.HttpClientConfig;import io.searchbox.core.Search;import io.searchbox.core.SearchResult;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.TermQueryBuilder;import org.elasticsearch.search.builder.SearchSourceBuilder;import java.io.IOException;import java.util.List;import java.util.Map;public class ESReader &#123; public static void main(String[] args) throws IOException &#123; //1.获取客户端对象 //1.1 创建ES客户端的工厂对象 JestClientFactory jestClientFactory = new JestClientFactory(); //1.2 创建配置信息 HttpClientConfig config = new HttpClientConfig.Builder(\"http://hadoop102:9200\").build(); jestClientFactory.setHttpClientConfig(config); //1.3 获取客户端对象 JestClient jestClient = jestClientFactory.getObject(); //2.读取数据 //2.0 创建查询条件 SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder(); boolQueryBuilder.filter(new TermQueryBuilder(\"class_id\", \"190218\")); searchSourceBuilder.query(boolQueryBuilder); searchSourceBuilder.from(0); searchSourceBuilder.size(2); //2.1 创建Search对象 Search search = new Search.Builder(searchSourceBuilder.toString()) .addIndex(\"student\") .addType(\"_doc\") .build(); //2.2 执行查询操作 SearchResult searchResult = jestClient.execute(search); //2.3 解析searchResult System.out.println(\"查询数据\" + searchResult.getTotal() + \"条！\"); // [json对应map是常见操作] List&lt;SearchResult.Hit&lt;Map, Void&gt;&gt; hits = searchResult.getHits(Map.class); for (SearchResult.Hit&lt;Map, Void&gt; hit : hits) &#123; Map source = hit.source; for (Object key : source.keySet()) &#123; System.out.println(hit.id + \":\" + key.toString() + \":\" + source.get(key).toString()); &#125; System.out.println(\"*************\"); &#125; //3.关闭资源 jestClient.shutdownClient(); &#125;&#125; java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Stu.javapublic class Stu &#123; private String id; private String name; public Stu() &#123; &#125; public Stu(String id, String name) &#123; this.id = id; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Stu stu = (Stu) o; if (id != null ? !id.equals(stu.id) : stu.id != null) return false; return name != null ? name.equals(stu.name) : stu.name == null; &#125; @Override public int hashCode() &#123; int result = id != null ? id.hashCode() : 0; result = 31 * result + (name != null ? name.hashCode() : 0); return result; &#125; @Override public String toString() &#123; return \"Stu&#123;\" + \"id='\" + id + '\\'' + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"elasticsearch","slug":"大数据/elasticsearch","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/elasticsearch/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://masteryang4.github.io/tags/elasticsearch/"},{"name":"数据库","slug":"数据库","permalink":"https://masteryang4.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"MyISAM与InnoDB的区别(详)","slug":"MyISAM与InnoDB的区别-详","date":"2020-05-14T12:52:48.000Z","updated":"2020-05-14T13:47:24.563Z","comments":true,"path":"2020/05/14/MyISAM与InnoDB的区别-详/","link":"","permalink":"https://masteryang4.github.io/2020/05/14/MyISAM%E4%B8%8EInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%AF%A6/","excerpt":"","text":"MyISAM与InnoDB的区别（详）1.事务 InnoDB支持事务，MyISAM不支持。 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； 所以，博客中的《 MySQL事务相关 》一文，是基于InnoDB引擎的。 2.外键 InnoDB支持外键，而MyISAM不支持。 对一个包含外键的InnoDB表转为MYISAM会失败； 3.索引 InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。 MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的（联系本文第9点），索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。 4.表的具体行数 InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。 而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）； 那么为什么InnoDB没有了这个变量呢？ ​ 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。InnoDB会尝试遍历一个尽可能小的索引除非优化器提示使用别的索引。如果二级索引不存在，InnoDB还会尝试去遍历其他聚簇索引. ​ 如果索引并没有完全处于InnoDB维护的缓冲区（Buffer Pool）中，count操作会比较费时。可以建立一个记录总行数的表并让你的程序在INSERT/DELETE时更新对应的数据。和上面提到的问题一样，如果此时存在多个事务的话这种方案也不太好用。如果得到大致的行数值已经足够满足需求可以尝试： SHOW TABLE STATUS 5.全文索引 Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高； 5.7以后的InnoDB支持全文索引了。 6.表压缩 MyISAM表格可以被压缩后进行查询操作,压缩表是不能进行修改的(除非先将表解除压缩，修改数据，然后再次压缩)。压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升查询性能，压缩表也支持索引，但索引也只是只读的。 7.锁粒度 InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁。 InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。 潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁 T_T。 8.主键 InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有 9.表数据文件存储 Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI Innodb：frm是表定义文件，ibd是数据文件（共享表空间和单独表空间） Myisam：frm是表定义文件，myd是数据文件，myi是索引文件 索引选择 除非需要用到某些Innodb不具备的特性，并且没有其他办法可以代替，否则都应该优先选择innodb引擎。 参考文章 https://blog.csdn.net/qq_35642036/article/details/82820178 （里面的图片值得参考） https://www.cnblogs.com/timor0101/p/12883649.html","categories":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/categories/SQL/"},{"name":"MySQL","slug":"SQL/MySQL","permalink":"https://masteryang4.github.io/categories/SQL/MySQL/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"数据库","slug":"数据库","permalink":"https://masteryang4.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","permalink":"https://masteryang4.github.io/tags/MySQL/"}]},{"title":"MySQL事务相关","slug":"MySQL事务相关","date":"2020-05-14T09:10:57.000Z","updated":"2020-05-14T12:21:18.503Z","comments":true,"path":"2020/05/14/MySQL事务相关/","link":"","permalink":"https://masteryang4.github.io/2020/05/14/MySQL%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/","excerpt":"","text":"事务四大特性（ACID）1、原子性（Atomicity）： 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。 事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。 也就是说事务是一个不可分割的整体。 的基本单位 2、一致性（Consistency）： 事务开始前和结束后，数据库的完整性约束没有被破坏 。 比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。 3、隔离性（Isolation）： 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。 比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前，B 不能向这张卡转账。 4、持久性（Durability）： 事务完成后，事务对数据库的所有更新将被保存到数据库，不 能回滚。 MySQL事务隔离级别多个事务之间隔离的，相互独立的。 但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 不可重复读（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 隔离级别越高，效率越低。 大多数数据库的默认级别就是不可重复读（Read committed），比如Sql Server , Oracle 【注意】MySQL的默认事务隔离级别是——可重复读 事务并发存在的问题1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。 （一个事务，读取到另一个事务中没有提交的数据） 2、不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务 A多次读取同一数据时，结果不一致 。 （在同一个事务中，两次读取到的数据不一样 ） 3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 （一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到添加的数据） （ 一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行） 可重复读的隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读（历史版本）； insert、update和delete会更新版本号，是当前读（当前版本）。 幻读只在当前读下才会出现。 不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表等方法 幻读产生的原因： 行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。 解决幻读的其他方法： 将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为间隙锁。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/categories/SQL/"},{"name":"MySQL","slug":"SQL/MySQL","permalink":"https://masteryang4.github.io/categories/SQL/MySQL/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"数据库","slug":"数据库","permalink":"https://masteryang4.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"MySQL","slug":"MySQL","permalink":"https://masteryang4.github.io/tags/MySQL/"}]},{"title":"[精]zookeeper总结与思考","slug":"精-zookeeper总结与思考","date":"2020-05-14T08:30:13.000Z","updated":"2020-06-17T11:40:35.102Z","comments":true,"path":"2020/05/14/精-zookeeper总结与思考/","link":"","permalink":"https://masteryang4.github.io/2020/05/14/%E7%B2%BE-zookeeper%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"一、介绍概述Zookeeper是一个开源的分布式的，为分布式应用提供协调服务的Apache项目。多作为集群提供服务的中间件. Zookeeper从设计模式角度来理解，是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生了变化，Zookeeper就负责通知已经在Zookeeper上注册的那些观察者做出相应的反应. 分布式系统: 分布式系统指由很多台计算机组成的一个整体。 这个整体一致对外,并且处理同一请求，系统对内透明，对外不透明。 内部的每台计算机都可以相互通信，例如使用RPC 或者是WebService。客户端向一个分布式系统发送的一次请求到接受到响应，有可能会经历多台计算机。 Zookeeper = 文件系统 + 通知机制 特点中心化集群，但是中心化集群易出现单点故障。 数据结构 应用场景提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。 二、安装及操作需要提前安装JDK 两种部署方式：本地模式（standalone），分布式模式 分布式安装部署 版本：zookeeper-3.4.10 1、规划 将在hadoop102、hadoop103和hadoop104三个节点上部署Zookeeper。 2、解压安装 三台服务器分别解压：tar -zxvf zookeeper-3.4.10.tar.gz 解压后生成zookeeper-3.4.10目录 3、配置服务器编号 在zookeeper-3.4.10目录下创建zkData：mkdir -p zkData 进入目录：cd zkData 创建myid文件：touch myid 编辑文件：vim myid 在文件中添加与server对应的编号：比如hadoop02添加2； 在hadoop103、hadoop104上修改myid文件中内容为3、4 4、修改配置文件 zookeeper-3.4.10/conf这个目录下的zoo_sample.cfg重命名为zoo.cfg：mv zoo_sample.cfg zoo.cfg 打开zoo.cfg文件：vim zoo.cfg 在文件中修改数据存储路径配置： dataDir=/opt/module/zookeeper-3.4.10/zkData 并且增加如下配置： #######################cluster########################## server.2=hadoop102:2888:3888 server.3=hadoop103:2888:3888 server.4=hadoop104:2888:3888 同步zoo.cfg配置文件到其他所有服务器 【配置参数解读】server.A=B:C:D A是一个数字，表示这个是第几号服务器【myid】； zk启动时读取myid文件，拿到里面的数据与zoo.cfg里面的配置信息比较从而判断到底是哪个server。 B是这个服务器的ip地址； C是这个服务器与集群中的Leader服务器交换信息的端口2888；【副本】 D是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口3888。【选举信息】 【扩展】2181，客户端访问端口 5、相关操作 三台服务器在zookeeper-3.4.10下分别启动：bin/zkServer.sh start 查看状态：bin/zkServer.sh status shell123456789101112[ys@hadoop102 zookeeper-3.4.10]# bin/zkServer.sh statusJMX enabled by defaultUsing config: /opt/module/zookeeper-3.4.10/bin/../conf/zoo.cfgMode: follower[ys@hadoop103 zookeeper-3.4.10]# bin/zkServer.sh statusJMX enabled by defaultUsing config: /opt/module/zookeeper-3.4.10/bin/../conf/zoo.cfgMode: leader[ys@hadoop104 zookeeper-3.4.5]# bin/zkServer.sh statusJMX enabled by defaultUsing config: /opt/module/zookeeper-3.4.10/bin/../conf/zoo.cfgMode: follower 客户端命令行操作启动客户端：bin/zkCli.sh 命令基本语法 功能描述 help 显示所有操作命令 ls path [watch] 使用 ls 命令来查看当前znode中所包含的内容 ls2 path [watch] （详细信息）查看当前节点数据并能看到更新次数等数据 create 普通创建-s 含有序列-e 临时（重启或者超时消失） get path [watch] 获得节点的值 set 设置节点的具体值 stat 查看节点状态 delete 删除节点 rmr 递归删除节点 三、内部原理【重点】选举机制【重点】 半数机制： 集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。 内部投票选举： Zookeeper虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。 【举例】五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。这些服务器依序启动，则： Code1234567891011121314151617181920212223242526因为一共5台服务器，只有超过半数以上，即最少启动3台服务器，集群才能正常工作。（1）服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成；服务器1状态保持为LOOKING；（2）服务器2启动，再发起一次选举。服务器1和2分别投自己一票，此时服务器1发现服务器2的id比自己大，更改选票投给服务器2；此时服务器1票数0票，服务器2票数2票，不够半数以上（3票），选举无法完成；服务器1，2状态保持LOOKING；（3）服务器3启动，发起一次选举。与上面过程一样，服务器1和2先投自己一票，然后因为服务器3id最大，两者更改选票投给为服务器3；此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数（3票），服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；（4）服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3；服务器4并更改状态为FOLLOWING；（5）服务器5启动，同4一样投票给3，此时服务器3一共5票，服务器5为0票；服务器5并更改状态为FOLLOWING；最终Leader是服务器3，状态为LEADING；其余服务器是Follower，状态为FOLLOWING。 参考文章： https://blog.csdn.net/weixin_43291055/article/details/95451357 选举机制文章推荐： https://www.cnblogs.com/shuaiandjun/p/9383655.html https://blog.csdn.net/wyqwilliam/article/details/83537139 节点类型 监听器原理【重点】 写数据流程 【案例】监听服务器节点动态上下线/zk工作机制 API操作：1、maven依赖 xml123456&lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.10&lt;/version&gt;&lt;/dependency&gt; 2、集群上创建/servers节点 shell12[zk: localhost:2181(CONNECTED) 10] create /servers \"servers\"Created /servers 3、服务器端向Zookeeper注册 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.IOException;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooKeeper;import org.apache.zookeeper.ZooDefs.Ids;public class DistributeServer &#123; private static String connectString = \"hadoop102:2181,hadoop103:2181,hadoop104:2181\"; private static int sessionTimeout = 2000; private ZooKeeper zk = null; private String parentNode = \"/servers\"; // 创建到zk的客户端连接 public void getConnect() throws IOException&#123; zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; &#125; &#125;); &#125; // 注册服务器 public void registServer(String hostname) throws Exception&#123; String create = zk.create(parentNode + \"/server\", hostname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); System.out.println(hostname +\" is online \"+ create); &#125; // 业务功能 public void business(String hostname) throws Exception&#123; System.out.println(hostname+\" is working ...\"); Thread.sleep(Long.MAX_VALUE); &#125; public static void main(String[] args) throws Exception &#123; // 1获取zk连接 DistributeServer server = new DistributeServer(); server.getConnect(); // 2 利用zk连接注册服务器信息 server.registServer(args[0]); // 3 启动业务功能 server.business(args[0]); &#125;&#125; 4、客户端 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.IOException;import java.util.ArrayList;import java.util.List;import org.apache.zookeeper.WatchedEvent;import org.apache.zookeeper.Watcher;import org.apache.zookeeper.ZooKeeper;public class DistributeClient &#123; private static String connectString = \"hadoop102:2181,hadoop103:2181,hadoop104:2181\"; private static int sessionTimeout = 2000; private ZooKeeper zk = null; private String parentNode = \"/servers\"; // 创建到zk的客户端连接 public void getConnect() throws IOException &#123; zk = new ZooKeeper(connectString, sessionTimeout, new Watcher() &#123; @Override public void process(WatchedEvent event) &#123; // 再次启动监听 try &#123; getServerList(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; // 获取服务器列表信息 public void getServerList() throws Exception &#123; // 1获取服务器子节点信息，并且对父节点进行监听 List&lt;String&gt; children = zk.getChildren(parentNode, true); // 2存储服务器信息列表 ArrayList&lt;String&gt; servers = new ArrayList&lt;&gt;(); // 3遍历所有节点，获取节点中的主机名称信息 for (String child : children) &#123; byte[] data = zk.getData(parentNode + \"/\" + child, false, null); servers.add(new String(data)); &#125; // 4打印服务器列表信息 System.out.println(servers); &#125; // 业务功能 public void business() throws Exception&#123; System.out.println(\"client is working ...\");Thread.sleep(Long.MAX_VALUE); &#125; public static void main(String[] args) throws Exception &#123; // 1获取zk连接 DistributeClient client = new DistributeClient(); client.getConnect(); // 2获取servers的子节点信息，从中获取服务器信息列表 client.getServerList(); // 3业务进程启动 client.business(); &#125;&#125; 四、其他注意点：1、zk常用端口号： 2181，客户端访问端口2888，zk内部信息通讯（数据）3888，zk选举专用 2、zk不能越级创建节点； 且创建节点一般要带有数据（除非数据是null），否则创建会失败 shell1234567891011121314[zk: localhost:2181(CONNECTED) 1] create /ys/sss \"666\"Node does not exist: /ys/sss[zk: localhost:2181(CONNECTED) 2] create /ys \"666\" Created /ys...[zk: localhost:2181(CONNECTED) 16] create /ss nullCreated /ys [zk: localhost:2181(CONNECTED) 17] ls /[cluster, configs, controller, brokers, zookeeper, overseer, admin, isr_change_notification, controller_epoch, druid, aliases.json, live_nodes, collections, overseer_elect, spark, clusterstate.json, consumers, 【ss】, latest_producer_id_block, config, hbase, kylin][zk: localhost:2181(CONNECTED) 18] ls /ss[][zk: localhost:2181(CONNECTED) 19] get /ssnull... 常考面试题 请简述ZooKeeper的选举机制 半数机制：2n+1 10 台服务器：3 台 zk 20 台服务器：5 台 zk 100 台服务器：11 台 zk 【注意】台数并不是越多越好。 太多选举时间过长影响性能。 ZooKeeper的监听原理 ZooKeeper的常用命令 ZooKeeper的部署方式有哪几种？集群中的角色有哪些？集群最少需要几台机器？ 部署方式单机模式、集群模式 角色：Leader和Follower 集群最少需要机器数：3","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"zookeeper","slug":"大数据/zookeeper","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/zookeeper/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://masteryang4.github.io/tags/zookeeper/"},{"name":"分布式","slug":"分布式","permalink":"https://masteryang4.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"[精]Redis总结与思考","slug":"精-Redis总结与思考","date":"2020-05-12T14:20:49.000Z","updated":"2020-06-09T15:19:27.345Z","comments":true,"path":"2020/05/12/精-Redis总结与思考/","link":"","permalink":"https://masteryang4.github.io/2020/05/12/%E7%B2%BE-Redis%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"Redis介绍及安装Redis简介1、Redis是最常用的非关系型数据库（NoSQL）——不依赖业务逻辑方式存储，而以简单的key-value模式存储。 常见的NoSQL数据库： ​ Memcached,Redis,MongoDB,HBase 2、Redis有16个库，编号为0~15，默认使用0号库。 3、Redis使用的是单线程+多路IO复用技术（Linux系统特有）。 Redis安装及启动1、Redis安装步骤： 首先保证有gcc-c++工具，否则先执行：yum install gcc-c++ 下载获得redis-3.2.5.tar.gz后将它放入Linux目录 解压命令:tar -zxvf redis-3.2.5.tar.gz 解压完成后进入目录:cd redis-3.2.5 在redis-3.2.5目录下执行make命令 在redis-3.2.5目录下执行make install命令 2、Redis默认安装目录：/usr/local/bin redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何(服务启动起来后执行) redis-check-aof：修复有问题的AOF文件 redis-check-rdb：修复有问题RDB文件 redis-sentinel：Redis集群使用 redis-server：Redis服务器启动命令 redis-cli：客户端，操作入口 3、Redis启动： 备份redis.conf：拷贝一份redis.conf到其他目录 修改redis.conf文件将里面的daemonize no 改成 yes(128行)，让服务在后台启动 启动命令：执行 redis-server /root/myredis/redis.conf 用客户端访问: redis-cli -p 6379 关闭：客户端中输入shutdown，redis-server进程就已关闭。之后Ctrl+c退出客户端即可。 Redis数据类型 常用五大数据类型：String,list,set,hash,zset 五大数据类型常用指令： 0、Key Key常用指令 keys * 查询当前库的所有键 exists &lt;key&gt; 判断某个键是否存在 type &lt;key&gt; 查看键对应的数据的类型 del &lt;key&gt; 删除某个键 expire &lt;key&gt; &lt;seconds&gt; 为键值设置过期时间，单位秒 ttl &lt;key&gt; 查看还有多少秒过期，-1表示永不过期，-2表示已过期 dbsize 查看当前数据库的key的数量 flushdb 清空当前库 flushall 通杀全部库 1、String String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。 String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M String常用指令 get &lt;key&gt; 查询对应键值 set &lt;key&gt; &lt;value&gt; 添加键值对 append &lt;key&gt; &lt;value&gt; 将给定的&lt;value&gt;追加到原值的末尾 strlen &lt;key&gt; 获得值的长度 setnx &lt;key&gt; &lt;value&gt; 只有在 key 不存在时设置 key 的值 incr &lt;key&gt; 将 key 中储存的数字值增1。只能对数字值操作，如果为空，新增值为1 decr &lt;key&gt; 将 key 中储存的数字值减1。只能对数字值操作，如果为空，新增值为-1 incrby / decrby &lt;key&gt; &lt;步长&gt; 将 key 中储存的数字值增减。自定义步长 mset &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt; … 同时设置一个或多个 key-value对 mget &lt;key1&gt; &lt;key2&gt; &lt;key3&gt; … 同时获取一个或多个 value msetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt; … 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt; 获得值的范围，类似java中的substring setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt; 用 &lt;value&gt;覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始 setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt; 设置键值的同时，设置过期时间，单位秒 getset &lt;key&gt; &lt;value&gt; 以新换旧，设置了新值同时获得旧值 2、List 单键多值 Redis 列表是简单的字符串列表，按照插入顺序排序。 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。 List常用指令 lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt; … 从左边/右边插入一个或多个值 lpop/rpop &lt;key&gt; 从左边/右边吐出一个值。值在键在，值亡键亡。 rpoplpush &lt;key1&gt; &lt;key2&gt; 从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边 lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; 按照索引下标获得元素(从左到右) lindex &lt;key&gt; &lt;index&gt; 按照索引下标获得元素(从左到右) llen &lt;key&gt; 获得列表长度 linsert &lt;key&gt; before &lt;value&gt; &lt;newvalue&gt; 在&lt;value&gt;的前面插入&lt;newvalue&gt; lrem &lt;key&gt; &lt;n&gt; &lt;value&gt; 从左边删除n个value(从左到右) 3、Set Redis的Set是string类型的无序集合 它底层其实是一个value为null的hash表,所以添加，删除，查找的复杂度都是O(1)。 Set常用指令 sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; … 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。 smembers &lt;key&gt; 取出该集合的所有值 sismember &lt;key&gt; &lt;value&gt; 判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有返回1，没有返回0 scard &lt;key&gt; 返回该集合的元素个数。 srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; … 删除集合中的某个元素。 spop &lt;key&gt; &lt;n&gt; 随机从该集合中吐出一个或多个值。 srandmember &lt;key&gt; &lt;n&gt; 随机从该集合中取出n个值。不会从集合中删除。 sinter &lt;key1&gt; &lt;key2&gt; 返回两个集合的交集元素。 sunion &lt;key1&gt; &lt;key2&gt; 返回两个集合的并集元素。 sdiff &lt;key1&gt; &lt;key2&gt; 返回两个集合的差集元素。 4、Hash Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似Java里面的Map&lt;String,Object&gt; Hash常用指令 hset &lt;key&gt; &lt;field&gt; &lt;value&gt; 给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt; hget &lt;key&gt; &lt;field&gt; 从&lt;key&gt;集合&lt;field&gt;取出 value hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;… 批量设置hash的值 hexists key &lt;field&gt; 查看哈希表 key 中，给定域 field 是否存在 hkeys &lt;key&gt; 列出该hash集合的所有field hvals &lt;key&gt; 列出该hash集合的所有value hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt; 为哈希表 key 中的域 field 的值加上增量 increment hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt; 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 5、zset (sorted set) Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。 有序集合的所有成员都关联了一个评分（score） ，这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。（集合的成员是唯一的，但是评分可以是重复了的） 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。 zset常用指令 zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;… 将一个或多个 member 元素及其 score 值加入到有序集 key 当中 zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [WITHSCORES] 返回有序集 key 中，下标在&lt;start&gt; &lt;stop&gt;之间的元素。带WITHSCORES，可以让分数一起和值返回到结果集。 zrangebyscore key min max [withscores] [limit offset count] 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列 zrevrangebyscore key max min [withscores] [limit offset count] 同上，改为从大到小排列 zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt; 为元素的score加上增量 zrem &lt;key&gt; &lt;value&gt; 删除该集合下，指定值的元素 zcount &lt;key&gt; &lt;min&gt; &lt;max&gt; 统计该集合，分数区间内的元素个数 zrank &lt;key&gt; &lt;value&gt; 返回该值在集合中的排名，从0开始 Redis的Java客户端Jedismaven依赖： xml12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.1&lt;/version&gt;&lt;/dependency&gt; 注意事项： 禁用Linux的防火墙： 临时禁用：service iptables stop 关闭开机自启：chkconfig iptables off redis.conf中注释掉bind 127.0.0.1（61行） ,然后 protect-mode（80行）设置为 no。 Jedis测试连通性 java12345678public class Demo01 &#123; public static void main(String[] args) &#123; //连接本地的 Redis 服务 Jedis jedis = new Jedis(\"127.0.0.1\",6379); //查看服务是否运行，打出pong表示OK System.out.println(\"connection is OK==========&gt;: \"+jedis.ping()); &#125;&#125; Jedis-API: Key java12345678//keySet&lt;String&gt; keys = jedis.keys(\"*\");for (Iterator iterator = keys.iterator(); iterator.hasNext();) &#123; String key = (String) iterator.next(); System.out.println(key);&#125;System.out.println(\"jedis.exists====&gt;\"+jedis.exists(\"k2\"));System.out.println(jedis.ttl(\"k1\")); Jedis-API: String java12345System.out.println(jedis.get(\"k1\"));jedis.set(\"k4\",\"k4_Redis\");System.out.println(\"----------------------------------------\");jedis.mset(\"str1\",\"v1\",\"str2\",\"v2\",\"str3\",\"v3\");System.out.println(jedis.mget(\"str1\",\"str2\",\"str3\")); Jedis-API: List java1234List&lt;String&gt; list = jedis.lrange(\"mylist\",0,-1); for (String element : list) &#123; System.out.println(element); &#125; Jedis-API: Set java123456789jedis.sadd(\"orders\",\"jd001\");jedis.sadd(\"orders\",\"jd002\");jedis.sadd(\"orders\",\"jd003\");Set&lt;String&gt; set1 = jedis.smembers(\"orders\");for (Iterator iterator = set1.iterator(); iterator.hasNext();) &#123; String string = (String) iterator.next(); System.out.println(string);&#125;jedis.srem(\"orders\",\"jd002\"); Jedis-API: hash[注意] java1234567891011jedis.hset(\"hash1\",\"userName\",\"lisi\");System.out.println(jedis.hget(\"hash1\",\"userName\"));Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //【注意】map.put(\"telphone\",\"13810169999\");map.put(\"address\",\"atguigu\");map.put(\"email\",\"abc@163.com\");jedis.hmset(\"hash2\",map);List&lt;String&gt; result = jedis.hmget(\"hash2\", \"telphone\",\"email\");for (String element : result) &#123; System.out.println(element);&#125; Jedis-API: zset java123456789jedis.zadd(\"zset01\",60d,\"v1\");jedis.zadd(\"zset01\",70d,\"v2\");jedis.zadd(\"zset01\",80d,\"v3\");jedis.zadd(\"zset01\",90d,\"v4\");Set&lt;String&gt; s1 = jedis.zrange(\"zset01\",0,-1);for (Iterator iterator = s1.iterator(); iterator.hasNext();) &#123; String string = (String) iterator.next(); System.out.println(string);&#125; Redis事务 Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 Redis事务的主要作用就是串联多个命令防止别的命令插队 悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁(Optimistic Lock)， 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。 三特性： 1、单独的隔离操作 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 2、没有隔离级别的概念 队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题 3、不保证原子性 Redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 Redis持久化1、RDB （Redis DataBase） 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 备份是如何执行的： Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 关于fork：在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”，一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 在redis.conf中配置文件名称，默认为dump.rdb RDB优缺点： 优点 节省磁盘空间 恢复速度快 rdb的缺点 虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。 在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。 2、AOF （Append Of File） 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 AOF默认不开启，需要手动在配置文件中配置 可以在redis.conf中配置文件名称，默认为 appendonly.aof AOF和RDB同时开启，系统默认取AOF的数据 AOF文件故障恢复： AOF文件的保存路径，同RDB的路径一致。 如遇到AOF文件损坏，可通过 redis-check-aof --fix appendonly.aof 进行恢复 Rewrite： AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof。 AOF优缺点： 优点： 备份机制更稳健，丢失数据概率更低。 可读的日志文本，通过操作AOF稳健，可以处理误操作。 缺点： 比起RDB占用更多的磁盘空间。 恢复备份速度要慢。 每次读写都同步的话，有一定的性能压力。 存在个别Bug，造成恢复不能。 用哪个好呢 官方推荐两个都启用。 如果对数据不敏感，可以选单独用RDB。 不建议单独用 AOF，因为可能会出现Bug。 如果只是做纯内存缓存，可以都不用。 Redis主从复制概念：主从复制，就是主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。 用处：读写分离，性能扩展。容灾快速回复。 Code1234567891011配从(服务器)不配主(服务器):- 拷贝多个redis.conf文件include- 开启daemonize yes- Pid文件名字pidfile- 指定端口port- Log文件名字- Dump.rdb名字dbfilename- Appendonly 关掉或者换名字info replication:打印主从复制的相关信息slaveof &lt;ip&gt; &lt;port&gt; :成为某个实例的从服务器 一主二仆模式： 复制原理： 每次从机联通后，都会给主机发送sync指令 主机立刻进行存盘操作，发送RDB文件，给从机 从机收到RDB文件后，进行全盘加载 之后每次主机的写操作，都会立刻发送给从机，从机执行相同的命令 薪火相传： 上一个slave可以是下一个slave的Master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。 用 slaveof &lt;ip&gt; &lt;port&gt; 中途变更转向:会清除之前的数据，重新建立拷贝最新的 风险是一旦某个slave宕机，后面的slave都没法备份 反客为主： 当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。。 用 slaveof no one 将从机变为主机。 哨兵模式(sentinel)反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。 Code1234567891、配置哨兵：调整为一主二仆模式自定义的&#x2F;myredis目录下新建sentinel.conf文件在配置文件中填写内容： sentinel monitor mymaster 127.0.0.1 6379 1其中mymaster为监控对象起的服务器名称， 1 为 至少有多少个哨兵同意迁移的数量。 2、启动哨兵执行redis-sentinel &#x2F;myredis&#x2F;sentinel.conf 故障恢复： 1、新主登基 从下线的主服务的所有从服务里面挑选一个从服务，将其转成主服务选择条件依次为：（1）选择优先级靠前的（2）选择偏移量最大的（3）选择runid最小的从服务 2、群仆俯首 挑选出新的主服务之后，sentinel 向原主服务的从服务发送 slaveof 新主服务 的命令，复制新master 3、旧主俯首 当已下线的服务重新上线时，sentinel会向其发送slaveof命令，让其成为新主的从 优先级在redis.conf中slave-priority 100偏移量是指获得原主数据最多的每个redis实例启动后都会随机生成一个40位的runid","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Redis","slug":"大数据/Redis","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Redis/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"数据库","slug":"数据库","permalink":"https://masteryang4.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Redis","slug":"Redis","permalink":"https://masteryang4.github.io/tags/Redis/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://masteryang4.github.io/tags/JavaWeb/"}]},{"title":"JUnit常用注解","slug":"JUnit常用注解","date":"2020-05-12T11:49:00.000Z","updated":"2020-05-12T12:14:44.974Z","comments":true,"path":"2020/05/12/JUnit常用注解/","link":"","permalink":"https://masteryang4.github.io/2020/05/12/JUnit%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"JUnit常用注解JUnit是 Java平台最常用的测试框架 。 本文重点阐述JUnit4版本的@Before、@After、@BeforeClass、@AfterClass四个注解。 JUnit4，JUnit5注解对比 JUnit4 JUnit5 功能 @BeforeClass @BeforeAll 在当前类的所有测试方法之前执行。注解在【静态方法】上。 @AfterClass @AfterAll 在当前类中的所有测试方法之后执行。注解在【静态方法】上。 @Before @BeforeEach 在每个测试方法之前执行。注解在【非静态方法】上。 @After @AfterEach 在每个测试方法之后执行。注解在【非静态方法】上。 为什么 JUnit中@BeforeClass和@AfterClass标注的方法必须是static的 ？ 其实和JUnit的运行机制有关： 在JUnit中：每运行一个@Test方法，就会为该测试类新建一个新的实例。所以@BeforeClass和@AfterClass必须是static的，因为运行他们的时候，测试类还没有实例化。 这种设计有助于提高测试方法之间的独立性，因为每个@Test执行的时候，都新建了一个实例，这样的话，可以避免测试方法之间重用各个@Test方法里面的变量值。 示例： java12345678910111213141516import org.junit.Test;public class JUintDemo &#123; int i = 2; @Test public void test1() &#123; int i = 1; System.out.println(\"test1 i=\" + i); //test1 i=1 &#125; @Test public void test2() &#123; System.out.println(\"test2 i=\" + i); //test2 i=2 &#125;&#125; 代码示例java1234567891011121314151617181920212223242526272829303132333435import org.junit.*;public class JunitTest &#123; @BeforeClass //【静态方法】 public static void beforeClass() &#123; System.out.println(\"before class:begin this class================\"); &#125; @AfterClass //【静态方法】 public static void afterClass() &#123; System.out.println(\"after class:end this class=================\"); &#125; @Before public void before() &#123; System.out.println(\"before:begin test\"); &#125; @After public void after() &#123; System.out.println(\"after:end test\"); &#125; @Test public void Test() &#123; System.out.println(\"[this is a test!]\"); &#125; @Test public void Test2() &#123; System.out.println(\"[this is another test!!!!!]\"); &#125;&#125; 执行整个JunitTest文件，输出结果： Code12345678before class:begin this class&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;before:begin test[this is a test!]after:end testbefore:begin test[this is another test!!!!!]after:end testafter class:end this class&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 小结一整个JUnit4的单元测试用例执行顺序为： ​ @BeforeClass -&gt; @Before -&gt; @Test -&gt; @After -&gt; @AfterClass; 每一个单独的测试方法的调用顺序为： ​ @Before -&gt; @Test -&gt; @After;","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"基础知识","slug":"Java/基础知识","permalink":"https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"JUnit","slug":"JUnit","permalink":"https://masteryang4.github.io/tags/JUnit/"},{"name":"单元测试","slug":"单元测试","permalink":"https://masteryang4.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"[SparkSQL]UDAF自定义聚合函数","slug":"SparkSQL-UDAF自定义聚合函数","date":"2020-05-05T13:30:07.000Z","updated":"2020-05-05T13:45:04.384Z","comments":true,"path":"2020/05/05/SparkSQL-UDAF自定义聚合函数/","link":"","permalink":"https://masteryang4.github.io/2020/05/05/SparkSQL-UDAF%E8%87%AA%E5%AE%9A%E4%B9%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/","excerpt":"","text":"[SparkSQL]UDAF自定义聚合函数SparkSql中，用户可以设定自己的自定义聚合函数（UserDefinedAggregateFunction）。 需求：实现平均年龄 user.json 文件： json123&#123;\"username\": \"lisi\",\"userage\": 40&#125;&#123;\"username\": \"zhangsan\",\"userage\": 30&#125;&#123;\"username\": \"wangwu\",\"userage\":20&#125; UDAF - 弱类型scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import org.apache.spark.SparkConfimport org.apache.spark.sql.expressions.&#123;MutableAggregationBuffer, UserDefinedAggregateFunction&#125;import org.apache.spark.sql.types.&#123;DataType, DoubleType, LongType, StructField, StructType&#125;import org.apache.spark.sql.&#123;DataFrame, Row, SparkSession&#125;import org.apache.spark.util.AccumulatorV2object SparkSQL_UDAF01 &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"sparksql\") val spark = SparkSession.builder().config(sparkConf).getOrCreate() // TODO 读取JSON数据 val df: DataFrame = spark.read.json(\"input/user.json\") // TODO 使用自定义聚合函数实现年龄的平均值计算 // buffer // select avg(age) from user // 创建自定义函数 val udaf = new MyAvgAgeUDAF // 注册UDAF函数 spark.udf.register(\"avgAge\", udaf) df.createTempView(\"user\") spark.sql(\"select avgAge(userage) from user\").show spark.close &#125; /* * TODO 自定义聚合函数（UDAF） * 1. 继承UserDefinedAggregateFunction * 2. 重写方法 */ class MyAvgAgeUDAF extends UserDefinedAggregateFunction &#123; // TODO 传入聚合函数的数据结构 // 1 =&gt; age =&gt; Long override def inputSchema: StructType = &#123; StructType(Array( StructField(\"age\", LongType) )) &#125; // TODO 用于计算的缓冲区的数据结构 override def bufferSchema: StructType = &#123; StructType(Array( StructField(\"totalage\", LongType), StructField(\"totalcnt\", LongType) )) &#125; // TODO 输出结果的类型 override def dataType: DataType = DoubleType // TODO 函数稳定性（幂等性） // 给函数相同的输入值，计算结果也相同 override def deterministic: Boolean = true // TODO 用于计算的缓冲区初始化 override def initialize(buffer: MutableAggregationBuffer): Unit = &#123; buffer(0) = 0L buffer(1) = 0L &#125; // TODO 将输入的值更新到缓冲区中 override def update(buffer: MutableAggregationBuffer, input: Row): Unit = &#123; buffer(0) = buffer.getLong(0) + input.getLong(0) buffer(1) = buffer.getLong(1) + 1L &#125; // TODO 合并缓冲区 // MutableAggregationBuffer 继承了Row override def merge(buffer1: MutableAggregationBuffer, buffer2: Row): Unit = &#123; buffer1(0) = buffer1.getLong(0) + buffer2.getLong(0) buffer1(1) = buffer1.getLong(1) + buffer2.getLong(1) &#125; // TODO 计算结果 override def evaluate(buffer: Row): Any = &#123; buffer.getLong(0).toDouble / buffer.getLong(1) &#125; &#125;&#125; 输出： sql12345+---------------------+|myavgageudaf(userage)|+---------------------+| 30.0|+---------------------+ UDAF - 强类型scala123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import org.apache.spark.SparkConfimport org.apache.spark.sql.&#123;DataFrame, Dataset, Encoder, Encoders, SparkSession, TypedColumn&#125;import org.apache.spark.sql.expressions.Aggregatorobject UDAF02 &#123; def main(args: Array[String]): Unit = &#123; val conf: SparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"myudaf\") val spark: SparkSession = SparkSession.builder().config(conf).getOrCreate() import spark.implicits._ val df: DataFrame = spark.read.json(\"input/user.json\") //封装为DataSet val ds: Dataset[User01] = df.as[User01] //创建聚合函数 var myAgeUdtf1 = new MyAveragUDAF1 //将聚合函数转换为查询的列 val col: TypedColumn[User01, Double] = myAgeUdtf1.toColumn //查询 ds.select(col).show() &#125; //输入数据类型 case class User01(username: String, userage: Long) //缓存类型 case class AgeBuffer(var sum: Long, var count: Long) /** * 定义类继承org.apache.spark.sql.expressions.Aggregator * 重写类中的方法 */ class MyAveragUDAF1 extends Aggregator[User01, AgeBuffer, Double] &#123; override def zero: AgeBuffer = &#123; AgeBuffer(0L, 0L) &#125; override def reduce(b: AgeBuffer, a: User01): AgeBuffer = &#123; b.sum = b.sum + a.userage b.count = b.count + 1 b &#125; override def merge(b1: AgeBuffer, b2: AgeBuffer): AgeBuffer = &#123; b1.sum = b1.sum + b2.sum b1.count = b1.count + b2.count b1 &#125; override def finish(buff: AgeBuffer): Double = &#123; buff.sum.toDouble / buff.count &#125; //DataSet默认额编解码器，用于序列化，固定写法 //自定义类型就是produce 自带类型根据类型选择 override def bufferEncoder: Encoder[AgeBuffer] = &#123; Encoders.product &#125; override def outputEncoder: Encoder[Double] = &#123; Encoders.scalaDouble &#125; &#125;&#125; 输出： sql12345+-----------------------------------------------------+|MyAveragUDAF1(com.atguigu.sparksql.UDAF_qiang$User01)|+-----------------------------------------------------+| 30.0|+-----------------------------------------------------+","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"},{"name":"sparksql","slug":"sparksql","permalink":"https://masteryang4.github.io/tags/sparksql/"}]},{"title":"HashMap文章推荐","slug":"HashMap文章推荐","date":"2020-04-30T15:42:39.000Z","updated":"2020-05-09T13:27:03.153Z","comments":true,"path":"2020/04/30/HashMap文章推荐/","link":"","permalink":"https://masteryang4.github.io/2020/04/30/HashMap%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90/","excerpt":"","text":"HashMap文章推荐Java 8系列之重新认识HashMap 【强烈推荐】来自美团技术团队，里面的参考文章也非常好 《吊打面试官》系列-HashMap 《吊打面试官》系列-ConcurrentHashMap &amp; HashTable 来自敖丙（蘑菇街大佬），从面试官角度阐述关键技术点，十分硬核，全是干货。 一个HashMap跟面试官扯了半个小时 面试者角度阐述HashMap。 有空闲时间的话，我自己也会出一篇，甚至是一系列的HashMap文章， 比如 源码分析， 知识点总结， 常考面试题归档 等等","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"https://masteryang4.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"hashmap","slug":"hashmap","permalink":"https://masteryang4.github.io/tags/hashmap/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Java IO相关总结归纳","slug":"Java-IO相关总结归纳","date":"2020-04-29T14:12:12.000Z","updated":"2020-04-29T14:14:13.243Z","comments":true,"path":"2020/04/29/Java-IO相关总结归纳/","link":"","permalink":"https://masteryang4.github.io/2020/04/29/Java-IO%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"基础知识","slug":"Java/基础知识","permalink":"https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"}]},{"title":"[spark]十一种方式实现WordCount","slug":"spark-十一种方式实现WordCount","date":"2020-04-27T14:23:10.000Z","updated":"2020-04-27T15:12:53.079Z","comments":true,"path":"2020/04/27/spark-十一种方式实现WordCount/","link":"","permalink":"https://masteryang4.github.io/2020/04/27/spark-%E5%8D%81%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0WordCount/","excerpt":"","text":"[Spark]十一种方式实现WordCount使用Spark中的11种方法实现经典的WordCount算法。 其中，10种SparkRDD（算子）+ 1种自定义累加器实现。 特朗普：没人比我更懂WordCount！（滑稽） Why WordCount？ 大数据中最经典的算法，相当于编程语言中的“Hello World”。 在大数据处理中，大多数复杂的问题通常被拆分成一个个小问题，这些小问题一般都是基于WordCount算法。所以，WordCount是重中之重，是大数据处理算法的基石。 10种Spark算子实现scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import org.apache.spark.&#123;SparkConf, SparkContext&#125;import scala.collection.mutable/** * spark-使用十种[算子]实现wordcount */object RDDWordcount &#123; def main(args: Array[String]): Unit = &#123; val sparkConf = new SparkConf().setMaster(\"local[*]\").setAppName(\"spark\") val sc = new SparkContext(sparkConf) // val rdd = sc.textFile(\"input/wc.txt\").flatMap(datas =&gt; &#123; // datas.split(\" \") // &#125;) val rdd = sc.makeRDD(List(\"hadoop\", \"hello\", \"spark\", \"hello\", \"scala\", \"hello\", \"scala\", \"spark\")) println(\"=================1====================\") rdd.countByValue().foreach(println) println(\"=================2====================\") rdd.map((_, 1)).countByKey().foreach(println) println(\"=================3====================\") rdd.map((_, 1)).reduceByKey(_ + _).collect().foreach(println) println(\"=================4====================\") rdd.map((_, 1)).groupByKey().mapValues(_.size).collect().foreach(println) println(\"=================5====================\") rdd.map((_, 1)).aggregateByKey(0)(_ + _, _ + _).collect().foreach(println) println(\"=================6====================\") rdd.map((_, 1)).foldByKey(0)(_ + _).collect().foreach(println) println(\"=================7====================\") rdd.map((_, 1)).combineByKey( (num: Int) =&gt; num, (x: Int, y: Int) =&gt; &#123; x + y &#125;, (x: Int, y: Int) =&gt; &#123; x + y &#125; ).collect().foreach(println) println(\"=================8====================\") rdd.map((_, 1)).groupBy(_._1).map(kv =&gt; &#123; (kv._1, kv._2.size) &#125;).collect().foreach(println) println(\"=================9====================\") rdd.aggregate(mutable.Map[String, Int]())( (map, word) =&gt; &#123; map(word) = map.getOrElse(word, 0) + 1 map &#125;, (map1, map2) =&gt; &#123; map1.foldLeft(map2)( (finalMap, kv) =&gt; &#123; finalMap(kv._1) = finalMap.getOrElse(kv._1, 0) + kv._2 finalMap &#125; ) &#125; ).foreach(println) println(\"=================10====================\") rdd.map(s =&gt; mutable.Map(s -&gt; 1)).fold(mutable.Map[String, Int]())( (map1, map2) =&gt; &#123; map1.foldLeft(map2)( (finalMap, kv) =&gt; &#123; finalMap(kv._1) = finalMap.getOrElse(kv._1, 0) + kv._2 finalMap &#125; ) &#125; ).foreach(println) sc.stop() &#125;&#125; 输出结果： scala1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950=================1====================(hello,3)(spark,2)(hadoop,1)(scala,2)=================2====================(hello,3)(spark,2)(hadoop,1)(scala,2)=================3====================(hello,3)(spark,2)(hadoop,1)(scala,2)=================4====================(hello,3)(spark,2)(hadoop,1)(scala,2)=================5====================(hello,3)(spark,2)(hadoop,1)(scala,2)=================6====================(hello,3)(spark,2)(hadoop,1)(scala,2)=================7====================(hello,3)(spark,2)(hadoop,1)(scala,2)=================8====================(hello,3)(spark,2)(hadoop,1)(scala,2)=================9====================(hadoop,1)(spark,2)(scala,2)(hello,3)=================10====================(hadoop,1)(spark,2)(scala,2)(hello,3) 自定义累加器实现scala12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import org.apache.spark.rdd.RDDimport org.apache.spark.util.AccumulatorV2import org.apache.spark.&#123;SparkConf, SparkContext&#125;import scala.collection.mutableobject MyAccTest &#123; def main(args: Array[String]): Unit = &#123; val conf: SparkConf = new SparkConf().setAppName(\"acc\").setMaster(\"local[*]\") val sc: SparkContext = new SparkContext(conf) // TODO Spark - 自定义累加器 - wordcount // 累加器可以不使用shuffle就完成数据的聚合功能 val rdd: RDD[String] = sc.makeRDD(List(\"hadoop spark\", \"hello\", \"spark\", \"hello\", \"scala\", \"hello\", \"scala\", \"spark\")) // TODO 1. 创建累加器 val acc = new WordCountAccumulator // TODO 2. 向Spark注册累加器 sc.register(acc, \"wordcount\") // TODO 3. 使用累加器 rdd.foreach( words =&gt; &#123; val ws = words.split(\" \") ws.foreach( word =&gt; &#123; acc.add(word) &#125; ) &#125; ) println(acc.value) //Map(hadoop -&gt; 1, spark -&gt; 3, scala -&gt; 2, hello -&gt; 3) sc.stop() &#125; // 自定义累加器 Map&#123;(Word - Count), (Word - Count)&#125; // 1, 继承AccumulatorV2, 定义泛型 // IN : 向累加器传递的值的类型 , Out : 累加器的返回结果类型 // 2. 重写方法 class WordCountAccumulator extends AccumulatorV2[String, mutable.Map[String, Int]] &#123; var innerMap = mutable.Map[String, Int]() // TODO 累加器是否初始化 // Z override def isZero: Boolean = innerMap.isEmpty // TODO 复制累加器 override def copy(): AccumulatorV2[String, mutable.Map[String, Int]] = &#123; new WordCountAccumulator &#125; // TODO 重置累加器 override def reset(): Unit = &#123; innerMap.clear() &#125; // TODO 累加数据 override def add(word: String): Unit = &#123; val cnt = innerMap.getOrElse(word, 0) innerMap.update(word, cnt + 1) &#125; // TODO 合并累加器 override def merge(other: AccumulatorV2[String, mutable.Map[String, Int]]): Unit = &#123; // 两个Map的合并 var map1 = this.innerMap var map2 = other.value innerMap = map1.foldLeft(map2)( (map, kv) =&gt; &#123; val k = kv._1 val v = kv._2 map(k) = map.getOrElse(k, 0) + v map &#125; ) &#125; // TODO 获取累加器的值，就是累加器的返回结果 override def value: mutable.Map[String, Int] = innerMap &#125;&#125; 输出结果： scala1Map(spark -&gt; 3, hadoop -&gt; 1, scala -&gt; 2, hello -&gt; 3)","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"大数据/spark","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"spark","slug":"spark","permalink":"https://masteryang4.github.io/tags/spark/"},{"name":"scala","slug":"scala","permalink":"https://masteryang4.github.io/tags/scala/"},{"name":"wordcount","slug":"wordcount","permalink":"https://masteryang4.github.io/tags/wordcount/"}]},{"title":"kafka高效读写数据","slug":"kafka高效读写数据","date":"2020-04-27T12:28:01.000Z","updated":"2020-06-18T06:40:37.634Z","comments":true,"path":"2020/04/27/kafka高效读写数据/","link":"","permalink":"https://masteryang4.github.io/2020/04/27/kafka%E9%AB%98%E6%95%88%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/","excerpt":"","text":"kafka高效读写数据一、分布式集群Kafka本身是分布式集群；同时采用分区技术，并发度高。 zookeeper在kafka中的作用：kafka集群中有一个broker会被选举成controller，负责管理集群broker的上下线，所有的topic分区副本分配和leader选举等工作。controller的管理工作都依赖于zk。 二、顺序写磁盘Kafka的producer生产数据，要写入到log文件中，写的过程是一直追加到文件末端，为顺序写。官网有数据表明，同样的磁盘，顺序写能到600M/s，而随机写只有100K/s。这与磁盘的机械机构有关，顺序写之所以快，是因为其省去了大量磁头寻址的时间。 三、零复制技术kafka零复制技术示意图： java复制技术示意图： （仅仅复制文件，没有对于文件的应用，效率很低。 文件要经过操作系统层（OS层）Buffer缓存传给java应用层输入流，输入流再将数据写到输出流，输出流将数据写到OS层缓存，缓存在将数据写到新的文件。。。） 因为java复制技术在拷贝文件时效率较低，所以对上图做出优化，如下图所示： （应用层通知操作系统层：仅仅是复制文件，所以操作系统层就不会将数据传给应用层，直接在操作系统层复制文件即可。）","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"大数据/kafka","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/"}],"tags":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"kafka","slug":"kafka","permalink":"https://masteryang4.github.io/tags/kafka/"}]},{"title":"flume总结与思考","slug":"精-flume总结与思考","date":"2020-04-24T15:50:53.000Z","updated":"2020-05-14T08:34:21.325Z","comments":true,"path":"2020/04/24/精-flume总结与思考/","link":"","permalink":"https://masteryang4.github.io/2020/04/24/%E7%B2%BE-flume%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"flume","slug":"大数据/flume","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/flume/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"教程","slug":"教程","permalink":"https://masteryang4.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"flume","slug":"flume","permalink":"https://masteryang4.github.io/tags/flume/"}]},{"title":"kafka分区分配策略","slug":"kafka分区分配策略","date":"2020-04-23T09:09:56.000Z","updated":"2020-06-18T06:40:54.884Z","comments":true,"path":"2020/04/23/kafka分区分配策略/","link":"","permalink":"https://masteryang4.github.io/2020/04/23/kafka%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","excerpt":"","text":"kafka分区分配策略kafka系列总结之：kafka分区分配策略[转载&amp;归纳] kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。 Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据 kafka官网： kafka.apache.org kafka分区分配策略文章索引 1、 Kafka分区分配策略（1）——RangeAssignor 2、 Kafka分区分配策略（2）——RoundRobinAssignor和StickyAssignor 3、 Kafka分区分配策略（3）——自定义分区分配策略 4、 Kafka分区分配策略（4）——分配的实施 [注]作者为 《深入理解Kafka:核心设计与实践原理》 的作者：朱忠华老师 作者更多kafka技术文章： https://blog.csdn.net/u013256816/category_6500871.html 作者个人博客： http://honeypps.com/ 作者CSDN博客： https://blog.csdn.net/u013256816","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"大数据/kafka","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"kafka","slug":"kafka","permalink":"https://masteryang4.github.io/tags/kafka/"}]},{"title":"scala中的flatMap和foldLeft函数","slug":"scala中的flatMap和foldLeft函数","date":"2020-04-21T14:34:32.000Z","updated":"2020-04-27T15:10:43.047Z","comments":true,"path":"2020/04/21/scala中的flatMap和foldLeft函数/","link":"","permalink":"https://masteryang4.github.io/2020/04/21/scala%E4%B8%AD%E7%9A%84flatMap%E5%92%8CfoldLeft%E5%87%BD%E6%95%B0/","excerpt":"","text":"scala中的flatMap和foldLeft函数scala由于其函数式编程的特性，在大数据的处理中被广泛使用。 此文针对scala集合中两个常用的，却不太好理解的函数进行示例讲解。 flatMapscala中最重要的函数之一，映射扁平化 把握以下三点即可： 1、flatMap = map + flatten 2、什么类型调用的flatMap方法，则返回的也是什么类型 3、先对集合中的每个元素进行map， ​ 再对map后的每个元素（map后的每个元素必须还是集合）中的每个元素进行flatten [注] 进行map的对象可以是只含一层的集合，但进行flatten操作的对象必需是至少含两层的集合 map和flatten示例： scala123456789101112131415object Test0001 &#123; def main(args: Array[String]): Unit = &#123; val list = List(1,2,3,4) // 集合映射 println(\"map =&gt; \" + list.map(x=&gt;&#123;x*2&#125;)) //map =&gt; List(2, 4, 6, 8) println(\"map =&gt; \" + list.map(x=&gt;x*2)) //map =&gt; List(2, 4, 6, 8) println(\"map =&gt; \" + list.map(_*2)) //map =&gt; List(2, 4, 6, 8) // 集合扁平化 val list1 = List( List(1,2), List(3,4) ) println(\"flatten =&gt;\" + list1.flatten) //flatten =&gt;List(1, 2, 3, 4) &#125;&#125; flatMap示例一： scala123val words = Set(\"scala\", \"spark\", \"hadoop\")val result = words.flatMap(x =&gt; x.toUpperCase)println(result) //Set(A, L, P, C, H, K, R, O, D, S) flatMap示例二： scala123456val tuples: List[(String, Int)] = List((\"Hello Scala\", 4), (\"Hello Spark\", 2))val strings: List[String] = tuples.map(t=&gt;&#123;(t._1+\" \")*t._2&#125;)//List(Hello Scala Hello Scala Hello Scala Hello Scala , Hello Spark Hello Spark )val flatMapList: List[String] = strings.flatMap(t=&gt;&#123;t.split(\" \")&#125;)//List(Hello, Scala, Hello, Scala, Hello, Scala, Hello, Scala, Hello, Spark, Hello, Spark) flatMap示例三： scala1234567val linesList = List((\"Hello Scala\", 4), (\"Hello Spark\", 2))val flatMapList: List[(String, Int)] = linesList.flatMap(t =&gt; &#123; val line: String = t._1 val words = line.split(\" \") words.map(w =&gt; (w, t._2))&#125;)println(flatMapList) //List((Hello,4), (Scala,4), (Hello,2), (Spark,2)) 根据上述三个原则即可算出函数结果。 foldLeft集合折叠函数，fold、foldRight底层都是基于foldLeft函数。 所以本文用到的函数可以不用严格区分，主要阐述其原理。 scala1def fold[A1 &gt;: A](z: A1)(op: (A1, A1) =&gt; A1): A1 = foldLeft(z)(op) 就是将集合的数据和集合之外的数据进行聚合操作。 fold方法有函数柯里化，有2个参数列表 第一个参数列表：集合之外的数据 第二个参数列表：表示计算规则 fold示例一： scala12345val list = List(1, 2, 3, 4)// 集合折叠println(\"fold =&gt; \" + list.fold(0)(_+_)) //10// 集合折叠(左)println(\"foldLeft =&gt; \" + list.foldLeft(0)(_+_)) //10 fold示例二： scala123456789101112131415161718192021object Scala21_Collection_Method4 &#123; def main(args: Array[String]): Unit = &#123; // 将两个Map集合进行合并(merge)处理 val map1 = mutable.Map(\"a\" -&gt; 1, \"b\" -&gt; 2, \"c\" -&gt; 3) val map2 = mutable.Map(\"a\" -&gt; 4, \"d\" -&gt; 5, \"c\" -&gt; 6) // Map( \"a\"-&gt;5, \"b\"-&gt;2, \"c\"-&gt;9 ,\"d\"-&gt;5) val map3 = map2.foldLeft(map1)( (map, kv) =&gt; &#123; val k = kv._1 val v = kv._2 //map.update(k, map.getOrElse(k, 0) + v) map(k) = map.getOrElse(k, 0) + v map &#125; ) println(map3) //Map(b -&gt; 2, d -&gt; 5, a -&gt; 5, c -&gt; 9) println(map1) //Map(b -&gt; 2, d -&gt; 5, a -&gt; 5, c -&gt; 9) println(map2) //Map(d -&gt; 5, a -&gt; 4, c -&gt; 6) &#125;&#125; 原理示意图如下： 总结： 其实，在foldleft函数中，第二个参数规定的就是， foldleft第一个参数和foldleft调用者的第一个元素的运算规则 可以用如下公式理解： a. foldLeft( b )( (b,a的第一个元素)=&gt;{} ) （对应上面示意图：红色块为b，蓝色块为a） 只不过在此公式中b和a的第一个元素都是动态变化的： ​ b一直在迭代，a会继续往后顺序取后面的值。 ​ 其实函数最终返回值就是b的值（上面的例子map1和map3相等也能证明这一点，本质就是map1把值赋给了map3），且a不发生改变。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"scala","slug":"大数据/scala","permalink":"https://masteryang4.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/scala/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"scala","slug":"scala","permalink":"https://masteryang4.github.io/tags/scala/"}]},{"title":"Java空指针问题的本质","slug":"Java空指针问题的本质","date":"2020-04-18T15:58:28.000Z","updated":"2020-04-18T16:00:16.725Z","comments":true,"path":"2020/04/18/Java空指针问题的本质/","link":"","permalink":"https://masteryang4.github.io/2020/04/18/Java%E7%A9%BA%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"基础知识","slug":"Java/基础知识","permalink":"https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试题：sleep和wait的区别","slug":"sleep和wait的区别小结","date":"2020-04-14T08:01:30.000Z","updated":"2020-04-16T15:49:47.457Z","comments":true,"path":"2020/04/14/sleep和wait的区别小结/","link":"","permalink":"https://masteryang4.github.io/2020/04/14/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93/","excerpt":"","text":"Java中sleep和wait方法的区别 sleep和wait都能使线程处于阻塞状态，但二者有着本质区别。 代码示例java123456789101112131415161718public class test_thread &#123; public static void main(String[] args) throws Exception &#123; Thread t1 = new Thread(); Thread t2 = new Thread(); //【本质区别】静态方法和成员方法 //【静态方法】，绑定的是类。休眠的线程不是t1，是当前运行的main线程 //和对象都没有关系，所以不存在什么对象锁 t1.sleep(1000); Thread.sleep(1000); //【成员方法】，等待的线程就是t2 //有同步/synchronized关键字才能拿到对象锁。 t2.wait(); t2.wait(1000);//wait也可以加等待时间 //【扩展】scala中的伴生对象就是对静态语法的模拟 &#125;&#125; 总结 【核心】静态方法、成员方法 sleep是Thread类的静态方法。sleep的作用是让线程休眠道制定的时间，在时间到达时恢复，也就是说sleep将在接到时间到达事件事恢复线程执行。 wait是Object的方法，也就是说可以对任意一个对象调用wait方法，调用wait方法将会属将调用者的线程挂起，直到其他线程调用同一个对象的notify方法才会重新激活调用者。 sleep方法没有释放锁（lock），而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 【使用范围】 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用， 而sleep可以在任何地方使用","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"多线程","slug":"Java/多线程","permalink":"https://masteryang4.github.io/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"}]},{"title":"Git使用小结","slug":"Git使用小结","date":"2020-04-12T16:25:50.000Z","updated":"2020-06-07T16:02:10.436Z","comments":true,"path":"2020/04/13/Git使用小结/","link":"","permalink":"https://masteryang4.github.io/2020/04/13/Git%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/","excerpt":"","text":"Git使用小结小结Git常用指令，以及如何将本地代码同步/更新到Github的常用指令 一、初始配置git安装完成后，需要设置一下，在命令行输入 Code12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; –global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 二、常用指令进入到自己的项目文件下右键选择Git Bash Here打开git客户端 初始化项目： Code1git init 将文件添加到本地仓库： Code1git add 将文件提交到仓库 Code1git commit -m &quot;注释内容&quot; 关联远程项目（你的远程仓库地址） Code1git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;xxx.git 本地推送到远程（ 第一次推送master分支的所有内容） 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 Code1git push -u origin master 查看Git状态 Code1git status 三、更新文件到GithubCode1234git addgit commit -m &quot;注释内容&quot;git pull origin master #从远程抓取分支，使用git pull，如果有冲突，要先处理冲突git push origin master 查看远程库信息： Code1git remote -v 会显示可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。","categories":[{"name":"Git&Github","slug":"Git-Github","permalink":"https://masteryang4.github.io/categories/Git-Github/"}],"tags":[{"name":"Git&Github","slug":"Git-Github","permalink":"https://masteryang4.github.io/tags/Git-Github/"}]},{"title":"关于i=i++的分析与思考","slug":"关于i-i-的分析与思考","date":"2020-04-10T16:00:30.000Z","updated":"2020-04-18T15:22:45.874Z","comments":true,"path":"2020/04/11/关于i-i-的分析与思考/","link":"","permalink":"https://masteryang4.github.io/2020/04/11/%E5%85%B3%E4%BA%8Ei-i-%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"基础知识","slug":"Java/基础知识","permalink":"https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"}]},{"title":"关于HashMap的两道小面试题","slug":"关于HashMap的两道小面试题","date":"2020-04-10T16:00:16.000Z","updated":"2020-04-18T15:23:25.435Z","comments":true,"path":"2020/04/11/关于HashMap的两道小面试题/","link":"","permalink":"https://masteryang4.github.io/2020/04/11/%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E4%B8%A4%E9%81%93%E5%B0%8F%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"https://masteryang4.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"String_StringBuffer_StringBuilder分析总结","slug":"String_StringBuffer_StringBuilder分析总结","date":"2020-04-10T16:00:03.000Z","updated":"2020-04-24T15:48:19.991Z","comments":true,"path":"2020/04/11/String_StringBuffer_StringBuilder分析总结/","link":"","permalink":"https://masteryang4.github.io/2020/04/11/String_StringBuffer_StringBuilder%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/","excerpt":"","text":"String_StringBuffer_StringBuilder分析总结本文对Java语言中的String，StringBuffer，StringBuilder类进行分析对比， 并String类型进行简单原理分析。 String，StringBuffer，StringBuilder的区别1、可变与不可变 String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。 java1private final char value[]; StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。 java1char[] value; 2、是否多线程安全 String中的对象是不可变的，也就可以理解为常量，显然线程安全。 AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。 StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 ​ StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。看如下源码： java12345678public synchronized StringBuffer reverse() &#123; super.reverse(); return this;&#125;public int indexOf(String str) &#123; return indexOf(str, 0); //存在 public synchronized int indexOf(String str, int fromIndex) 方法&#125; 3、StringBuilder与StringBuffer共同点 StringBuilder与StringBuffer有公共父类AbstractStringBuilder(抽象类)。 抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。 StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(…)。只是StringBuffer会在方法上加synchronized关键字，进行同步。 如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 String相关String类部分源码： java123456789101112131415161718192021222324252627282930313233343536public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; //... public String() &#123; this.value = \"\".value; &#125; public String(String original) &#123; this.value = original.value; this.hash = original.hash; &#125; public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length); &#125; //... public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; 说明： private final char value[];说明String不可变 其实不可变指的是其字符串内容不可变，字符串对象的地址其实是可以改变的，示例如下： java1234String a = \"ABCabc\";System.out.println(\"a = \" + a); //a = ABCabca = a.replace('A', 'a');System.out.println(\"a = \" + a); //a = aBCabc ​ 这个例子的本质是，字符串对象a指向了一个新的字符串数组。 如果真的要去修改String内容的话，其实也是可以的，使用反射机制就可以实现，示例如下： java123456789101112131415161718192021public static void testReflection() throws Exception &#123; //创建字符串\"Hello World\"， 并赋给引用s String s = \"Hello World\"; System.out.println(\"s = \" + s); //Hello World //获取String类中的value字段 Field valueFieldOfString = String.class.getDeclaredField(\"value\"); //改变value属性的访问权限 valueFieldOfString.setAccessible(true); //获取s对象上的value属性的值 char[] value = (char[]) valueFieldOfString.get(s); //改变value所引用的数组中的第5个字符 value[5] = '_'; System.out.println(\"s = \" + s); //Hello_World&#125; 参考博客： https://www.cnblogs.com/leskang/p/6110631.html https://www.cnblogs.com/xudong-bupt/p/3961159.html","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"基础知识","slug":"Java/基础知识","permalink":"https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"}]},{"title":"Java中final关键字小结","slug":"Java中final关键字小结","date":"2020-04-10T15:59:41.000Z","updated":"2020-04-16T15:44:18.891Z","comments":true,"path":"2020/04/10/Java中final关键字小结/","link":"","permalink":"https://masteryang4.github.io/2020/04/10/Java%E4%B8%ADfinal%E5%85%B3%E9%94%AE%E5%AD%97%E5%B0%8F%E7%BB%93/","excerpt":"","text":"Java中final关键字小结一、final、finally、finalize的区别final： 修饰符（关键字）有三种用法：修饰类、变量和方法。 修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。 修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。（下一节代码示例） 修饰方法时，也同样只能使用，不能在子类中被重写。 finally: 通常放在 try…catch 的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在finally块中。 finalize： Object 类中定义的方法。 Java 中允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。 这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize() 方法可以整理系统资源或者执行其他清理工作。 二、代码示例java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class zd_important_test_nbst &#123; public static void main(String[] args) &#123; UserTest userTest = new UserTest(); System.out.println(userTest.getA()); UserTest userTest1 = new UserTest(6); System.out.println(userTest1.getA()); &#125;&#125;class UserTest &#123; /** * final修饰的变量，要么一开始就初始化（饿汉式），要么就在构造方法里初始化（懒汉式）。 * 一旦初始化完成，就不能修改。 * * 【String中同样，使用private final修饰char[]】所以String是不可变的。 * （通过反射可以破坏其不可变性） * 其他博客会提到上述内容。 */ private final int a; public UserTest() &#123; super(); a = 1; &#125; public UserTest(int a) &#123; this.a = a; &#125; public int getA() &#123; return a; &#125; //会报错，因为a是final// public void setA(int b) &#123;// this.a = b;// &#125; /** * 以下为idea默认生成的hashcode和equals，可忽略 * * 在Object的源码中，hashcode是native方法，使用c语言实现的，综合类的信息计算出的hashcode值 * equals底层就是“==” */ @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; UserTest userTest = (UserTest) o; return a == userTest.a; &#125; @Override public int hashCode() &#123; return Objects.hash(a); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"基础知识","slug":"Java/基础知识","permalink":"https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"}]},{"title":"Java静态代码块的加载时机","slug":"Java静态代码块的加载时机","date":"2020-04-10T15:57:07.000Z","updated":"2020-04-18T15:22:19.726Z","comments":true,"path":"2020/04/10/Java静态代码块的加载时机/","link":"","permalink":"https://masteryang4.github.io/2020/04/10/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/","excerpt":"","text":"Java静态代码块的加载时机在java中，静态代码块其实并不是随着类的加载而加载。","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"基础知识","slug":"Java/基础知识","permalink":"https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"}]},{"title":"SQL的执行顺序问题","slug":"SQL的执行顺序问题","date":"2020-04-10T15:44:24.000Z","updated":"2020-04-14T13:41:32.432Z","comments":true,"path":"2020/04/10/SQL的执行顺序问题/","link":"","permalink":"https://masteryang4.github.io/2020/04/10/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"SQL的执行顺序问题众所周知，sql的执行顺序： sql1from... where...group by... having....select ... order by... limit 但是，有一个“bug”，在 MySQL 中： sql1SELECT title, COUNT(title) AS t FROM table GROUP BY title HAVING t &gt;= 2 这样的语句是可以执行的。 正常来说，having在select之前执行，但是却可以使用select的别名，这是为什么呢？ 查阅了一切资料，做出如下解释： 解释一 mysql的处理方式是中间生成虚拟表（或者叫临时表），而这个虚拟表的生成的列靠的就是select。 所以猜测类似having之后的操作，其实内部已经根据select生成了虚拟表，列自然也是as后的。 解释二 之所以MYSQL可以这么做是因为MYSQL用的是临时表， 在having前已经产生了数据，所以可以用别名，但SQL Sever不可以，SQL是在having后才Select。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/categories/SQL/"},{"name":"MySQL","slug":"SQL/MySQL","permalink":"https://masteryang4.github.io/categories/SQL/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://masteryang4.github.io/tags/MySQL/"}]},{"title":"LeetCode经典10道题","slug":"LeetCode经典10道题","date":"2020-03-22T15:36:52.000Z","updated":"2020-06-02T15:12:37.693Z","comments":true,"path":"2020/03/22/LeetCode经典10道题/","link":"","permalink":"https://masteryang4.github.io/2020/03/22/LeetCode%E7%BB%8F%E5%85%B810%E9%81%93%E9%A2%98/","excerpt":"","text":"LeetCode题目精选1. 两数之和链接：https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 Code1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题解： java12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 2. 爬楼梯链接：https://leetcode-cn.com/problems/climbing-stairs/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： Code12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： Code123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 题解： java1234567891011121314public class Solution &#123; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125; 3. 翻转二叉树链接：https://leetcode-cn.com/problems/invert-binary-tree/ 翻转一棵二叉树。 示例： 输入： Code12345 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\1 3 6 9 输出： Code12345 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\9 6 3 1 题解： java12345678910public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; TreeNode right = invertTree(root.right); TreeNode left = invertTree(root.left); root.left = right; root.right = left; return root;&#125; 4. 反转链表链接：https://leetcode-cn.com/problems/reverse-linked-list/ 反转一个单链表。 示例: Code12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 题解： java1234567891011public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; &#125; return prev;&#125; 5. LRU缓存机制链接：https://leetcode-cn.com/problems/lru-cache/ 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: Code1234567891011LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );cache.put(1, 1);cache.put(2, 2);cache.get(1); &#x2F;&#x2F; 返回 1cache.put(3, 3); &#x2F;&#x2F; 该操作会使得密钥 2 作废cache.get(2); &#x2F;&#x2F; 返回 -1 (未找到)cache.put(4, 4); &#x2F;&#x2F; 该操作会使得密钥 1 作废cache.get(1); &#x2F;&#x2F; 返回 -1 (未找到)cache.get(3); &#x2F;&#x2F; 返回 3cache.get(4); &#x2F;&#x2F; 返回 4 题解： java12345678910111213141516171819202122232425262728class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123; private int capacity; public LRUCache(int capacity) &#123; super(capacity, 0.75F, true); this.capacity = capacity; &#125; public int get(int key) &#123; return super.getOrDefault(key, -1); &#125; public void put(int key, int value) &#123; super.put(key, value); &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123; return size() &gt; capacity; &#125;&#125;/** * LRUCache 对象会以如下语句构造和调用: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 6. 最长回文子串链接：https://leetcode-cn.com/problems/longest-palindromic-substring/ 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： Code123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： Code12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 题解： java1234567891011121314151617181920212223public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return \"\"; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125;private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1;&#125; 7. 有效的括号链接：https://leetcode-cn.com/problems/valid-parentheses/ 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 1. 左括号必须用相同类型的右括号闭合。 2. 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: Code12输入: &quot;()&quot;输出: true 示例 2: Code12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3: Code12输入: &quot;(]&quot;输出: false 示例 4: Code12输入: &quot;([)]&quot;输出: false 示例 5: Code12输入: &quot;&#123;[]&#125;&quot;输出: true 题解： java1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; // Hash table that takes care of the mappings. private HashMap&lt;Character, Character&gt; mappings; // Initialize hash map with mappings. This simply makes the code easier to read. public Solution() &#123; this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); this.mappings.put('&#125;', '&#123;'); this.mappings.put(']', '['); &#125; public boolean isValid(String s) &#123; // Initialize a stack to be used in the algorithm. Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); // If the current character is a closing bracket. if (this.mappings.containsKey(c)) &#123; // Get the top element of the stack. If the stack is empty, set a dummy value of '#' char topElement = stack.empty() ? '#' : stack.pop(); // If the mapping for this bracket doesn't match the stack's top element, return false. if (topElement != this.mappings.get(c)) &#123; return false; &#125; &#125; else &#123; // If it was an opening bracket, push to the stack. stack.push(c); &#125; &#125; // If the stack still contains elements, then it is an invalid expression. return stack.isEmpty(); &#125;&#125; 8. 数组中的第K个最大元素链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/ 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: Code12输入: [3,2,1,5,6,4] 和 k &#x3D; 2输出: 5 示例 2: Code12输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 题解： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Random;class Solution &#123; int [] nums; public void swap(int a, int b) &#123; int tmp = this.nums[a]; this.nums[a] = this.nums[b]; this.nums[b] = tmp; &#125; public int partition(int left, int right, int pivot_index) &#123; int pivot = this.nums[pivot_index]; // 1. move pivot to end swap(pivot_index, right); int store_index = left; // 2. move all smaller elements to the left for (int i = left; i &lt;= right; i++) &#123; if (this.nums[i] &lt; pivot) &#123; swap(store_index, i); store_index++; &#125; &#125; // 3. move pivot to its final place swap(store_index, right); return store_index; &#125; public int quickselect(int left, int right, int k_smallest) &#123; /* Returns the k-th smallest element of list within left..right. */ if (left == right) // If the list contains only one element, return this.nums[left]; // return that element // select a random pivot_index Random random_num = new Random(); int pivot_index = left + random_num.nextInt(right - left); pivot_index = partition(left, right, pivot_index); // the pivot is on (N - k)th smallest position if (k_smallest == pivot_index) return this.nums[k_smallest]; // go left side else if (k_smallest &lt; pivot_index) return quickselect(left, pivot_index - 1, k_smallest); // go right side return quickselect(pivot_index + 1, right, k_smallest); &#125; public int findKthLargest(int[] nums, int k) &#123; this.nums = nums; int size = nums.length; // kth largest is (N - k)th smallest return quickselect(0, size - 1, size - k); &#125;&#125; 9. 实现 Trie (前缀树)实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Code12345678Trie trie &#x3D; new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); &#x2F;&#x2F; 返回 truetrie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 falsetrie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 题解： java1234567891011121314151617181920212223242526272829303132333435363738394041class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char currentChar = word.charAt(i); if (!node.containsKey(currentChar)) &#123; node.put(currentChar, new TrieNode()); &#125; node = node.get(currentChar); &#125; node.setEnd(); &#125; // search a prefix or whole key in trie and // returns the node where search ends private TrieNode searchPrefix(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char curLetter = word.charAt(i); if (node.containsKey(curLetter)) &#123; node = node.get(curLetter); &#125; else &#123; return null; &#125; &#125; return node; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); &#125;&#125; 10. 编辑距离链接：https://leetcode-cn.com/problems/edit-distance/ 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 1. 插入一个字符 2. 删除一个字符 3. 替换一个字符 示例 1: Code123456输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;) 示例 2: Code12345678输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;) 题解： java1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int minDistance(String word1, String word2) &#123; int n = word1.length(); int m = word2.length(); // if one of the strings is empty if (n * m == 0) return n + m; // array to store the convertion history int [][] d = new int[n + 1][m + 1]; // init boundaries for (int i = 0; i &lt; n + 1; i++) &#123; d[i][0] = i; &#125; for (int j = 0; j &lt; m + 1; j++) &#123; d[0][j] = j; &#125; // DP compute for (int i = 1; i &lt; n + 1; i++) &#123; for (int j = 1; j &lt; m + 1; j++) &#123; int left = d[i - 1][j] + 1; int down = d[i][j - 1] + 1; int left_down = d[i - 1][j - 1]; if (word1.charAt(i - 1) != word2.charAt(j - 1)) left_down += 1; d[i][j] = Math.min(left, Math.min(down, left_down)); &#125; &#125; return d[n][m]; &#125;&#125;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"https://masteryang4.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://masteryang4.github.io/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"HashMap底层实现源码分析","slug":"HashMap底层实现源码分析","date":"2020-03-16T15:21:13.000Z","updated":"2020-05-09T13:27:22.937Z","comments":true,"path":"2020/03/16/HashMap底层实现源码分析/","link":"","permalink":"https://masteryang4.github.io/2020/03/16/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"HashMap底层实现原理0.样例数据java123456789101112131415161718192021222324252627282930313233343536373839import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class CollectionTest &#123; public static void main(String[] args) &#123; //唯一的工作初始化负债因子（this.loadFactor = DEFAULT_LOAD_FACTOR）为0.75f Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); int count = 1; //添加kv for (char i = 65; i &lt; 91; i++) &#123; map.put(String.valueOf(i),count); count++; &#125; //第一种遍历方式 Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; iterator = keySet.iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); System.out.println(key+ \" =&gt; \" + map.get(key)); &#125; System.out.println(\"******************************\"); //第二种遍历方式 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iteratorMap = map.entrySet().iterator(); while (iteratorMap.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; mapEntry = iteratorMap.next(); System.out.println(mapEntry); &#125; System.out.println(\"******************************\"); //第三种遍历方式 for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + \" =&gt; \" + entry.getValue()); &#125; &#125;&#125; 1. 类信息java1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 2. 基本属性java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125private static final long serialVersionUID = 362498820763181265L; //序列化版本号static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认容量16(左移4位相当于乘以2的4次方)static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//最大容量（1073741824）static final float DEFAULT_LOAD_FACTOR = 0.75f;//默认负载因子static final int TREEIFY_THRESHOLD = 8; //链表节点转换红黑树节点的阈值static final int UNTREEIFY_THRESHOLD = 6; //红黑树节点转换链表节点的阈值static final int MIN_TREEIFY_CAPACITY = 64;// 转红黑树时, table的最小长度// 基本hash节点, 继承自Entry，此时的Node节点就是相当于Entry节点的实现static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125;transient Node&lt;K,V&gt;[] table; //hashMap数组的表示transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //entry节点transient int size; //数组长度transient int modCount; //添加的元素个数int threshold; //合理的初始化数组长度，根据tableSizeFor()得到，用于手动设置时使用final float loadFactor; //负载因子，用于手动设置时使用//构造器一：定义Node[]数组初始长度public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); //为Node[]数组设置负债因子 this.loadFactor = loadFactor; //为Node[]数组设置一个合理的值 this.threshold = tableSizeFor(initialCapacity);&#125;//初始化Node[]数组长度，根据传入的值以2的n次方对数组进行扩容//（例如：存入传入值为9，数组容量为16，在(8,16]范围内将不会再次扩容）。static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= 1 &lt;&lt; 30) ? 1 &lt;&lt; 30 : n + 1;&#125;//构造器二：调用HashMap(int initialCapacity, float loadFactor)构造器public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//构造器三：仅创建HashMap对象，并初始化负债因子为0.75fpublic HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR;&#125;// 红黑树节点static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; //...&#125; 3. hash算法HashMap定位数组索引位置，直接决定了hash方法的离散性能。下面是定位哈希桶数组的源码： java123456789101112131415161718192021222324252627// 计算key的hash值static final int hash(Object key) &#123; int h; // 1.先拿到key的hashCode值,基本数据类型会使用其包装类重载的hashCode()方法去计算hash值，引用数据类型根据是否重写去计算 // 2.将hashCode的高16位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; // 将(tab.length - 1) 与 hash值进行&amp;运算 int index = (tab.length - 1) &amp; hash;&#125;//对值进行Hash计算public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = valu /** * 当KEY值为A测试数据，A的hash为: 31 * hash + ANSI码值65 * 当KEY值为AB测试数据，AB的hash为：31 * 65 + 66 */ for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; HashMap底层数组的长度总是2的n次方，并且取模运算为“h mod table.length”，对应上面的公式，可以得到该运算等同于“h &amp; (table.length - 1)”。这是HashMap在速度上的优化，因为&amp;比%具有更高的效率。 在JDK1.8的实现中，还优化了高位运算的算法，将hashCode的高16位与hashCode进行异或运算，主要是为了在table的length较小的时候，让高位也参与运算，并且不会有太大的开销。 4. get方法java1234567891011121314151617181920212223242526272829303132//调用的GET方法public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//实际执行的GET方法final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // table不为空 &amp;&amp; table长度大于0 &amp;&amp; table索引位置(根据hash值计算出)节点不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // first的key等于传入的key则返回first对象 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //first的key不等于传入的key则说明是链表，向下遍历 if ((e = first.next) != null) &#123; // 判断是否为TreeNode，是则为红黑树 // 如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //走下列步骤表示是链表，循环至节点的key与传入的key值相等 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; //找不到符合的返回空 return null;&#125; 5. put方法java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//掉用的PUT方法，hash(key)调用本例中的hash()方法public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; //实际执行的PUT方法 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table是否为空或者length等于0, 如果是则调用resize方法进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 通过hash值计算索引位置, 如果table表该索引位置节点为空则新增一个 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 将索引位置的头节点赋值给p tab[i] = newNode(hash, key, value, null); else &#123; // table表该索引位置不为空 Node&lt;K,V&gt; e; K k; //判断p节点的hash值和key值是否跟传入的hash值和key值相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果相等, 则p节点即为要查找的目标节点，赋值给e // 判断p节点是否为TreeNode, 如果是则调用红黑树的putTreeVal方法查找目标节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 走到这代表p节点为普通链表节点 else &#123; // 遍历此链表, binCount用于统计节点数 for (int binCount = 0; ; ++binCount) &#123; //p.next为空代表目标节点不存在 if ((e = p.next) == null) &#123; //新增一个节点插入链表尾部 p.next = newNode(hash, key, value, null); //如果节点数目超过8个，调用treeifyBin方法将该链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //e节点的hash值和key值都与传入的相等, 则e即为目标节点,跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e不为空则代表根据传入的hash值和key值查找到了节点,将该节点的value覆盖,返回oldValue if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 用于LinkedHashMap return oldValue; &#125; &#125; //map修改次数加1 ++modCount; //map节点数加1，如果超过阀值，则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); // 用于LinkedHashMap return null;&#125; 从上面的源码分析可以看出 1、如果节点已经存在，则更新原值 2、如果节点不存在，则插入数组中，如果数组已经有值，则判断是非是红黑树，如果是，则调用红黑树方法插入 3、如果插入的是链表，插入尾部，然后判断节点数是否超过8，如果超过，则转换为红黑树 4、先插入的数据，后面判断是否超过阀值再进行的扩容 putTreeVal,插入红黑树方法就不看了，看下treeifyBin方法，该方法是将链表转化为红黑树, java123456789101112131415161718192021222324final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; // table为空或者table的长度小于64, 进行扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); // 根据hash值计算索引值, 遍历该索引位置的链表 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); // 链表节点转红黑树节点 if (tl == null) // tl为空代表为第一次循环 hd = p; // 头结点 else &#123; p.prev = tl; // 当前节点的prev属性设为上一个节点 tl.next = p; // 上一个节点的next属性设置为当前节点 &#125; tl = p; // tl赋值为p, 在下一次循环中作为上一个节点 &#125; while ((e = e.next) != null); // e指向下一个节点 // 将table该索引位置赋值为新转的TreeNode的头节点 if ((tab[index] = hd) != null) hd.treeify(tab); // 以头结点为根结点, 构建红黑树 &#125;&#125; 可以看到，会先判断tab的节点数是否超过64，如果没超过，则进行扩容，如果超过了才会转换为红黑树 可以得到两个结论 1、什么时候转换为红黑树 当链表数目超过8,并且map节点数量超过64，才会转换为红黑树 2、什么时候扩容（前提是map数目没有超过最大容量值 1&lt;&lt;30 ） 新增节点时，发生了碰撞，并且节点数目超过阀值 新增节点时，发生了碰撞，节点数量木有超过阀值，但是链表数目&gt;8,map节点&lt;64时 再看下resize()方法 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788final Node&lt;K,V&gt;[] resize() &#123; //oldTab保存未扩容的tab Node&lt;K,V&gt;[] oldTab = table; //oldTab最大容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; //oldTab阀值 int oldThr = threshold; int newCap, newThr = 0; //如果老map有值 if (oldCap &gt; 0) &#123; // 老table的容量超过最大容量值，设置阈值为Integer.MAX_VALUE，返回老表 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; //老table的容量没有超过最大容量值，将新容量赋值为老容量*2，如果新容量&lt;最大容量并且老容量&gt;=16, 则将新阈值设置为原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // 老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值 newCap = oldThr; // 则将新表的容量设置为老表的阈值 else &#123; //老表的容量为0, 老表的阈值为0, 则为空表，设置默认容量和阈值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 如果新阈值为空, 则通过新的容量*负载因子获得新阈值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 将当前阈值赋值为刚计算出来的新的阈值 threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 将当前的表赋值为新定义的表 // 如果老表不为空, 则需遍历将节点赋值给新表 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; // 将索引值为j的老表头节点赋值给e oldTab[j] = null; //将老表的节点设置为空, 以便垃圾收集器回收空间 // 如果e.next为空, 则代表老表的该位置只有1个节点, // 通过hash值计算新表的索引位置, 直接将该节点放在该位置 if (e.next == null) // newTab[e.hash &amp; (newCap - 1)] = e; //e.next不为空,判断是否是红黑树 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //是普通链表 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为: // 老表的索引位置＋oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; // 最后一个节点的next设为空 newTab[j] = loHead; // 将原索引位置的节点设置为对应的头结点 &#125; if (hiTail != null) &#123; hiTail.next = null; // 最后一个节点的next设为空 newTab[j + oldCap] = hiHead; // 将索引位置为原索引+oldCap的节点设置为对应的头结点 &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 可以看出，扩容时，节点重hash只分布在原索引位置与原索引+oldCap位置，为什么呢 假设老表的容量为16，即oldCap=16，则新表容量为16*2=32，假设节点1的hash值为0000 0000 0000 0000 0000 1111 0000 1010，节点2的hash值为0000 0000 0000 0000 0000 1111 0001 1010，则节点1和节点2在老表的索引位置计算如下图计算1，由于老表的长度限制，节点1和节点2的索引位置只取决于节点hash值的最后4位。再看计算2，计算2为新表的索引计算，可以知道如果两个节点在老表的索引位置相同，则新表的索引位置只取决于节点hash值倒数第5位的值，而此位置的值刚好为老表的容量值16，此时节点在新表的索引位置只有两种情况：原索引位置和原索引+oldCap位置（在此例中即为10和10+16=26）。由于结果只取决于节点hash值的倒数第5位，而此位置的值刚好为老表的容量值16，因此此时新表的索引位置的计算可以替换为计算3，直接使用节点的hash值与老表的容量16进行位于运算，如果结果为0则该节点在新表的索引位置为原索引位置，否则该节点在新表的索引位置为原索引+oldCap位置。 6. remove()方法java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 如果table不为空并且根据hash值计算出来的索引位置不为空, 将该位置的节点赋值给p if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // 如果p的hash值和key都与入参的相同, 则p即为目标节点, 赋值给node if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; // 否则向下遍历节点 if (p instanceof TreeNode) // 如果p是TreeNode则调用红黑树的方法查找节点 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; // 遍历链表查找符合条件的节点 // 当节点的hash值和key与传入的相同,则该节点即为目标节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; // 赋值给node, 并跳出循环 break; &#125; p = e; // p节点赋值为本次结束的e &#125; while ((e = e.next) != null); // 指向像一个节点 &#125; &#125; // 如果node不为空(即根据传入key和hash值查找到目标节点)，则进行移除操作 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) // 如果是TreeNode则调用红黑树的移除方法 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 走到这代表节点是普通链表节点 // 如果node是该索引位置的头结点则直接将该索引位置的值赋值为node的next节点 else if (node == p) tab[index] = node.next; // 否则将node的上一个节点的next属性设置为node的next节点, // 即将node节点移除, 将node的上下节点进行关联(链表的移除) else p.next = node.next; ++modCount; // 修改次数+1 --size; // table的总节点数-1 afterNodeRemoval(node); // 供LinkedHashMap使用 return node; // 返回被移除的节点 &#125; &#125; return null;&#125; 7. JDK1.7和1.8的区别1、JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率） 2、JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。 3、扩容后数据存储位置的计算方式也不一样：1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1），而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。 4、jdk1.7 先扩容再put ，jdk1.8 先put再扩容","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"https://masteryang4.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://masteryang4.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"},{"name":"hashmap","slug":"hashmap","permalink":"https://masteryang4.github.io/tags/hashmap/"}]},{"title":"Comparable和Comparator底层源码分析","slug":"Comparable和Comparator底层源码分析","date":"2020-03-15T15:52:58.000Z","updated":"2020-04-18T15:17:34.133Z","comments":true,"path":"2020/03/15/Comparable和Comparator底层源码分析/","link":"","permalink":"https://masteryang4.github.io/2020/03/15/Comparable%E5%92%8CComparator%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"1. Comparable源码分析1.1创建Java工程，实现Comparable接口java123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.Serializable;//实现Serializable，标识该类可被序列化//实现Comparable接口，让此类可以利用Collections.sort()进行排序public class User&lt;T extends User&gt; implements Serializable,Comparable&lt;T&gt;&#123; private String name; private int age; private transient String address;//transient修饰，标识该类序列化时此字段不需要进行存储 public User(String name)&#123; this.name = name; &#125; public User(String name,int age,String address)&#123; this(name); this.age = age; this.address = address; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getAddress() &#123; return address; &#125; @Override public int compareTo(T o) &#123; //在此处打上断点，方便进行调试 int returnInt = 0; if(age&gt;o.getAge())&#123; returnInt=1; &#125;else if(age==o.getAge())&#123; returnInt=0; &#125;else if(age&lt;o.getAge())&#123; returnInt=-1; &#125; return returnInt; &#125;&#125; 1.2 编写测试类java123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Collections;import java.util.List;public class TestComparable &#123; public static void main(String[] args) &#123; User u1 = new User(\"caililiang1\",20,\"hubei1\"); User u2 = new User(\"caililiang2\",30,\"hubei2\"); User u3 = new User(\"caililiang3\",25,\"hubei3\"); User u4 = new User(\"caililiang4\",28,\"hubei4\"); User u5 = new User(\"caililiang5\",23,\"hubei5\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); list.add(u5); for(int i=0;i&lt;list.size();i++)&#123; User u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; System.out.println(\"排序后---------------------\"); //在此处打上断点，方便进行调试 Collections.sort(list); for(int i=0;i&lt;list.size();i++)&#123; User u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; &#125;&#125; 1.3 Collections类中的泛型方法sort()java1234567// 此处 &lt;T extends Comparable&lt;? super T&gt;&gt; 的意思是：// 1.&lt;T extends Comparable&gt;表示比较对象的类必须是Comparable 的子类。// 2.Comparable&lt;? super T&gt;表示是Comparable实现类及以上。public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123; //调用List接口中的sort()方法 list.sort(null); &#125; 1.4 List接口中的默认方法sort()java1234567891011// 由于本例中采用的是ArrayList集合，ArrayList集合对List接口中的sort()方法进行了重写，// 因此实际在DeBug的过程中会执行ArrayLIst类中的sort()方法 default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125; &#125; 1.5 ArrayList集合中的方法sort()java1234567891011@Override@SuppressWarnings(\"unchecked\")public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; //此方法直接调用Arrays类中sort()方法 Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 1.6 Arrays类中的sort()方法java12345678910111213141516171819202122public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c) &#123; //在1.3中传入的 c值为null,所以调用sort(a, fromIndex, toIndex)方法 if (c == null) &#123; sort(a, fromIndex, toIndex); &#125; else &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); &#125;&#125;public static void sort(Object[] a, int fromIndex, int toIndex) &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) //归并排序 legacyMergeSort(a, fromIndex, toIndex); else //二进制插入排序 ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);&#125; 解析：源码里首先判断是否采用传统的排序方法,LegacyMergeSort.userRequested属性默认为false,也就是说默认选中 ComparableTimSort.sort(a)方法(传统归并排序在1.5及之前是默认排序方法，1.5之后默认执行ComparableTimSort.sort()方法。除非程序中强制要求使用传统归并排序,语句如下：System.setProperty(“java.util.Arrays.useLegacyMergeSort”, “true”))继续看 ComparableTimSort.sort(a)源码 1.7 ComparableTimSort类中的sort()方法java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123; assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; //nRemaining表示没有排序的对象个数，方法执行前，如果这个数小于2，就不需要排序了。 //如果2&lt;= nRemaining &lt;=32,即MIN_MERGE的初始值，表示需要排序的数组是小数组 //可以使用mini-TimSort方法进行排序，否则需要使用归并排序。 int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a \"mini-TimSort\" with no merges if (nRemaining &lt; MIN_MERGE) &#123; //调用重写的compareTo()方法 int initRunLen = countRunAndMakeAscending(a, lo, hi); //只看这一句 binarySort(a, lo, hi, lo + initRunLen); return; &#125; ...... &#125;//这里才是真正的调用compareTo()方法对当前对象进行比较 private static int countRunAndMakeAscending(Object[] a, int lo, int hi) &#123; assert lo &lt; hi; int runHi = lo + 1; if (runHi == hi) return 1; // Find end of run, and reverse range if descending if (((Comparable) a[runHi++]).compareTo(a[lo]) &lt; 0) &#123; // 降序排列 while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &lt; 0) runHi++; reverseRange(a, lo, runHi); &#125; else &#123;// 升序排列 while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &gt;= 0) runHi++; &#125; return runHi - lo; &#125;//这里才是真正的进行排序。 private static void binarySort(Object[] a, int lo, int hi, int start) &#123; assert lo &lt;= start &amp;&amp; start &lt;= hi; if (start == lo) start++; for ( ; start &lt; hi; start++) &#123; Comparable pivot = (Comparable) a[start]; // Set left (and right) to the index where a[start] (pivot) belongs int left = lo; int right = start; assert left &lt;= right; /* * Invariants: * pivot &gt;= all in [lo, left). * pivot &lt; all in [right, start). */ while (left &lt; right) &#123; int mid = (left + right) &gt;&gt;&gt; 1; if (pivot.compareTo(a[mid]) &lt; 0) right = mid; else left = mid + 1; &#125; assert left == right; /* * The invariants still hold: pivot &gt;= all in [lo, left) and * pivot &lt; all in [left, start), so pivot belongs at left. Note * that if there are elements equal to pivot, left points to the * first slot after them -- that's why this sort is stable. * Slide elements over to make room for pivot. */ int n = start - left; // The number of elements to move // Switch is just an optimization for arraycopy in default case switch (n) &#123; case 2: a[left + 2] = a[left + 1]; case 1: a[left + 1] = a[left]; break; default: System.arraycopy(a, left, a, left + 1, n); &#125; a[left] = pivot; &#125; &#125; 2. Comparator源码分析2.1 创建JavaBeanjava123456789101112131415161718192021222324252627282930import java.io.Serializable;public class People implements Serializable &#123; private String name; private int age; private transient String address;//transient修饰，标识该类序列化时此字段不需要进行存储 public People(String name)&#123; this.name = name; &#125; public People(String name,int age,String address)&#123; this(name); this.age = age; this.address = address; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getAddress() &#123; return address; &#125;&#125; 2.2 创建外部比较器java123456789101112131415import java.util.Comparator;public class PeopleComparator&lt;T extends People&gt; implements Comparator&lt;T&gt; &#123; public int compare(T o1, T o2) &#123; int returnInt = 0; if(o1.getAge()&gt;o2.getAge())&#123; returnInt = 1; &#125;else if(o1.getAge()==o2.getAge())&#123; returnInt = 0; &#125;else if(o1.getAge()&lt;o2.getAge())&#123; returnInt = -1; &#125; return returnInt; &#125;&#125; 2.3 创建测试类java12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;import java.util.List;public class TestComparator &#123; public static void main(String[] args) &#123; People u1 = new People(\"caililiang1\",20,\"hubei1\"); People u2 = new People(\"caililiang2\",30,\"hubei2\"); People u3 = new People(\"caililiang3\",25,\"hubei3\"); People u4 = new People(\"caililiang4\",28,\"hubei4\"); People u5 = new People(\"caililiang5\",23,\"hubei5\"); List&lt;People&gt; list = new ArrayList&lt;People&gt;(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); list.add(u5); for(int i=0;i&lt;list.size();i++)&#123; People u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; System.out.println(\"排序后---------------------\"); Collections.sort(list,new PeopleComparator()); for(int i=0;i&lt;list.size();i++)&#123; People u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; &#125;&#125; 2.4 Collections类中的泛型方法sort()java12345 @SuppressWarnings(&#123;\"unchecked\", \"rawtypes\"&#125;)//此处调用的是sort方法的重载方法，与案例一中不同 public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c); &#125; 2.5 ArrayList集合中的方法sort()java12345678910@Override@SuppressWarnings(\"unchecked\")public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 2.6 Arrays类中的sort()方法java123456789101112public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a, fromIndex, toIndex); &#125; else &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else //本次进入这里进行排序 TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); &#125;&#125; 2.7 TimSort类下的sort()方法java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static &lt;T&gt; void sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen) &#123; assert c != null &amp;&amp; a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a \"mini-TimSort\" with no merges if (nRemaining &lt; MIN_MERGE) &#123; int initRunLen = countRunAndMakeAscending(a, lo, hi, c); binarySort(a, lo, hi, lo + initRunLen, c); return; &#125; private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start, Comparator&lt;? super T&gt; c) &#123; assert lo &lt;= start &amp;&amp; start &lt;= hi; if (start == lo) start++; for ( ; start &lt; hi; start++) &#123; T pivot = a[start]; // Set left (and right) to the index where a[start] (pivot) belongs int left = lo; int right = start; assert left &lt;= right; /* * Invariants: * pivot &gt;= all in [lo, left). * pivot &lt; all in [right, start). */ while (left &lt; right) &#123; int mid = (left + right) &gt;&gt;&gt; 1; if (c.compare(pivot, a[mid]) &lt; 0) right = mid; else left = mid + 1; &#125; assert left == right; /* * The invariants still hold: pivot &gt;= all in [lo, left) and * pivot &lt; all in [left, start), so pivot belongs at left. Note * that if there are elements equal to pivot, left points to the * first slot after them -- that's why this sort is stable. * Slide elements over to make room for pivot. */ int n = start - left; // The number of elements to move // Switch is just an optimization for arraycopy in default case switch (n) &#123; case 2: a[left + 2] = a[left + 1]; case 1: a[left + 1] = a[left]; break; default: System.arraycopy(a, left, a, left + 1, n); &#125; a[left] = pivot; &#125;&#125; 3. 总结 Comparable 此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo()方法被称为它的自然比较方法。 实现此接口的对象列表（集合和数组）可以通过 Collections.sort和 Arrays.sort 进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Arrays.sort(people) Comparator 是比较器，排序时，需要新建比较器对象，将比较器和对象一起传递过去就可以比大小，可称为“外部排序”。比较器是定义在要比较对象的外部的, 必须要重写compare()方法，而需要比较的类的结构不需要有任何变化。并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。 Arrays.sort(people,new PersonCompartor()); 关于两个类的具体应用场景可以理解为，自己在创建一个工程时可以使用Comparable进行排序，当工程创建完毕时添加新的排序功能时，可以使用Comparator，无需改变类的结构。","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"基础知识","slug":"Java/基础知识","permalink":"https://masteryang4.github.io/categories/Java/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://masteryang4.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"}]},{"title":"Hexo博客安装及部署","slug":"Hexo博客安装及部署","date":"2020-03-12T06:40:31.000Z","updated":"2020-04-18T15:53:17.599Z","comments":true,"path":"2020/03/12/Hexo博客安装及部署/","link":"","permalink":"https://masteryang4.github.io/2020/03/12/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E5%8F%8A%E9%83%A8%E7%BD%B2/","excerpt":"安装nodejs node -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本 hexo安装及配置 hexo -v #查看hexo版本mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n “我的第一篇文章” #创建新的文章 在blog目录下","text":"安装nodejs node -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本 hexo安装及配置 hexo -v #查看hexo版本mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n “我的第一篇文章” #创建新的文章 在blog目录下 hexo clean #清理hexo g #生成#Github创建一个新的仓库 YourGithubName.github.iocnpm install –save hexo-deployer-git #在blog目录下安装git部署插件 配置_config.yml yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/YourGithubName/YourGithubName.github.io.gitbranch: master 部署到Github仓库里 hexo d https://YourGithubName.github.io/ #访问这个地址可以查看博客 yilia主题配置 下载yilia主题到本地 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml 文件 yml1theme: yilia 部署到github hexo clean #清理一下 hexo g #生成 hexo d #部署到远程Github仓库 查看博客 ： https://YourGithubName.github.io/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://masteryang4.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://masteryang4.github.io/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://masteryang4.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"ArrayList底层实现源码分析(JDK1.8)","slug":"ArrayList底层实现源码分析_JDK1.8","date":"2020-03-12T03:30:45.000Z","updated":"2020-04-18T15:16:40.883Z","comments":true,"path":"2020/03/12/ArrayList底层实现源码分析_JDK1.8/","link":"","permalink":"https://masteryang4.github.io/2020/03/12/ArrayList%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_JDK1.8/","excerpt":"1. 类信息1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; 2. 基本属性","text":"1. 类信息java1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; 2. 基本属性 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//定义序列化ID，主要是为了表示不同的版本的兼容性private static final long serialVersionUID = 8683452581122892189L;//默认的数组存储容量(ArrayList底层是数组结构)private static final int DEFAULT_CAPACITY = 10;//当指定数组的容量为0时使用这个常量赋值private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认空参构造函数时使用这个常量赋值private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//真正存放数据的对象数组，transient标识不被序列化transient Object[] elementData;//数组中的真实元素个数，该值小于或等于elementData.lengthprivate int size;//最大数组长度：0x7fffffff - 8private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//构造器一：创建具有初始化长度的listpublic ArrayList(int initialCapacity) &#123; //对传入的值进行合法检测 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;//构造器二：默认空参构造器public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//构造器三：创建具有初始化值的集合，可传入的集合类型父类是Collection即可，此处是多态的一个应用public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将传入的集合转化为数组 elementData = c.toArray(); //判断elementData数组长度 if ((size = elementData.length) != 0) &#123; // elementData转化的数组如果不是Object的子类，就对当前数组进行复制，重新赋值给elementData if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123;//如果数组长度为0，复制为EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 3. add(E e) 方法ArrayList集合创建时，默认初始化长度为0，通过add( )方法在添加元素时对数组长度进行动态赋值。添加第一个元素时，长度为10。当添加的元素个数超过10时，会进行首次扩容，容量为原数组长度的1.5倍。 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //此方法是添加元素的方法，另外还有一个重载方法 public boolean add(E e) &#123; //调用ensureCapacityInternal方法，初始化数组长度（默认为10） ensureCapacityInternal(size + 1); //为数组复制 elementData[size++] = e; return true; &#125;//初始化数组长度，默认值为10 private void ensureCapacityInternal(int minCapacity) &#123; //判断如果数组长度为0，对长度进行初始化 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //从默认数组长度（10）和添加的元素个数（添加第一个元素时size=0,minCapacity=size+1）中取出最大值 //作为数组初始化长度 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //再次确定数组容量 ensureExplicitCapacity(minCapacity); &#125; //再次确定数组容量 private void ensureExplicitCapacity(int minCapacity) &#123; //对数组元素个数进行统计 modCount++; //如果数组长度超过10，就对数组长度进行扩容 //那第一次扩容举例：minCapacity值为11，DEFAULT_CAPACITY值为10 if (minCapacity - elementData.length &gt; 0) //对数组进行扩容，默认为老数组的1.5倍 grow(minCapacity); &#125; //对数组进行扩容，默认为老数组的1.5倍 private void grow(int minCapacity) &#123; //老数组容量：minCapacity int oldCapacity = elementData.length; //新数组容量：是老数组长度的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //对新数组容量进行合法检测 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //MAX_ARRAY_SIZE：0x7fffffff - 8 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //如果超过最大数组长度，再次进行扩容 newCapacity = hugeCapacity(minCapacity); //对原数组进行复制 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //三元运算符，如果超过最大数组长度返回Integer最大值：0x7fffffff return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 4. add (int idnex,E element)从源码中可以看出，与add(E e)方法大致一致，主要的差异是增加了一行代码：System.arraycopy(elementData, index, elementData, index + 1, size - index)，从index位置开始以及之后的数据，整体拷贝到index+1开始的位置，然后再把新加入的数据放在index这个位置，而之前的数据不需要移动。 java123456789101112131415161718//在指定位置添加元素public void add(int index, E element) &#123; //判断index是否在范围内 rangeCheckForAdd(index); //与add(E e)方法一致，对数组长度进行初始化 ensureCapacityInternal(size + 1); //对原数组从index位置进行拷贝，复制到index+1的位置，elementData[index]此时为空 //System.arraycopy是一个native方法，意味着这个方法是C/C++语言实现的，我们无法再以普通的方式去查看这些方法了 System.arraycopy(elementData, index, elementData, index + 1, size - index); //为该下标赋值 elementData[index] = element; size++;&#125;//判断index是否在范围内的具体实现private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; arraycopy(elementData, index, elementData, index + 1, size - index)函数中各个参数对应的意义：（原数组，原数组的开始位置，目标数组，目标数组的开始位置，拷贝的个数） 5. remove(int index)java12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //移除指定index下的元素 public E remove(int index) &#123; //index是否合法检测 rangeCheck(index); modCount++; //指定index下的元素 E oldValue = elementData(index); //移除后数组长度 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //为最后一个元素赋值为null elementData[--size] = null; return oldValue; &#125; //返回指定index下的元素E elementData(int index) &#123; return (E) elementData[index]; &#125; //根据元素（对象）移除该元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; //类似于remove()方法 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; &#125; remove方法与add正好是一个相反的操作，移除一个元素，会影响到一批数字的位置移动，所以也是比较耗性能。核心代码都是调用了java.lang.System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)方法 6. get(int index)java123456//根据指定下标获取元素值public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 7. set(int index, E element)java12345678//修改指定index下的元素值public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 8. clear()java12345678910//清空所有元素public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 9. contains(Object o)java1234567891011121314151617//查询是否包含某个元素public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;//具体的实现方法，如果不包含返回-1public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 10. 总结 基于数组实现的List在随机访问和遍历的效率比较高，但是往指定位置加入元素或者删除指定位置的元素效率比较低。","categories":[{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/categories/Java/"},{"name":"集合","slug":"Java/集合","permalink":"https://masteryang4.github.io/categories/Java/%E9%9B%86%E5%90%88/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://masteryang4.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"易错点","slug":"易错点","permalink":"https://masteryang4.github.io/tags/%E6%98%93%E9%94%99%E7%82%B9/"},{"name":"Java","slug":"Java","permalink":"https://masteryang4.github.io/tags/Java/"}]}]}