{"meta":{"title":"MasterYangBlog","subtitle":"","description":"","author":"Yang4","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Comparable和Comparator底层源码分析","slug":"Comparable和Comparator底层源码分析","date":"2020-03-15T15:52:58.000Z","updated":"2020-03-15T15:57:09.181Z","comments":true,"path":"2020/03/15/Comparable和Comparator底层源码分析/","link":"","permalink":"http://yoursite.com/2020/03/15/Comparable%E5%92%8CComparator%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"1. Comparable源码分析1.1创建Java工程，实现Comparable接口java123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.Serializable;//实现Serializable，标识该类可被序列化//实现Comparable接口，让此类可以利用Collections.sort()进行排序public class User&lt;T extends User&gt; implements Serializable,Comparable&lt;T&gt;&#123; private String name; private int age; private transient String address;//transient修饰，标识该类序列化时此字段不需要进行存储 public User(String name)&#123; this.name = name; &#125; public User(String name,int age,String address)&#123; this(name); this.age = age; this.address = address; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getAddress() &#123; return address; &#125; @Override public int compareTo(T o) &#123; //在此处打上断点，方便进行调试 int returnInt = 0; if(age&gt;o.getAge())&#123; returnInt=1; &#125;else if(age==o.getAge())&#123; returnInt=0; &#125;else if(age&lt;o.getAge())&#123; returnInt=-1; &#125; return returnInt; &#125;&#125; 1.2 编写测试类java123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Collections;import java.util.List;public class TestComparable &#123; public static void main(String[] args) &#123; User u1 = new User(\"caililiang1\",20,\"hubei1\"); User u2 = new User(\"caililiang2\",30,\"hubei2\"); User u3 = new User(\"caililiang3\",25,\"hubei3\"); User u4 = new User(\"caililiang4\",28,\"hubei4\"); User u5 = new User(\"caililiang5\",23,\"hubei5\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); list.add(u5); for(int i=0;i&lt;list.size();i++)&#123; User u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; System.out.println(\"排序后---------------------\"); //在此处打上断点，方便进行调试 Collections.sort(list); for(int i=0;i&lt;list.size();i++)&#123; User u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; &#125;&#125; 1.3 Collections类中的泛型方法sort()java1234567// 此处 &lt;T extends Comparable&lt;? super T&gt;&gt; 的意思是：// 1.&lt;T extends Comparable&gt;表示比较对象的类必须是Comparable 的子类。// 2.Comparable&lt;? super T&gt;表示是Comparable实现类及以上。public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123; //调用List接口中的sort()方法 list.sort(null); &#125; 1.4 List接口中的默认方法sort()java1234567891011// 由于本例中采用的是ArrayList集合，ArrayList集合对List接口中的sort()方法进行了重写，// 因此实际在DeBug的过程中会执行ArrayLIst类中的sort()方法 default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125; &#125; 1.5 ArrayList集合中的方法sort()java1234567891011@Override@SuppressWarnings(\"unchecked\")public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; //此方法直接调用Arrays类中sort()方法 Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 1.6 Arrays类中的sort()方法java12345678910111213141516171819202122public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c) &#123; //在1.3中传入的 c值为null,所以调用sort(a, fromIndex, toIndex)方法 if (c == null) &#123; sort(a, fromIndex, toIndex); &#125; else &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); &#125;&#125;public static void sort(Object[] a, int fromIndex, int toIndex) &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) //归并排序 legacyMergeSort(a, fromIndex, toIndex); else //二进制插入排序 ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);&#125; 解析：源码里首先判断是否采用传统的排序方法,LegacyMergeSort.userRequested属性默认为false,也就是说默认选中 ComparableTimSort.sort(a)方法(传统归并排序在1.5及之前是默认排序方法，1.5之后默认执行ComparableTimSort.sort()方法。除非程序中强制要求使用传统归并排序,语句如下：System.setProperty(“java.util.Arrays.useLegacyMergeSort”, “true”))继续看 ComparableTimSort.sort(a)源码 1.7 ComparableTimSort类中的sort()方法java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123; assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; //nRemaining表示没有排序的对象个数，方法执行前，如果这个数小于2，就不需要排序了。 //如果2&lt;= nRemaining &lt;=32,即MIN_MERGE的初始值，表示需要排序的数组是小数组 //可以使用mini-TimSort方法进行排序，否则需要使用归并排序。 int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a \"mini-TimSort\" with no merges if (nRemaining &lt; MIN_MERGE) &#123; //调用重写的compareTo()方法 int initRunLen = countRunAndMakeAscending(a, lo, hi); //只看这一句 binarySort(a, lo, hi, lo + initRunLen); return; &#125; ...... &#125;//这里才是真正的调用compareTo()方法对当前对象进行比较 private static int countRunAndMakeAscending(Object[] a, int lo, int hi) &#123; assert lo &lt; hi; int runHi = lo + 1; if (runHi == hi) return 1; // Find end of run, and reverse range if descending if (((Comparable) a[runHi++]).compareTo(a[lo]) &lt; 0) &#123; // 降序排列 while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &lt; 0) runHi++; reverseRange(a, lo, runHi); &#125; else &#123;// 升序排列 while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &gt;= 0) runHi++; &#125; return runHi - lo; &#125;//这里才是真正的进行排序。 private static void binarySort(Object[] a, int lo, int hi, int start) &#123; assert lo &lt;= start &amp;&amp; start &lt;= hi; if (start == lo) start++; for ( ; start &lt; hi; start++) &#123; Comparable pivot = (Comparable) a[start]; // Set left (and right) to the index where a[start] (pivot) belongs int left = lo; int right = start; assert left &lt;= right; /* * Invariants: * pivot &gt;= all in [lo, left). * pivot &lt; all in [right, start). */ while (left &lt; right) &#123; int mid = (left + right) &gt;&gt;&gt; 1; if (pivot.compareTo(a[mid]) &lt; 0) right = mid; else left = mid + 1; &#125; assert left == right; /* * The invariants still hold: pivot &gt;= all in [lo, left) and * pivot &lt; all in [left, start), so pivot belongs at left. Note * that if there are elements equal to pivot, left points to the * first slot after them -- that's why this sort is stable. * Slide elements over to make room for pivot. */ int n = start - left; // The number of elements to move // Switch is just an optimization for arraycopy in default case switch (n) &#123; case 2: a[left + 2] = a[left + 1]; case 1: a[left + 1] = a[left]; break; default: System.arraycopy(a, left, a, left + 1, n); &#125; a[left] = pivot; &#125; &#125; 2. Comparator源码分析2.1 创建JavaBeanjava123456789101112131415161718192021222324252627282930import java.io.Serializable;public class People implements Serializable &#123; private String name; private int age; private transient String address;//transient修饰，标识该类序列化时此字段不需要进行存储 public People(String name)&#123; this.name = name; &#125; public People(String name,int age,String address)&#123; this(name); this.age = age; this.address = address; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getAddress() &#123; return address; &#125;&#125; 2.2 创建外部比较器java123456789101112131415import java.util.Comparator;public class PeopleComparator&lt;T extends People&gt; implements Comparator&lt;T&gt; &#123; public int compare(T o1, T o2) &#123; int returnInt = 0; if(o1.getAge()&gt;o2.getAge())&#123; returnInt = 1; &#125;else if(o1.getAge()==o2.getAge())&#123; returnInt = 0; &#125;else if(o1.getAge()&lt;o2.getAge())&#123; returnInt = -1; &#125; return returnInt; &#125;&#125; 2.3 创建测试类java12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;import java.util.List;public class TestComparator &#123; public static void main(String[] args) &#123; People u1 = new People(\"caililiang1\",20,\"hubei1\"); People u2 = new People(\"caililiang2\",30,\"hubei2\"); People u3 = new People(\"caililiang3\",25,\"hubei3\"); People u4 = new People(\"caililiang4\",28,\"hubei4\"); People u5 = new People(\"caililiang5\",23,\"hubei5\"); List&lt;People&gt; list = new ArrayList&lt;People&gt;(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); list.add(u5); for(int i=0;i&lt;list.size();i++)&#123; People u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; System.out.println(\"排序后---------------------\"); Collections.sort(list,new PeopleComparator()); for(int i=0;i&lt;list.size();i++)&#123; People u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; &#125;&#125; 2.4 Collections类中的泛型方法sort()java12345 @SuppressWarnings(&#123;\"unchecked\", \"rawtypes\"&#125;)//此处调用的是sort方法的重载方法，与案例一中不同 public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c); &#125; 2.5 ArrayList集合中的方法sort()java12345678910@Override@SuppressWarnings(\"unchecked\")public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 2.6 Arrays类中的sort()方法java123456789101112public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a, fromIndex, toIndex); &#125; else &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else //本次进入这里进行排序 TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); &#125;&#125; 2.7 TimSort类下的sort()方法java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static &lt;T&gt; void sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen) &#123; assert c != null &amp;&amp; a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a \"mini-TimSort\" with no merges if (nRemaining &lt; MIN_MERGE) &#123; int initRunLen = countRunAndMakeAscending(a, lo, hi, c); binarySort(a, lo, hi, lo + initRunLen, c); return; &#125; private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start, Comparator&lt;? super T&gt; c) &#123; assert lo &lt;= start &amp;&amp; start &lt;= hi; if (start == lo) start++; for ( ; start &lt; hi; start++) &#123; T pivot = a[start]; // Set left (and right) to the index where a[start] (pivot) belongs int left = lo; int right = start; assert left &lt;= right; /* * Invariants: * pivot &gt;= all in [lo, left). * pivot &lt; all in [right, start). */ while (left &lt; right) &#123; int mid = (left + right) &gt;&gt;&gt; 1; if (c.compare(pivot, a[mid]) &lt; 0) right = mid; else left = mid + 1; &#125; assert left == right; /* * The invariants still hold: pivot &gt;= all in [lo, left) and * pivot &lt; all in [left, start), so pivot belongs at left. Note * that if there are elements equal to pivot, left points to the * first slot after them -- that's why this sort is stable. * Slide elements over to make room for pivot. */ int n = start - left; // The number of elements to move // Switch is just an optimization for arraycopy in default case switch (n) &#123; case 2: a[left + 2] = a[left + 1]; case 1: a[left + 1] = a[left]; break; default: System.arraycopy(a, left, a, left + 1, n); &#125; a[left] = pivot; &#125;&#125; 3. 总结 Comparable 此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo()方法被称为它的自然比较方法。 实现此接口的对象列表（集合和数组）可以通过 Collections.sort和 Arrays.sort 进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Arrays.sort(people) Comparator 是比较器，排序时，需要新建比较器对象，将比较器和对象一起传递过去就可以比大小，可称为“外部排序”。比较器是定义在要比较对象的外部的, 必须要重写compare()方法，而需要比较的类的结构不需要有任何变化。并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。 Arrays.sort(people,new PersonCompartor()); 关于两个类的具体应用场景可以理解为，自己在创建一个工程时可以使用Comparable进行排序，当工程创建完毕时添加新的排序功能时，可以使用Comparator，无需改变类的结构。","categories":[],"tags":[]},{"title":"Hexo博客安装及部署","slug":"Hexo博客安装及部署","date":"2020-03-12T06:40:31.000Z","updated":"2020-03-12T06:54:39.177Z","comments":true,"path":"2020/03/12/Hexo博客安装及部署/","link":"","permalink":"http://yoursite.com/2020/03/12/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E5%8F%8A%E9%83%A8%E7%BD%B2/","excerpt":"安装nodejs node -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本 hexo安装及配置 hexo -v #查看hexo版本mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n “我的第一篇文章” #创建新的文章 在blog目录下","text":"安装nodejs node -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本 hexo安装及配置 hexo -v #查看hexo版本mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n “我的第一篇文章” #创建新的文章 在blog目录下 hexo clean #清理hexo g #生成#Github创建一个新的仓库 YourGithubName.github.iocnpm install –save hexo-deployer-git #在blog目录下安装git部署插件 配置_config.yml yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/YourGithubName/YourGithubName.github.io.gitbranch: master 部署到Github仓库里 hexo d https://YourGithubName.github.io/ #访问这个地址可以查看博客 yilia主题配置 下载yilia主题到本地 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml 文件 yml1theme: yilia 部署到github hexo clean #清理一下 hexo g #生成 hexo d #部署到远程Github仓库 查看博客 ： https://YourGithubName.github.io/","categories":[],"tags":[]},{"title":"ArrayList底层实现源码分析(JDK1.8)","slug":"ArrayList底层实现源码分析_JDK1.8","date":"2020-03-12T03:30:45.000Z","updated":"2020-03-12T06:17:54.055Z","comments":true,"path":"2020/03/12/ArrayList底层实现源码分析_JDK1.8/","link":"","permalink":"http://yoursite.com/2020/03/12/ArrayList%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_JDK1.8/","excerpt":"1. 类信息1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; 2. 基本属性","text":"1. 类信息java1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; 2. 基本属性 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//定义序列化ID，主要是为了表示不同的版本的兼容性private static final long serialVersionUID = 8683452581122892189L;//默认的数组存储容量(ArrayList底层是数组结构)private static final int DEFAULT_CAPACITY = 10;//当指定数组的容量为0时使用这个常量赋值private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认空参构造函数时使用这个常量赋值private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//真正存放数据的对象数组，transient标识不被序列化transient Object[] elementData;//数组中的真实元素个数，该值小于或等于elementData.lengthprivate int size;//最大数组长度：0x7fffffff - 8private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//构造器一：创建具有初始化长度的listpublic ArrayList(int initialCapacity) &#123; //对传入的值进行合法检测 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;//构造器二：默认空参构造器public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//构造器三：创建具有初始化值的集合，可传入的集合类型父类是Collection即可，此处是多态的一个应用public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将传入的集合转化为数组 elementData = c.toArray(); //判断elementData数组长度 if ((size = elementData.length) != 0) &#123; // elementData转化的数组如果不是Object的子类，就对当前数组进行复制，重新赋值给elementData if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123;//如果数组长度为0，复制为EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 3. add(E e) 方法ArrayList集合创建时，默认初始化长度为0，通过add( )方法在添加元素时对数组长度进行动态赋值。添加第一个元素时，长度为10。当添加的元素个数超过10时，会进行首次扩容，容量为原数组长度的1.5倍。 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //此方法是添加元素的方法，另外还有一个重载方法 public boolean add(E e) &#123; //调用ensureCapacityInternal方法，初始化数组长度（默认为10） ensureCapacityInternal(size + 1); //为数组复制 elementData[size++] = e; return true; &#125;//初始化数组长度，默认值为10 private void ensureCapacityInternal(int minCapacity) &#123; //判断如果数组长度为0，对长度进行初始化 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //从默认数组长度（10）和添加的元素个数（添加第一个元素时size=0,minCapacity=size+1）中取出最大值 //作为数组初始化长度 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //再次确定数组容量 ensureExplicitCapacity(minCapacity); &#125; //再次确定数组容量 private void ensureExplicitCapacity(int minCapacity) &#123; //对数组元素个数进行统计 modCount++; //如果数组长度超过10，就对数组长度进行扩容 //那第一次扩容举例：minCapacity值为11，DEFAULT_CAPACITY值为10 if (minCapacity - elementData.length &gt; 0) //对数组进行扩容，默认为老数组的1.5倍 grow(minCapacity); &#125; //对数组进行扩容，默认为老数组的1.5倍 private void grow(int minCapacity) &#123; //老数组容量：minCapacity int oldCapacity = elementData.length; //新数组容量：是老数组长度的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //对新数组容量进行合法检测 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //MAX_ARRAY_SIZE：0x7fffffff - 8 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //如果超过最大数组长度，再次进行扩容 newCapacity = hugeCapacity(minCapacity); //对原数组进行复制 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //三元运算符，如果超过最大数组长度返回Integer最大值：0x7fffffff return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 4. add (int idnex,E element)从源码中可以看出，与add(E e)方法大致一致，主要的差异是增加了一行代码：System.arraycopy(elementData, index, elementData, index + 1, size - index)，从index位置开始以及之后的数据，整体拷贝到index+1开始的位置，然后再把新加入的数据放在index这个位置，而之前的数据不需要移动。 java123456789101112131415161718//在指定位置添加元素public void add(int index, E element) &#123; //判断index是否在范围内 rangeCheckForAdd(index); //与add(E e)方法一致，对数组长度进行初始化 ensureCapacityInternal(size + 1); //对原数组从index位置进行拷贝，复制到index+1的位置，elementData[index]此时为空 //System.arraycopy是一个native方法，意味着这个方法是C/C++语言实现的，我们无法再以普通的方式去查看这些方法了 System.arraycopy(elementData, index, elementData, index + 1, size - index); //为该下标赋值 elementData[index] = element; size++;&#125;//判断index是否在范围内的具体实现private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; arraycopy(elementData, index, elementData, index + 1, size - index)函数中各个参数对应的意义：（原数组，原数组的开始位置，目标数组，目标数组的开始位置，拷贝的个数） 5. remove(int index)java12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //移除指定index下的元素 public E remove(int index) &#123; //index是否合法检测 rangeCheck(index); modCount++; //指定index下的元素 E oldValue = elementData(index); //移除后数组长度 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //为最后一个元素赋值为null elementData[--size] = null; return oldValue; &#125; //返回指定index下的元素E elementData(int index) &#123; return (E) elementData[index]; &#125; //根据元素（对象）移除该元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; //类似于remove()方法 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; &#125; remove方法与add正好是一个相反的操作，移除一个元素，会影响到一批数字的位置移动，所以也是比较耗性能。核心代码都是调用了java.lang.System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)方法 6. get(int index)java123456//根据指定下标获取元素值public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 7. set(int index, E element)java12345678//修改指定index下的元素值public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 8. clear()java12345678910//清空所有元素public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 9. contains(Object o)java1234567891011121314151617//查询是否包含某个元素public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;//具体的实现方法，如果不包含返回-1public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 10. 总结 基于数组实现的List在随机访问和遍历的效率比较高，但是往指定位置加入元素或者删除指定位置的元素效率比较低。","categories":[],"tags":[]}]}