{"meta":{"title":"MasterYangBlog","subtitle":"","description":"","author":"Yang4","url":"https://masteryang4.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-04-13T13:58:22.000Z","updated":"2020-04-13T13:58:22.286Z","comments":true,"path":"categories/index.html","permalink":"https://masteryang4.github.io/categories/index.html","excerpt":"","text":""},{"title":"link","date":"2020-04-13T13:58:35.000Z","updated":"2020-04-13T14:30:44.623Z","comments":true,"path":"link/index.html","permalink":"https://masteryang4.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-13T13:57:16.000Z","updated":"2020-04-13T13:57:16.229Z","comments":true,"path":"tags/index.html","permalink":"https://masteryang4.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试题：sleep和wait的区别","slug":"面试题：sleep和wait的区别","date":"2020-04-14T08:01:30.000Z","updated":"2020-04-14T08:02:48.128Z","comments":true,"path":"2020/04/14/面试题：sleep和wait的区别/","link":"","permalink":"https://masteryang4.github.io/2020/04/14/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Asleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Git使用小结","slug":"Git使用小结","date":"2020-04-12T16:25:50.000Z","updated":"2020-04-13T15:01:34.625Z","comments":true,"path":"2020/04/13/Git使用小结/","link":"","permalink":"https://masteryang4.github.io/2020/04/13/Git%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/","excerpt":"","text":"Git使用小结小结Git常用指令，以及如何将本地代码同步/更新到Github的常用指令 一、初始配置git安装完成后，需要设置一下，在命令行输入 Code12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; –global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 二、常用指令进入到自己的项目文件下右键选择Git Bash Here打开git客户端 初始化项目： Code1git init 将文件添加到本地仓库： Code1git add 将文件提交到仓库 Code1git commit -m &quot;注释内容&quot; 关联远程项目（你的远程仓库地址） Code1git remote add origin https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;xxx.git 本地推送到远程（ 第一次推送master分支的所有内容） 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 Code1git push -u origin master 查看Git状态 Code1git status 三、更新文件到GithubCode1234git addgit commit -m &quot;注释内容&quot;git pull origin master #从远程抓取分支，使用git pull，如果有冲突，要先处理冲突git push origin master 查看远程库信息： Code1git remote -v 会显示可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。","categories":[{"name":"Git","slug":"Git","permalink":"https://masteryang4.github.io/categories/Git/"},{"name":"Github","slug":"Git/Github","permalink":"https://masteryang4.github.io/categories/Git/Github/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://masteryang4.github.io/tags/Git/"},{"name":"Github","slug":"Github","permalink":"https://masteryang4.github.io/tags/Github/"}]},{"title":"关于i=i++的分析与思考","slug":"关于i-i-的分析与思考","date":"2020-04-10T16:00:30.000Z","updated":"2020-04-10T16:00:30.426Z","comments":true,"path":"2020/04/11/关于i-i-的分析与思考/","link":"","permalink":"https://masteryang4.github.io/2020/04/11/%E5%85%B3%E4%BA%8Ei-i-%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"关于HashMap的两道小面试题","slug":"关于HashMap的两道小面试题","date":"2020-04-10T16:00:16.000Z","updated":"2020-04-10T16:00:16.927Z","comments":true,"path":"2020/04/11/关于HashMap的两道小面试题/","link":"","permalink":"https://masteryang4.github.io/2020/04/11/%E5%85%B3%E4%BA%8EHashMap%E7%9A%84%E4%B8%A4%E9%81%93%E5%B0%8F%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"String源码简析","slug":"String源码简析","date":"2020-04-10T16:00:03.000Z","updated":"2020-04-10T16:00:03.340Z","comments":true,"path":"2020/04/11/String源码简析/","link":"","permalink":"https://masteryang4.github.io/2020/04/11/String%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java中final关键字解析","slug":"Java中final关键字解析","date":"2020-04-10T15:59:41.000Z","updated":"2020-04-10T15:59:41.394Z","comments":true,"path":"2020/04/10/Java中final关键字解析/","link":"","permalink":"https://masteryang4.github.io/2020/04/10/Java%E4%B8%ADfinal%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java静态代码块的加载时机","slug":"Java静态代码块的加载时机","date":"2020-04-10T15:57:07.000Z","updated":"2020-04-10T15:57:34.477Z","comments":true,"path":"2020/04/10/Java静态代码块的加载时机/","link":"","permalink":"https://masteryang4.github.io/2020/04/10/Java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/","excerpt":"","text":"Java静态代码块的加载时机在java中，静态代码块其实并不是随着类的加载而加载。","categories":[],"tags":[]},{"title":"SQL的执行顺序问题","slug":"SQL的执行顺序问题","date":"2020-04-10T15:44:24.000Z","updated":"2020-04-13T15:06:16.121Z","comments":true,"path":"2020/04/10/SQL的执行顺序问题/","link":"","permalink":"https://masteryang4.github.io/2020/04/10/SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/","excerpt":"","text":"SQL的执行顺序问题众所周知，sql的执行顺序： sql1from... where...group by... having....select ... order by... limit 但是，有一个“bug”，在 MySQL 中： sql1SELECT title, COUNT(title) AS t FROM table GROUP BY title HAVING t &gt;= 2 这样的语句是可以执行的。 正常来说，having在select之前执行，但是却可以使用select的别名，这是为什么呢？ 查阅了一切资料，做出如下解释： 解释一 mysql的处理方式是中间生成虚拟表（或者叫临时表），而这个虚拟表的生成的列靠的就是select。 所以猜测类似having之后的操作，其实内部已经根据select生成了虚拟表，列自然也是as后的。 解释二 之所以MYSQL可以这么做是因为MYSQL用的是临时表， 在having前已经产生了数据，所以可以用别名，但SQL Sever不可以，SQL是在having后才Select。","categories":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/categories/SQL/"},{"name":"MySQL","slug":"SQL/MySQL","permalink":"https://masteryang4.github.io/categories/SQL/MySQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://masteryang4.github.io/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"https://masteryang4.github.io/tags/MySQL/"}]},{"title":"LeetCode经典10道题","slug":"LeetCode经典10道题","date":"2020-03-22T15:36:52.000Z","updated":"2020-04-13T15:08:49.546Z","comments":true,"path":"2020/03/22/LeetCode经典10道题/","link":"","permalink":"https://masteryang4.github.io/2020/03/22/LeetCode%E7%BB%8F%E5%85%B810%E9%81%93%E9%A2%98/","excerpt":"","text":"LeetCode题目精选 两数之和 链接：https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 Code1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题解： java12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 爬楼梯 链接：https://leetcode-cn.com/problems/climbing-stairs/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： Code12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： Code123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 题解： java1234567891011121314public class Solution &#123; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125; 翻转二叉树 链接：https://leetcode-cn.com/problems/invert-binary-tree/ 翻转一棵二叉树。 示例： 输入： Code12345 4 &#x2F; \\ 2 7 &#x2F; \\ &#x2F; \\1 3 6 9 输出： Code12345 4 &#x2F; \\ 7 2 &#x2F; \\ &#x2F; \\9 6 3 1 题解： java12345678910public TreeNode invertTree(TreeNode root) &#123; if (root == null) &#123; return null; &#125; TreeNode right = invertTree(root.right); TreeNode left = invertTree(root.left); root.left = right; root.right = left; return root;&#125; 反转链表 链接：https://leetcode-cn.com/problems/reverse-linked-list/ 反转一个单链表。 示例: Code12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 题解： java1234567891011public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; &#125; return prev;&#125; LRU缓存机制 链接：https://leetcode-cn.com/problems/lru-cache/ 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: Code1234567891011LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );cache.put(1, 1);cache.put(2, 2);cache.get(1); &#x2F;&#x2F; 返回 1cache.put(3, 3); &#x2F;&#x2F; 该操作会使得密钥 2 作废cache.get(2); &#x2F;&#x2F; 返回 -1 (未找到)cache.put(4, 4); &#x2F;&#x2F; 该操作会使得密钥 1 作废cache.get(1); &#x2F;&#x2F; 返回 -1 (未找到)cache.get(3); &#x2F;&#x2F; 返回 3cache.get(4); &#x2F;&#x2F; 返回 4 题解： java12345678910111213141516171819202122232425262728class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123; private int capacity; public LRUCache(int capacity) &#123; super(capacity, 0.75F, true); this.capacity = capacity; &#125; public int get(int key) &#123; return super.getOrDefault(key, -1); &#125; public void put(int key, int value) &#123; super.put(key, value); &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123; return size() &gt; capacity; &#125;&#125;/** * LRUCache 对象会以如下语句构造和调用: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 最长回文子串 链接：https://leetcode-cn.com/problems/longest-palindromic-substring/ 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： Code123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： Code12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 题解： java1234567891011121314151617181920212223public String longestPalindrome(String s) &#123; if (s == null || s.length() &lt; 1) return \"\"; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125;private int expandAroundCenter(String s, int left, int right) &#123; int L = left, R = right; while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1;&#125; 有效的括号 链接：https://leetcode-cn.com/problems/valid-parentheses/ 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 1. 左括号必须用相同类型的右括号闭合。 2. 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: Code12输入: &quot;()&quot;输出: true 示例 2: Code12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3: Code12输入: &quot;(]&quot;输出: false 示例 4: Code12输入: &quot;([)]&quot;输出: false 示例 5: Code12输入: &quot;&#123;[]&#125;&quot;输出: true 题解： java1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; // Hash table that takes care of the mappings. private HashMap&lt;Character, Character&gt; mappings; // Initialize hash map with mappings. This simply makes the code easier to read. public Solution() &#123; this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); this.mappings.put('&#125;', '&#123;'); this.mappings.put(']', '['); &#125; public boolean isValid(String s) &#123; // Initialize a stack to be used in the algorithm. Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); // If the current character is a closing bracket. if (this.mappings.containsKey(c)) &#123; // Get the top element of the stack. If the stack is empty, set a dummy value of '#' char topElement = stack.empty() ? '#' : stack.pop(); // If the mapping for this bracket doesn't match the stack's top element, return false. if (topElement != this.mappings.get(c)) &#123; return false; &#125; &#125; else &#123; // If it was an opening bracket, push to the stack. stack.push(c); &#125; &#125; // If the stack still contains elements, then it is an invalid expression. return stack.isEmpty(); &#125;&#125; 数组中的第K个最大元素 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/ 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: Code12输入: [3,2,1,5,6,4] 和 k &#x3D; 2输出: 5 示例 2: Code12输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 题解： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Random;class Solution &#123; int [] nums; public void swap(int a, int b) &#123; int tmp = this.nums[a]; this.nums[a] = this.nums[b]; this.nums[b] = tmp; &#125; public int partition(int left, int right, int pivot_index) &#123; int pivot = this.nums[pivot_index]; // 1. move pivot to end swap(pivot_index, right); int store_index = left; // 2. move all smaller elements to the left for (int i = left; i &lt;= right; i++) &#123; if (this.nums[i] &lt; pivot) &#123; swap(store_index, i); store_index++; &#125; &#125; // 3. move pivot to its final place swap(store_index, right); return store_index; &#125; public int quickselect(int left, int right, int k_smallest) &#123; /* Returns the k-th smallest element of list within left..right. */ if (left == right) // If the list contains only one element, return this.nums[left]; // return that element // select a random pivot_index Random random_num = new Random(); int pivot_index = left + random_num.nextInt(right - left); pivot_index = partition(left, right, pivot_index); // the pivot is on (N - k)th smallest position if (k_smallest == pivot_index) return this.nums[k_smallest]; // go left side else if (k_smallest &lt; pivot_index) return quickselect(left, pivot_index - 1, k_smallest); // go right side return quickselect(pivot_index + 1, right, k_smallest); &#125; public int findKthLargest(int[] nums, int k) &#123; this.nums = nums; int size = nums.length; // kth largest is (N - k)th smallest return quickselect(0, size - 1, size - k); &#125;&#125; 实现 Trie (前缀树) 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Code12345678Trie trie &#x3D; new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); &#x2F;&#x2F; 返回 truetrie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 falsetrie.startsWith(&quot;app&quot;); &#x2F;&#x2F; 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); &#x2F;&#x2F; 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 题解： java1234567891011121314151617181920212223242526272829303132333435363738394041class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char currentChar = word.charAt(i); if (!node.containsKey(currentChar)) &#123; node.put(currentChar, new TrieNode()); &#125; node = node.get(currentChar); &#125; node.setEnd(); &#125; // search a prefix or whole key in trie and // returns the node where search ends private TrieNode searchPrefix(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char curLetter = word.charAt(i); if (node.containsKey(curLetter)) &#123; node = node.get(curLetter); &#125; else &#123; return null; &#125; &#125; return node; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); &#125;&#125; 编辑距离 链接：https://leetcode-cn.com/problems/edit-distance/ 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 1. 插入一个字符 2. 删除一个字符 3. 替换一个字符 示例 1: Code123456输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;) 示例 2: Code12345678输入: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;) 题解： java1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public int minDistance(String word1, String word2) &#123; int n = word1.length(); int m = word2.length(); // if one of the strings is empty if (n * m == 0) return n + m; // array to store the convertion history int [][] d = new int[n + 1][m + 1]; // init boundaries for (int i = 0; i &lt; n + 1; i++) &#123; d[i][0] = i; &#125; for (int j = 0; j &lt; m + 1; j++) &#123; d[0][j] = j; &#125; // DP compute for (int i = 1; i &lt; n + 1; i++) &#123; for (int j = 1; j &lt; m + 1; j++) &#123; int left = d[i - 1][j] + 1; int down = d[i][j - 1] + 1; int left_down = d[i - 1][j - 1]; if (word1.charAt(i - 1) != word2.charAt(j - 1)) left_down += 1; d[i][j] = Math.min(left, Math.min(down, left_down)); &#125; &#125; return d[n][m]; &#125;&#125;","categories":[],"tags":[]},{"title":"HashMap底层实现源码分析","slug":"HashMap底层实现源码分析","date":"2020-03-16T15:21:13.000Z","updated":"2020-03-16T15:21:51.836Z","comments":true,"path":"2020/03/16/HashMap底层实现源码分析/","link":"","permalink":"https://masteryang4.github.io/2020/03/16/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"HashMap底层实现原理0.样例数据java123456789101112131415161718192021222324252627282930313233343536373839import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class CollectionTest &#123; public static void main(String[] args) &#123; //唯一的工作初始化负债因子（this.loadFactor = DEFAULT_LOAD_FACTOR）为0.75f Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); int count = 1; //添加kv for (char i = 65; i &lt; 91; i++) &#123; map.put(String.valueOf(i),count); count++; &#125; //第一种遍历方式 Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; iterator = keySet.iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); System.out.println(key+ \" =&gt; \" + map.get(key)); &#125; System.out.println(\"******************************\"); //第二种遍历方式 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iteratorMap = map.entrySet().iterator(); while (iteratorMap.hasNext()) &#123; Map.Entry&lt;String, Integer&gt; mapEntry = iteratorMap.next(); System.out.println(mapEntry); &#125; System.out.println(\"******************************\"); //第三种遍历方式 for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + \" =&gt; \" + entry.getValue()); &#125; &#125;&#125; 1. 类信息java1public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 2. 基本属性java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125private static final long serialVersionUID = 362498820763181265L; //序列化版本号static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默认容量16(左移4位相当于乘以2的4次方)static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//最大容量（1073741824）static final float DEFAULT_LOAD_FACTOR = 0.75f;//默认负载因子static final int TREEIFY_THRESHOLD = 8; //链表节点转换红黑树节点的阈值static final int UNTREEIFY_THRESHOLD = 6; //红黑树节点转换链表节点的阈值static final int MIN_TREEIFY_CAPACITY = 64;// 转红黑树时, table的最小长度// 基本hash节点, 继承自Entry，此时的Node节点就是相当于Entry节点的实现static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125;transient Node&lt;K,V&gt;[] table; //hashMap数组的表示transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //entry节点transient int size; //数组长度transient int modCount; //添加的元素个数int threshold; //合理的初始化数组长度，根据tableSizeFor()得到，用于手动设置时使用final float loadFactor; //负载因子，用于手动设置时使用//构造器一：定义Node[]数组初始长度public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); //为Node[]数组设置负债因子 this.loadFactor = loadFactor; //为Node[]数组设置一个合理的值 this.threshold = tableSizeFor(initialCapacity);&#125;//初始化Node[]数组长度，根据传入的值以2的n次方对数组进行扩容//（例如：存入传入值为9，数组容量为16，在(8,16]范围内将不会再次扩容）。static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= 1 &lt;&lt; 30) ? 1 &lt;&lt; 30 : n + 1;&#125;//构造器二：调用HashMap(int initialCapacity, float loadFactor)构造器public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;//构造器三：仅创建HashMap对象，并初始化负债因子为0.75fpublic HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR;&#125;// 红黑树节点static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; //...&#125; 3. hash算法HashMap定位数组索引位置，直接决定了hash方法的离散性能。下面是定位哈希桶数组的源码： java123456789101112131415161718192021222324252627// 计算key的hash值static final int hash(Object key) &#123; int h; // 1.先拿到key的hashCode值,基本数据类型会使用其包装类重载的hashCode()方法去计算hash值，引用数据类型根据是否重写去计算 // 2.将hashCode的高16位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; // 将(tab.length - 1) 与 hash值进行&amp;运算 int index = (tab.length - 1) &amp; hash;&#125;//对值进行Hash计算public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = valu /** * 当KEY值为A测试数据，A的hash为: 31 * hash + ANSI码值65 * 当KEY值为AB测试数据，AB的hash为：31 * 65 + 66 */ for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; HashMap底层数组的长度总是2的n次方，并且取模运算为“h mod table.length”，对应上面的公式，可以得到该运算等同于“h &amp; (table.length - 1)”。这是HashMap在速度上的优化，因为&amp;比%具有更高的效率。 在JDK1.8的实现中，还优化了高位运算的算法，将hashCode的高16位与hashCode进行异或运算，主要是为了在table的length较小的时候，让高位也参与运算，并且不会有太大的开销。 4. get方法java1234567891011121314151617181920212223242526272829303132//调用的GET方法public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;//实际执行的GET方法final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // table不为空 &amp;&amp; table长度大于0 &amp;&amp; table索引位置(根据hash值计算出)节点不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // first的key等于传入的key则返回first对象 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //first的key不等于传入的key则说明是链表，向下遍历 if ((e = first.next) != null) &#123; // 判断是否为TreeNode，是则为红黑树 // 如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //走下列步骤表示是链表，循环至节点的key与传入的key值相等 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; //找不到符合的返回空 return null;&#125; 5. put方法java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//掉用的PUT方法，hash(key)调用本例中的hash()方法public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; //实际执行的PUT方法 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table是否为空或者length等于0, 如果是则调用resize方法进行初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 通过hash值计算索引位置, 如果table表该索引位置节点为空则新增一个 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 将索引位置的头节点赋值给p tab[i] = newNode(hash, key, value, null); else &#123; // table表该索引位置不为空 Node&lt;K,V&gt; e; K k; //判断p节点的hash值和key值是否跟传入的hash值和key值相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果相等, 则p节点即为要查找的目标节点，赋值给e // 判断p节点是否为TreeNode, 如果是则调用红黑树的putTreeVal方法查找目标节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 走到这代表p节点为普通链表节点 else &#123; // 遍历此链表, binCount用于统计节点数 for (int binCount = 0; ; ++binCount) &#123; //p.next为空代表目标节点不存在 if ((e = p.next) == null) &#123; //新增一个节点插入链表尾部 p.next = newNode(hash, key, value, null); //如果节点数目超过8个，调用treeifyBin方法将该链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //e节点的hash值和key值都与传入的相等, 则e即为目标节点,跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // e不为空则代表根据传入的hash值和key值查找到了节点,将该节点的value覆盖,返回oldValue if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 用于LinkedHashMap return oldValue; &#125; &#125; //map修改次数加1 ++modCount; //map节点数加1，如果超过阀值，则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); // 用于LinkedHashMap return null;&#125; 从上面的源码分析可以看出 1、如果节点已经存在，则更新原值 2、如果节点不存在，则插入数组中，如果数组已经有值，则判断是非是红黑树，如果是，则调用红黑树方法插入 3、如果插入的是链表，插入尾部，然后判断节点数是否超过8，如果超过，则转换为红黑树 4、先插入的数据，后面判断是否超过阀值再进行的扩容 putTreeVal,插入红黑树方法就不看了，看下treeifyBin方法，该方法是将链表转化为红黑树, java123456789101112131415161718192021222324final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; // table为空或者table的长度小于64, 进行扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); // 根据hash值计算索引值, 遍历该索引位置的链表 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); // 链表节点转红黑树节点 if (tl == null) // tl为空代表为第一次循环 hd = p; // 头结点 else &#123; p.prev = tl; // 当前节点的prev属性设为上一个节点 tl.next = p; // 上一个节点的next属性设置为当前节点 &#125; tl = p; // tl赋值为p, 在下一次循环中作为上一个节点 &#125; while ((e = e.next) != null); // e指向下一个节点 // 将table该索引位置赋值为新转的TreeNode的头节点 if ((tab[index] = hd) != null) hd.treeify(tab); // 以头结点为根结点, 构建红黑树 &#125;&#125; 可以看到，会先判断tab的节点数是否超过64，如果没超过，则进行扩容，如果超过了才会转换为红黑树 可以得到两个结论 1、什么时候转换为红黑树 当链表数目超过8,并且map节点数量超过64，才会转换为红黑树 2、什么时候扩容（前提是map数目没有超过最大容量值 1&lt;&lt;30 ） 新增节点时，发生了碰撞，并且节点数目超过阀值 新增节点时，发生了碰撞，节点数量木有超过阀值，但是链表数目&gt;8,map节点&lt;64时 再看下resize()方法 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788final Node&lt;K,V&gt;[] resize() &#123; //oldTab保存未扩容的tab Node&lt;K,V&gt;[] oldTab = table; //oldTab最大容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; //oldTab阀值 int oldThr = threshold; int newCap, newThr = 0; //如果老map有值 if (oldCap &gt; 0) &#123; // 老table的容量超过最大容量值，设置阈值为Integer.MAX_VALUE，返回老表 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; //老table的容量没有超过最大容量值，将新容量赋值为老容量*2，如果新容量&lt;最大容量并且老容量&gt;=16, 则将新阈值设置为原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // 老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值 newCap = oldThr; // 则将新表的容量设置为老表的阈值 else &#123; //老表的容量为0, 老表的阈值为0, 则为空表，设置默认容量和阈值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 如果新阈值为空, 则通过新的容量*负载因子获得新阈值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; // 将当前阈值赋值为刚计算出来的新的阈值 threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 将当前的表赋值为新定义的表 // 如果老表不为空, 则需遍历将节点赋值给新表 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; // 将索引值为j的老表头节点赋值给e oldTab[j] = null; //将老表的节点设置为空, 以便垃圾收集器回收空间 // 如果e.next为空, 则代表老表的该位置只有1个节点, // 通过hash值计算新表的索引位置, 直接将该节点放在该位置 if (e.next == null) // newTab[e.hash &amp; (newCap - 1)] = e; //e.next不为空,判断是否是红黑树 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //是普通链表 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; //如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为: // 老表的索引位置＋oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; // 最后一个节点的next设为空 newTab[j] = loHead; // 将原索引位置的节点设置为对应的头结点 &#125; if (hiTail != null) &#123; hiTail.next = null; // 最后一个节点的next设为空 newTab[j + oldCap] = hiHead; // 将索引位置为原索引+oldCap的节点设置为对应的头结点 &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 可以看出，扩容时，节点重hash只分布在原索引位置与原索引+oldCap位置，为什么呢 假设老表的容量为16，即oldCap=16，则新表容量为16*2=32，假设节点1的hash值为0000 0000 0000 0000 0000 1111 0000 1010，节点2的hash值为0000 0000 0000 0000 0000 1111 0001 1010，则节点1和节点2在老表的索引位置计算如下图计算1，由于老表的长度限制，节点1和节点2的索引位置只取决于节点hash值的最后4位。再看计算2，计算2为新表的索引计算，可以知道如果两个节点在老表的索引位置相同，则新表的索引位置只取决于节点hash值倒数第5位的值，而此位置的值刚好为老表的容量值16，此时节点在新表的索引位置只有两种情况：原索引位置和原索引+oldCap位置（在此例中即为10和10+16=26）。由于结果只取决于节点hash值的倒数第5位，而此位置的值刚好为老表的容量值16，因此此时新表的索引位置的计算可以替换为计算3，直接使用节点的hash值与老表的容量16进行位于运算，如果结果为0则该节点在新表的索引位置为原索引位置，否则该节点在新表的索引位置为原索引+oldCap位置。 6. remove()方法java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 如果table不为空并且根据hash值计算出来的索引位置不为空, 将该位置的节点赋值给p if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; // 如果p的hash值和key都与入参的相同, 则p即为目标节点, 赋值给node if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; // 否则向下遍历节点 if (p instanceof TreeNode) // 如果p是TreeNode则调用红黑树的方法查找节点 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; // 遍历链表查找符合条件的节点 // 当节点的hash值和key与传入的相同,则该节点即为目标节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; // 赋值给node, 并跳出循环 break; &#125; p = e; // p节点赋值为本次结束的e &#125; while ((e = e.next) != null); // 指向像一个节点 &#125; &#125; // 如果node不为空(即根据传入key和hash值查找到目标节点)，则进行移除操作 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) // 如果是TreeNode则调用红黑树的移除方法 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 走到这代表节点是普通链表节点 // 如果node是该索引位置的头结点则直接将该索引位置的值赋值为node的next节点 else if (node == p) tab[index] = node.next; // 否则将node的上一个节点的next属性设置为node的next节点, // 即将node节点移除, 将node的上下节点进行关联(链表的移除) else p.next = node.next; ++modCount; // 修改次数+1 --size; // table的总节点数-1 afterNodeRemoval(node); // 供LinkedHashMap使用 return node; // 返回被移除的节点 &#125; &#125; return null;&#125; 7. JDK1.7和1.8的区别1、JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（n）变成O（logN）提高了效率） 2、JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。 3、扩容后数据存储位置的计算方式也不一样：1. 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1），而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。 4、jdk1.7 先扩容再put ，jdk1.8 先put再扩容","categories":[],"tags":[]},{"title":"Comparable和Comparator底层源码分析","slug":"Comparable和Comparator底层源码分析","date":"2020-03-15T15:52:58.000Z","updated":"2020-03-15T15:57:09.181Z","comments":true,"path":"2020/03/15/Comparable和Comparator底层源码分析/","link":"","permalink":"https://masteryang4.github.io/2020/03/15/Comparable%E5%92%8CComparator%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"1. Comparable源码分析1.1创建Java工程，实现Comparable接口java123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.Serializable;//实现Serializable，标识该类可被序列化//实现Comparable接口，让此类可以利用Collections.sort()进行排序public class User&lt;T extends User&gt; implements Serializable,Comparable&lt;T&gt;&#123; private String name; private int age; private transient String address;//transient修饰，标识该类序列化时此字段不需要进行存储 public User(String name)&#123; this.name = name; &#125; public User(String name,int age,String address)&#123; this(name); this.age = age; this.address = address; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getAddress() &#123; return address; &#125; @Override public int compareTo(T o) &#123; //在此处打上断点，方便进行调试 int returnInt = 0; if(age&gt;o.getAge())&#123; returnInt=1; &#125;else if(age==o.getAge())&#123; returnInt=0; &#125;else if(age&lt;o.getAge())&#123; returnInt=-1; &#125; return returnInt; &#125;&#125; 1.2 编写测试类java123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Collections;import java.util.List;public class TestComparable &#123; public static void main(String[] args) &#123; User u1 = new User(\"caililiang1\",20,\"hubei1\"); User u2 = new User(\"caililiang2\",30,\"hubei2\"); User u3 = new User(\"caililiang3\",25,\"hubei3\"); User u4 = new User(\"caililiang4\",28,\"hubei4\"); User u5 = new User(\"caililiang5\",23,\"hubei5\"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); list.add(u5); for(int i=0;i&lt;list.size();i++)&#123; User u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; System.out.println(\"排序后---------------------\"); //在此处打上断点，方便进行调试 Collections.sort(list); for(int i=0;i&lt;list.size();i++)&#123; User u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; &#125;&#125; 1.3 Collections类中的泛型方法sort()java1234567// 此处 &lt;T extends Comparable&lt;? super T&gt;&gt; 的意思是：// 1.&lt;T extends Comparable&gt;表示比较对象的类必须是Comparable 的子类。// 2.Comparable&lt;? super T&gt;表示是Comparable实现类及以上。public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123; //调用List接口中的sort()方法 list.sort(null); &#125; 1.4 List接口中的默认方法sort()java1234567891011// 由于本例中采用的是ArrayList集合，ArrayList集合对List接口中的sort()方法进行了重写，// 因此实际在DeBug的过程中会执行ArrayLIst类中的sort()方法 default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125; &#125; 1.5 ArrayList集合中的方法sort()java1234567891011@Override@SuppressWarnings(\"unchecked\")public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; //此方法直接调用Arrays类中sort()方法 Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 1.6 Arrays类中的sort()方法java12345678910111213141516171819202122public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c) &#123; //在1.3中传入的 c值为null,所以调用sort(a, fromIndex, toIndex)方法 if (c == null) &#123; sort(a, fromIndex, toIndex); &#125; else &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); &#125;&#125;public static void sort(Object[] a, int fromIndex, int toIndex) &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) //归并排序 legacyMergeSort(a, fromIndex, toIndex); else //二进制插入排序 ComparableTimSort.sort(a, fromIndex, toIndex, null, 0, 0);&#125; 解析：源码里首先判断是否采用传统的排序方法,LegacyMergeSort.userRequested属性默认为false,也就是说默认选中 ComparableTimSort.sort(a)方法(传统归并排序在1.5及之前是默认排序方法，1.5之后默认执行ComparableTimSort.sort()方法。除非程序中强制要求使用传统归并排序,语句如下：System.setProperty(“java.util.Arrays.useLegacyMergeSort”, “true”))继续看 ComparableTimSort.sort(a)源码 1.7 ComparableTimSort类中的sort()方法java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) &#123; assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; //nRemaining表示没有排序的对象个数，方法执行前，如果这个数小于2，就不需要排序了。 //如果2&lt;= nRemaining &lt;=32,即MIN_MERGE的初始值，表示需要排序的数组是小数组 //可以使用mini-TimSort方法进行排序，否则需要使用归并排序。 int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a \"mini-TimSort\" with no merges if (nRemaining &lt; MIN_MERGE) &#123; //调用重写的compareTo()方法 int initRunLen = countRunAndMakeAscending(a, lo, hi); //只看这一句 binarySort(a, lo, hi, lo + initRunLen); return; &#125; ...... &#125;//这里才是真正的调用compareTo()方法对当前对象进行比较 private static int countRunAndMakeAscending(Object[] a, int lo, int hi) &#123; assert lo &lt; hi; int runHi = lo + 1; if (runHi == hi) return 1; // Find end of run, and reverse range if descending if (((Comparable) a[runHi++]).compareTo(a[lo]) &lt; 0) &#123; // 降序排列 while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &lt; 0) runHi++; reverseRange(a, lo, runHi); &#125; else &#123;// 升序排列 while (runHi &lt; hi &amp;&amp; ((Comparable) a[runHi]).compareTo(a[runHi - 1]) &gt;= 0) runHi++; &#125; return runHi - lo; &#125;//这里才是真正的进行排序。 private static void binarySort(Object[] a, int lo, int hi, int start) &#123; assert lo &lt;= start &amp;&amp; start &lt;= hi; if (start == lo) start++; for ( ; start &lt; hi; start++) &#123; Comparable pivot = (Comparable) a[start]; // Set left (and right) to the index where a[start] (pivot) belongs int left = lo; int right = start; assert left &lt;= right; /* * Invariants: * pivot &gt;= all in [lo, left). * pivot &lt; all in [right, start). */ while (left &lt; right) &#123; int mid = (left + right) &gt;&gt;&gt; 1; if (pivot.compareTo(a[mid]) &lt; 0) right = mid; else left = mid + 1; &#125; assert left == right; /* * The invariants still hold: pivot &gt;= all in [lo, left) and * pivot &lt; all in [left, start), so pivot belongs at left. Note * that if there are elements equal to pivot, left points to the * first slot after them -- that's why this sort is stable. * Slide elements over to make room for pivot. */ int n = start - left; // The number of elements to move // Switch is just an optimization for arraycopy in default case switch (n) &#123; case 2: a[left + 2] = a[left + 1]; case 1: a[left + 1] = a[left]; break; default: System.arraycopy(a, left, a, left + 1, n); &#125; a[left] = pivot; &#125; &#125; 2. Comparator源码分析2.1 创建JavaBeanjava123456789101112131415161718192021222324252627282930import java.io.Serializable;public class People implements Serializable &#123; private String name; private int age; private transient String address;//transient修饰，标识该类序列化时此字段不需要进行存储 public People(String name)&#123; this.name = name; &#125; public People(String name,int age,String address)&#123; this(name); this.age = age; this.address = address; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getAddress() &#123; return address; &#125;&#125; 2.2 创建外部比较器java123456789101112131415import java.util.Comparator;public class PeopleComparator&lt;T extends People&gt; implements Comparator&lt;T&gt; &#123; public int compare(T o1, T o2) &#123; int returnInt = 0; if(o1.getAge()&gt;o2.getAge())&#123; returnInt = 1; &#125;else if(o1.getAge()==o2.getAge())&#123; returnInt = 0; &#125;else if(o1.getAge()&lt;o2.getAge())&#123; returnInt = -1; &#125; return returnInt; &#125;&#125; 2.3 创建测试类java12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;import java.util.List;public class TestComparator &#123; public static void main(String[] args) &#123; People u1 = new People(\"caililiang1\",20,\"hubei1\"); People u2 = new People(\"caililiang2\",30,\"hubei2\"); People u3 = new People(\"caililiang3\",25,\"hubei3\"); People u4 = new People(\"caililiang4\",28,\"hubei4\"); People u5 = new People(\"caililiang5\",23,\"hubei5\"); List&lt;People&gt; list = new ArrayList&lt;People&gt;(); list.add(u1); list.add(u2); list.add(u3); list.add(u4); list.add(u5); for(int i=0;i&lt;list.size();i++)&#123; People u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; System.out.println(\"排序后---------------------\"); Collections.sort(list,new PeopleComparator()); for(int i=0;i&lt;list.size();i++)&#123; People u =list.get(i); System.out.println(u.getName()+\"---&gt;\"+u.getAge()); &#125; &#125;&#125; 2.4 Collections类中的泛型方法sort()java12345 @SuppressWarnings(&#123;\"unchecked\", \"rawtypes\"&#125;)//此处调用的是sort方法的重载方法，与案例一中不同 public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c); &#125; 2.5 ArrayList集合中的方法sort()java12345678910@Override@SuppressWarnings(\"unchecked\")public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 2.6 Arrays类中的sort()方法java123456789101112public static &lt;T&gt; void sort(T[] a, int fromIndex, int toIndex, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a, fromIndex, toIndex); &#125; else &#123; rangeCheck(a.length, fromIndex, toIndex); if (LegacyMergeSort.userRequested) legacyMergeSort(a, fromIndex, toIndex, c); else //本次进入这里进行排序 TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0); &#125;&#125; 2.7 TimSort类下的sort()方法java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static &lt;T&gt; void sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c, T[] work, int workBase, int workLen) &#123; assert c != null &amp;&amp; a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length; int nRemaining = hi - lo; if (nRemaining &lt; 2) return; // Arrays of size 0 and 1 are always sorted // If array is small, do a \"mini-TimSort\" with no merges if (nRemaining &lt; MIN_MERGE) &#123; int initRunLen = countRunAndMakeAscending(a, lo, hi, c); binarySort(a, lo, hi, lo + initRunLen, c); return; &#125; private static &lt;T&gt; void binarySort(T[] a, int lo, int hi, int start, Comparator&lt;? super T&gt; c) &#123; assert lo &lt;= start &amp;&amp; start &lt;= hi; if (start == lo) start++; for ( ; start &lt; hi; start++) &#123; T pivot = a[start]; // Set left (and right) to the index where a[start] (pivot) belongs int left = lo; int right = start; assert left &lt;= right; /* * Invariants: * pivot &gt;= all in [lo, left). * pivot &lt; all in [right, start). */ while (left &lt; right) &#123; int mid = (left + right) &gt;&gt;&gt; 1; if (c.compare(pivot, a[mid]) &lt; 0) right = mid; else left = mid + 1; &#125; assert left == right; /* * The invariants still hold: pivot &gt;= all in [lo, left) and * pivot &lt; all in [left, start), so pivot belongs at left. Note * that if there are elements equal to pivot, left points to the * first slot after them -- that's why this sort is stable. * Slide elements over to make room for pivot. */ int n = start - left; // The number of elements to move // Switch is just an optimization for arraycopy in default case switch (n) &#123; case 2: a[left + 2] = a[left + 1]; case 1: a[left + 1] = a[left]; break; default: System.arraycopy(a, left, a, left + 1, n); &#125; a[left] = pivot; &#125;&#125; 3. 总结 Comparable 此接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo()方法被称为它的自然比较方法。 实现此接口的对象列表（集合和数组）可以通过 Collections.sort和 Arrays.sort 进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。 Arrays.sort(people) Comparator 是比较器，排序时，需要新建比较器对象，将比较器和对象一起传递过去就可以比大小，可称为“外部排序”。比较器是定义在要比较对象的外部的, 必须要重写compare()方法，而需要比较的类的结构不需要有任何变化。并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。 Arrays.sort(people,new PersonCompartor()); 关于两个类的具体应用场景可以理解为，自己在创建一个工程时可以使用Comparable进行排序，当工程创建完毕时添加新的排序功能时，可以使用Comparator，无需改变类的结构。","categories":[],"tags":[]},{"title":"Hexo博客安装及部署","slug":"Hexo博客安装及部署","date":"2020-03-12T06:40:31.000Z","updated":"2020-03-12T06:54:39.177Z","comments":true,"path":"2020/03/12/Hexo博客安装及部署/","link":"","permalink":"https://masteryang4.github.io/2020/03/12/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E5%8F%8A%E9%83%A8%E7%BD%B2/","excerpt":"安装nodejs node -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本 hexo安装及配置 hexo -v #查看hexo版本mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n “我的第一篇文章” #创建新的文章 在blog目录下","text":"安装nodejs node -v #查看node版本npm -v #查看npm版本npm install -g cnpm –registry=http://registry.npm.taobao.org #安装淘宝的cnpm 管理器cnpm -v #查看cnpm版本 hexo安装及配置 hexo -v #查看hexo版本mkdir blog #创建blog目录cd blog #进入blog目录sudo hexo init #生成博客 初始化博客 hexo s #启动本地博客服务http://localhost:4000/ #本地访问地址hexo n “我的第一篇文章” #创建新的文章 在blog目录下 hexo clean #清理hexo g #生成#Github创建一个新的仓库 YourGithubName.github.iocnpm install –save hexo-deployer-git #在blog目录下安装git部署插件 配置_config.yml yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/YourGithubName/YourGithubName.github.io.gitbranch: master 部署到Github仓库里 hexo d https://YourGithubName.github.io/ #访问这个地址可以查看博客 yilia主题配置 下载yilia主题到本地 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 修改hexo根目录下的 _config.yml 文件 yml1theme: yilia 部署到github hexo clean #清理一下 hexo g #生成 hexo d #部署到远程Github仓库 查看博客 ： https://YourGithubName.github.io/","categories":[],"tags":[]},{"title":"ArrayList底层实现源码分析(JDK1.8)","slug":"ArrayList底层实现源码分析_JDK1.8","date":"2020-03-12T03:30:45.000Z","updated":"2020-03-12T06:17:54.055Z","comments":true,"path":"2020/03/12/ArrayList底层实现源码分析_JDK1.8/","link":"","permalink":"https://masteryang4.github.io/2020/03/12/ArrayList%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_JDK1.8/","excerpt":"1. 类信息1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; 2. 基本属性","text":"1. 类信息java1public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; 2. 基本属性 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//定义序列化ID，主要是为了表示不同的版本的兼容性private static final long serialVersionUID = 8683452581122892189L;//默认的数组存储容量(ArrayList底层是数组结构)private static final int DEFAULT_CAPACITY = 10;//当指定数组的容量为0时使用这个常量赋值private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//默认空参构造函数时使用这个常量赋值private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//真正存放数据的对象数组，transient标识不被序列化transient Object[] elementData;//数组中的真实元素个数，该值小于或等于elementData.lengthprivate int size;//最大数组长度：0x7fffffff - 8private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//构造器一：创建具有初始化长度的listpublic ArrayList(int initialCapacity) &#123; //对传入的值进行合法检测 if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;//构造器二：默认空参构造器public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//构造器三：创建具有初始化值的集合，可传入的集合类型父类是Collection即可，此处是多态的一个应用public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将传入的集合转化为数组 elementData = c.toArray(); //判断elementData数组长度 if ((size = elementData.length) != 0) &#123; // elementData转化的数组如果不是Object的子类，就对当前数组进行复制，重新赋值给elementData if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123;//如果数组长度为0，复制为EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 3. add(E e) 方法ArrayList集合创建时，默认初始化长度为0，通过add( )方法在添加元素时对数组长度进行动态赋值。添加第一个元素时，长度为10。当添加的元素个数超过10时，会进行首次扩容，容量为原数组长度的1.5倍。 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 //此方法是添加元素的方法，另外还有一个重载方法 public boolean add(E e) &#123; //调用ensureCapacityInternal方法，初始化数组长度（默认为10） ensureCapacityInternal(size + 1); //为数组复制 elementData[size++] = e; return true; &#125;//初始化数组长度，默认值为10 private void ensureCapacityInternal(int minCapacity) &#123; //判断如果数组长度为0，对长度进行初始化 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; //从默认数组长度（10）和添加的元素个数（添加第一个元素时size=0,minCapacity=size+1）中取出最大值 //作为数组初始化长度 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; //再次确定数组容量 ensureExplicitCapacity(minCapacity); &#125; //再次确定数组容量 private void ensureExplicitCapacity(int minCapacity) &#123; //对数组元素个数进行统计 modCount++; //如果数组长度超过10，就对数组长度进行扩容 //那第一次扩容举例：minCapacity值为11，DEFAULT_CAPACITY值为10 if (minCapacity - elementData.length &gt; 0) //对数组进行扩容，默认为老数组的1.5倍 grow(minCapacity); &#125; //对数组进行扩容，默认为老数组的1.5倍 private void grow(int minCapacity) &#123; //老数组容量：minCapacity int oldCapacity = elementData.length; //新数组容量：是老数组长度的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //对新数组容量进行合法检测 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //MAX_ARRAY_SIZE：0x7fffffff - 8 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //如果超过最大数组长度，再次进行扩容 newCapacity = hugeCapacity(minCapacity); //对原数组进行复制 elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //三元运算符，如果超过最大数组长度返回Integer最大值：0x7fffffff return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 4. add (int idnex,E element)从源码中可以看出，与add(E e)方法大致一致，主要的差异是增加了一行代码：System.arraycopy(elementData, index, elementData, index + 1, size - index)，从index位置开始以及之后的数据，整体拷贝到index+1开始的位置，然后再把新加入的数据放在index这个位置，而之前的数据不需要移动。 java123456789101112131415161718//在指定位置添加元素public void add(int index, E element) &#123; //判断index是否在范围内 rangeCheckForAdd(index); //与add(E e)方法一致，对数组长度进行初始化 ensureCapacityInternal(size + 1); //对原数组从index位置进行拷贝，复制到index+1的位置，elementData[index]此时为空 //System.arraycopy是一个native方法，意味着这个方法是C/C++语言实现的，我们无法再以普通的方式去查看这些方法了 System.arraycopy(elementData, index, elementData, index + 1, size - index); //为该下标赋值 elementData[index] = element; size++;&#125;//判断index是否在范围内的具体实现private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; arraycopy(elementData, index, elementData, index + 1, size - index)函数中各个参数对应的意义：（原数组，原数组的开始位置，目标数组，目标数组的开始位置，拷贝的个数） 5. remove(int index)java12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //移除指定index下的元素 public E remove(int index) &#123; //index是否合法检测 rangeCheck(index); modCount++; //指定index下的元素 E oldValue = elementData(index); //移除后数组长度 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); //为最后一个元素赋值为null elementData[--size] = null; return oldValue; &#125; //返回指定index下的元素E elementData(int index) &#123; return (E) elementData[index]; &#125; //根据元素（对象）移除该元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; //类似于remove()方法 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; &#125; remove方法与add正好是一个相反的操作，移除一个元素，会影响到一批数字的位置移动，所以也是比较耗性能。核心代码都是调用了java.lang.System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)方法 6. get(int index)java123456//根据指定下标获取元素值public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 7. set(int index, E element)java12345678//修改指定index下的元素值public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 8. clear()java12345678910//清空所有元素public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 9. contains(Object o)java1234567891011121314151617//查询是否包含某个元素public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;//具体的实现方法，如果不包含返回-1public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; 10. 总结 基于数组实现的List在随机访问和遍历的效率比较高，但是往指定位置加入元素或者删除指定位置的元素效率比较低。","categories":[],"tags":[]}]}